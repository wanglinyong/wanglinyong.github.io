<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang&#39;s Blog</title>
  
  
  <link href="/wanglinyong.github.io/atom.xml" rel="self"/>
  
  <link href="https://wanglinyong.github.io/"/>
  <updated>2018-06-04T13:03:22.445Z</updated>
  <id>https://wanglinyong.github.io/</id>
  
  <author>
    <name>WangLinYong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dockpanel动态添加picturebox并绑定图片</title>
    <link href="https://wanglinyong.github.io/2018/06/04/dockpanel%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0picturebox%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://wanglinyong.github.io/2018/06/04/dockpanel动态添加picturebox的方法/</id>
    <published>2018-06-04T12:59:40.000Z</published>
    <updated>2018-06-04T13:03:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。</p><h2 id="1-生成picturebox的方法"><a href="#1-生成picturebox的方法" class="headerlink" title="1.生成picturebox的方法"></a>1.生成picturebox的方法</h2><pre><code> public void generatorPictureBox(){    int imageNum = 20;//图片的数量    PictureBox[] pict;    pict = new PictureBox[imageNum];    for (int i = 1; i &lt; imageNum; i++)    {        pict[i] = new System.Windows.Forms.PictureBox();               pict[i].Location = new Point(5 , 10+(i - 1) * 60);//设置图片位置  竖向排列        pict[i].SizeMode = PictureBoxSizeMode.Zoom;        pict[i].Image = Image.FromFile(@&quot;D:\images\&quot; + i + &quot;.png&quot;);//导入图片        pict[i].Size = new Size(50, 50);//设置图片大小        pict[i].BorderStyle = BorderStyle.None;//取消边框        pict[i].Image.Tag = i;        pict[i].Click += singleClick;//给图片绑定点击事件        dockPanel1.Controls.Add(pict[i]); //添加picturebox    }}</code></pre><h2 id="2-给图片绑定的点击事件"><a href="#2-给图片绑定的点击事件" class="headerlink" title="2.给图片绑定的点击事件"></a>2.给图片绑定的点击事件</h2><pre><code>private void singleClick(object sender, EventArgs e)  {      PictureBox p = sender as PictureBox;             LOG.Info(&quot;Click===============imgIndex====&quot;+p.Image.Tag);  }</code></pre><h2 id="3-在窗体初始化的时候调用generatorPictureBox方法即可"><a href="#3-在窗体初始化的时候调用generatorPictureBox方法即可" class="headerlink" title="3.在窗体初始化的时候调用generatorPictureBox方法即可"></a>3.在窗体初始化的时候调用generatorPictureBox方法即可</h2><h2 id="4-效果如下："><a href="#4-效果如下：" class="headerlink" title="4.效果如下："></a>4.效果如下：</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/doc-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。&lt;/p&gt;
&lt;h2 id=&quot;1-生成picturebox的方法&quot;&gt;&lt;a href=&quot;#1-生成picturebox的方法&quot; class=&quot;he
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="picturebox" scheme="https://wanglinyong.github.io/tags/picturebox/"/>
    
      <category term="c#" scheme="https://wanglinyong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Xshell6下载安装</title>
    <link href="https://wanglinyong.github.io/2018/05/28/Xshell6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
    <id>https://wanglinyong.github.io/2018/05/28/Xshell6下载安装/</id>
    <published>2018-05-28T11:23:20.000Z</published>
    <updated>2018-05-29T11:44:50.606Z</updated>
    
    <content type="html"><![CDATA[<p>随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。</p><p> 1.进入xshell英文官网，链接地址如下：</p><pre><code>http://www.netsarang.com/products/main.html</code></pre><p>2.将鼠标悬浮在Download上会出现三个列表，点击第三个Free License,如下图：</p><p><img src="https://img-blog.csdn.net/20180528160438334" alt=""></p><p>或者点击Download，将窗口滚动到最下方，点击Free for Home &amp; School，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160452206" alt=""></p><p>3.之后会进入Xshell6和Xftp6的下载页面，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160508678" alt=""></p><p>4.点击Xshell6会跳转到填写个人信息的页面，打红星的是必填项，注意邮箱要正确，会将下载链接发到你的邮箱，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160523209" alt=""></p><p>5.填写好信息后，点击Submit提交，这时下载链接就会发送到你填写的邮箱了。</p><p>6.打开邮箱，点击链接进行下载，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160539725" alt=""></p><p>7.下载完成后根据提示进行安装即可。</p><p>xshell6下载完成以后，一般还需要配合xftp6文件上传工具使用，下载步骤同上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。&lt;/p&gt;
&lt;p&gt; 1.进入xshell英文官网，链接地址如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零开始开发SSM项目-博客系统实战</title>
    <link href="https://wanglinyong.github.io/2018/05/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91SSM%E9%A1%B9%E7%9B%AE-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://wanglinyong.github.io/2018/05/26/从零开始开发SSM项目-博客系统实战/</id>
    <published>2018-05-26T11:30:28.000Z</published>
    <updated>2018-05-26T11:30:45.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、项目包含功能"><a href="#一、项目包含功能" class="headerlink" title="一、项目包含功能"></a>一、项目包含功能</h1><p>使用SSM框架开发一个博客系统，包含的功能大致有:</p><p>1.用户注册与激活，激活方式通过邮件激活</p><p>2.用户的登录和退出，包括账号登录和手机快捷登录</p><p>3.用户账号登录和注册时需要输入验证码验证</p><p>4.首页展示及分页，主要展示文章内容，可进行搜索，将搜索结果高亮显示</p><p>5.首页文章的点赞、踩和评论功能</p><p>6.个人主页模块，包括个人的基本信息，梦分类，发布梦，管理梦以及热梦推荐等</p><p>7.书写文章功能</p><p>8.文章管理功能，包括文章的查看、修改和删除</p><p>9.个人信息修改功能</p><p>10.安全框架 spring-security 的整合，对不符合条件的用户或者 URL 进行拦截</p><p>11.记录用户登录信息，包括登录的时间、IP 等</p><h1 id="二、项目所用技术"><a href="#二、项目所用技术" class="headerlink" title="二、项目所用技术"></a>二、项目所用技术</h1><p>使用到的技术主要有</p><p>1.主体框架：SpringMVC + Spring + Mybatis</p><p>2.安全框架：Spring-Security</p><p>3.数据库：Mysql</p><p>4.缓存技术：Redis</p><p>5.消息中间件：ActiveMQ</p><p>6.搜索引擎：solr</p><p>7.富文本编辑器： Kindeditor</p><p>8.异步更新：Ajax</p><p>9.前端框架：zui、bootstrap、Jquery</p><h1 id="三、部分页面效果如下："><a href="#三、部分页面效果如下：" class="headerlink" title="三、部分页面效果如下："></a>三、部分页面效果如下：</h1><p>1.登录页面（账号登录和手机快捷登录）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-y.png" alt=""></p><p>2.注册页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/regist-x.png" alt=""></p><p>3.首页（评论、回复及点赞）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/index-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/chat-x.png" alt=""></p><p>4.写博客页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/write-x.png" alt=""></p><p>5.个人主页</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/personal-x.png" alt=""></p><p>6.个人信息页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/update.png" alt=""></p><p>7.修改密码页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/repassword-x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、项目包含功能&quot;&gt;&lt;a href=&quot;#一、项目包含功能&quot; class=&quot;headerlink&quot; title=&quot;一、项目包含功能&quot;&gt;&lt;/a&gt;一、项目包含功能&lt;/h1&gt;&lt;p&gt;使用SSM框架开发一个博客系统，包含的功能大致有:&lt;/p&gt;
&lt;p&gt;1.用户注册与激活，激活方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 借助阿里大于平台发送短信</title>
    <link href="https://wanglinyong.github.io/2018/05/18/csharp%E5%80%9F%E5%8A%A9%E9%98%BF%E9%87%8C%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    <id>https://wanglinyong.github.io/2018/05/18/csharp借助阿里大于发送短信/</id>
    <published>2018-05-18T12:30:18.000Z</published>
    <updated>2018-05-18T12:34:29.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、首先申请签名和模板"><a href="#一、首先申请签名和模板" class="headerlink" title="一、首先申请签名和模板"></a>一、首先申请签名和模板</h1><p>1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管理，申请一个签名，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-1.png" alt=""></p><p>2.然后找到模板管理，申请一个模板，模板里都有格式内容介绍，申请好以后大概是这样：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-8.png" alt=""></p><p>3.签名名称和模板CODE等会代码中会用到，还有Access Key ID 和 Access Key Secret也要用到，Access Key在个人信息的下拉列表里可以找到，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-3.png" alt=""></p><h1 id="二、下载-Net平台下的SDK"><a href="#二、下载-Net平台下的SDK" class="headerlink" title="二、下载.Net平台下的SDK"></a>二、下载.Net平台下的SDK</h1><p>1.点击短信服务列表中的帮助文档</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-4.png" alt=""></p><p>2.点击SDK下载，进入到SDK及DEMO下载页面，找到第4个[NET],点击即可下载。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-5.png" alt=""></p><p>3.将下载好的压缩包进行解压，找到msg_demo目录，在/msg_demo/alicom-mns-receive有发送短信的demo和dll文件</p><h1 id="三、发短信的具体实现"><a href="#三、发短信的具体实现" class="headerlink" title="三、发短信的具体实现"></a>三、发短信的具体实现</h1><p>1.将/msg_demo/alicom-mns-receive/dll目录下的4个dll文件拷贝到你的项目目录下</p><p>2.在你项目的引用右键添加引用，打开引用管理器，如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-6.png" alt=""></p><p>3.点击浏览，将阿里大于依赖的4个dll文件添加进来，然后点击确定。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-7.png" alt=""></p><p>4.将/msg_demo/alicom-mns-receive下的sendsms文件拷贝到你的项目中，将其中Access Key ID 、 Access Key Secret、签名名称、模板CODE替换成你自己的即可，还有接收短信的手机号，模板内容等，可以将main函数改成一个方法sendMsg(string phone,string code)，直接调用方法即可，参数改为接收短信的手机号和短信内容：</p><pre><code>namespace ConsoleApplication1{class sendsms{    static String product = &quot;Dysmsapi&quot;;//短信API产品名称    static String domain = &quot;dysmsapi.aliyuncs.com&quot;;//短信API产品域名    static String accessId = &quot;你的Key&quot;;    static String accessSecret = &quot;你的Secret&quot;;    static String regionIdForPop = &quot;cn-hangzhou&quot;;   public  static void sendMsg(string phone,string code)    {        IClientProfile profile = DefaultProfile.GetProfile(regionIdForPop, accessId, accessSecret);        DefaultProfile.AddEndpoint(regionIdForPop, regionIdForPop, product, domain);        IAcsClient acsClient = new DefaultAcsClient(profile);        SendSmsRequest request = new SendSmsRequest();        try        {            //request.SignName = &quot;上云预发测试&quot;;//&quot;管理控制台中配置的短信签名（状态必须是验证通过）&quot;            //request.TemplateCode = &quot;SMS_71130001&quot;;//管理控制台中配置的审核通过的短信模板的模板CODE（状态必须是验证通过）&quot;            //request.RecNum = &quot;13567939485&quot;;//&quot;接收号码，多个号码可以逗号分隔&quot;            //request.ParamString = &quot;{\&quot;name\&quot;:\&quot;123\&quot;}&quot;;//短信模板中的变量；数字需要转换为字符串；个人用户每个变量长度必须小于15个字符。&quot;            //SingleSendSmsResponse httpResponse = client.GetAcsResponse(request);            request.PhoneNumbers = phone;//接收短信的手机号            request.SignName = &quot;签名名称&quot;;            request.TemplateCode = &quot;模板CODE&quot;;            request.TemplateParam = &quot;{\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;}&quot;;//模板内容           // request.OutId = &quot;xxxxxxxx&quot;;  //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者            //请求失败这里会抛ClientException异常            SendSmsResponse sendSmsResponse = acsClient.GetAcsResponse(request);            System.Console.WriteLine(sendSmsResponse.Message);        }        catch (ServerException e)        {            System.Console.WriteLine(&quot;ServerException&quot;);        }        catch (ClientException e)        {            System.Console.WriteLine(&quot;ClientException&quot;);        }    }}}</code></pre><p>5.运行程序，调用发送短信方法进行测试，测试成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、首先申请签名和模板&quot;&gt;&lt;a href=&quot;#一、首先申请签名和模板&quot; class=&quot;headerlink&quot; title=&quot;一、首先申请签名和模板&quot;&gt;&lt;/a&gt;一、首先申请签名和模板&lt;/h1&gt;&lt;p&gt;1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="C#" scheme="https://wanglinyong.github.io/tags/C/"/>
    
      <category term="发短信" scheme="https://wanglinyong.github.io/tags/%E5%8F%91%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序日期格式化</title>
    <link href="https://wanglinyong.github.io/2018/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://wanglinyong.github.io/2018/05/11/微信小程序日期格式化/</id>
    <published>2018-05-11T12:15:18.000Z</published>
    <updated>2018-05-14T12:46:48.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-微信小程序util-js下有一个日期格式化函数"><a href="#1-微信小程序util-js下有一个日期格式化函数" class="headerlink" title="1.微信小程序util.js下有一个日期格式化函数"></a>1.微信小程序util.js下有一个日期格式化函数</h2><pre><code>const formatTime = date =&gt; {  var date = new Date(date);    const year = date.getFullYear()  const month = date.getMonth() + 1  const day = date.getDate()  const hour = date.getHours()  const minute = date.getMinutes()  const second = date.getSeconds()  return [year, month, day].map(formatNumber).join(&apos;-&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)}module.exports = {  formatTime: formatTime}</code></pre><p>但是它原来是没有下面的这段代码的  它要求传入的data是一个日期参数，为了方便将日期字符串作为参数传递，将date转换一下（这里的参数date就是日期字符串）：</p><pre><code>var date = new Date(date);  </code></pre><h2 id="2-获取后台的list列表数据后，遍历对其进行日期格式化："><a href="#2-获取后台的list列表数据后，遍历对其进行日期格式化：" class="headerlink" title="2.获取后台的list列表数据后，遍历对其进行日期格式化："></a>2.获取后台的list列表数据后，遍历对其进行日期格式化：</h2><p>引入util.js</p><pre><code>var util = require(&apos;../../utils/util.js&apos;);</code></pre><p>评论列表日期格式化代码：</p><pre><code>  if (res.data.result == 0) {  let comms = res.data.lists  console.log(comms)  for(let c in comms){    let  date = util.formatTime(comms[c].ctime)    comms[c].ctime = date  }  that.setData({    commentList: comms || [],    bookIsBuy: res.data.is_buy  });  setTimeout(function () {    that.setData({      commentLoading: false    });  }, 500);} </code></pre><p>调用util.js中的方法</p><pre><code>let  date = util.formatTime(comms[c].ctime)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-微信小程序util-js下有一个日期格式化函数&quot;&gt;&lt;a href=&quot;#1-微信小程序util-js下有一个日期格式化函数&quot; class=&quot;headerlink&quot; title=&quot;1.微信小程序util.js下有一个日期格式化函数&quot;&gt;&lt;/a&gt;1.微信小程序util
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序Java登录流程</title>
    <link href="https://wanglinyong.github.io/2018/05/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FJava%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"/>
    <id>https://wanglinyong.github.io/2018/05/10/微信小程序Java登录流程/</id>
    <published>2018-05-10T12:48:25.000Z</published>
    <updated>2018-05-10T13:17:06.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、登录流程图"><a href="#一、登录流程图" class="headerlink" title="一、登录流程图"></a>一、登录流程图</h1><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/wx-login.png" alt=""></p><h1 id="二、微信小程序端"><a href="#二、微信小程序端" class="headerlink" title="二、微信小程序端"></a>二、微信小程序端</h1><pre><code>doLogin:function(callback = () =&gt;{}){let that = this;wx.login({  success:function(loginRes){    if(loginRes){      //获取用户信息      wx.getUserInfo({        withCredentials:true,//非必填  默认为true        success:function(infoRes){          console.log(infoRes,&apos;&gt;&gt;&gt;&apos;);          //请求服务端的登录接口          wx.request({            url: api.loginUrl,            data:{              code:loginRes.code,//临时登录凭证              rawData:infoRes.rawData,//用户非敏感信息              signature:infoRes.signature,//签名              encrypteData:infoRes.encryptedData,//用户敏感信息              iv:infoRes.iv//解密算法的向量            },            success:function(res){              console.log(&apos;login success&apos;);              res = res.data;              if(res.result==0){                that.globalData.userInfo = res.userInfo;                wx.setStorageSync(&apos;userInfo&apos;,JSON.stringify(res.userInfo));                wx.setStorageSync(&apos;loginFlag&apos;,res.skey);                console.log(&quot;skey=&quot;+res.skey);                callback();              }else{                that.showInfo(&apos;res.errmsg&apos;);              }            },            fail:function(error){              //调用服务端登录接口失败             // that.showInfo(&apos;调用接口失败&apos;);              console.log(error);            }          });        }      });    }else{    }  }});}</code></pre><p>微信小程序端发起登录请求，携带的参数主要有：</p><pre><code>code:loginRes.code,//临时登录凭证rawData:infoRes.rawData,//用户非敏感信息signature:infoRes.signature,//签名encrypteData:infoRes.encryptedData,//用户敏感信息iv:infoRes.iv//解密算法的向量</code></pre><p>需要的数据主要有：</p><pre><code>result、userInfo和skey</code></pre><p>result用来判断是否登录成功，userInfo是用户的一些信息，保存在缓存中，不用每次都从后台获取，skey是用户登录态标识，也放在缓存中，如果skey存在就直接登录，维护用户的登录状态，具有时效性</p><h1 id="三、Java后台"><a href="#三、Java后台" class="headerlink" title="三、Java后台"></a>三、Java后台</h1><pre><code>@ResponseBody@RequestMapping(&quot;/login&quot;)public Map&lt;String,Object&gt; doLogin(Model model,                                  @RequestParam(value = &quot;code&quot;,required = false) String code,                                  @RequestParam(value = &quot;rawData&quot;,required = false) String rawData,                                  @RequestParam(value = &quot;signature&quot;,required = false) String signature,                                  @RequestParam(value = &quot;encrypteData&quot;,required = false) String encrypteData,                                  @RequestParam(value = &quot;iv&quot;,required = false) String iv){    log.info( &quot;Start get SessionKey&quot; );    Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(  );    System.out.println(&quot;用户非敏感信息&quot;+rawData);    JSONObject rawDataJson = JSON.parseObject( rawData );    System.out.println(&quot;签名&quot;+signature);    JSONObject SessionKeyOpenId = getSessionKeyOrOpenId( code );    System.out.println(&quot;post请求获取的SessionAndopenId=&quot;+SessionKeyOpenId);    String openid = SessionKeyOpenId.getString(&quot;openid&quot; );    String sessionKey = SessionKeyOpenId.getString( &quot;session_key&quot; );    System.out.println(&quot;openid=&quot;+openid+&quot;,session_key=&quot;+sessionKey);    User user = userService.findByOpenid( openid );    //uuid生成唯一key    String skey = UUID.randomUUID().toString();    if(user==null){        //入库        String nickName = rawDataJson.getString( &quot;nickName&quot; );        String avatarUrl = rawDataJson.getString( &quot;avatarUrl&quot; );        String gender  = rawDataJson.getString( &quot;gender&quot; );        String city = rawDataJson.getString( &quot;city&quot; );        String country = rawDataJson.getString( &quot;country&quot; );        String province = rawDataJson.getString( &quot;province&quot; );        user = new User();        user.setUid( openid );        user.setCreateTime( new Date(  ) );        user.setSessionkey( sessionKey );        user.setUbalance( 0 );        user.setSkey( skey );        user.setUaddress( country+&quot; &quot;+province+&quot; &quot;+city );        user.setUavatar( avatarUrl );        user.setUgender( Integer.parseInt( gender ) );        user.setUname( nickName );        user.setUpdateTime( new Date(  ) );        userService.insert( user );    }else {        //已存在        log.info( &quot;用户openid已存在,不需要插入&quot; );    }    //根据openid查询skey是否存在    String skey_redis = (String) redisTemplate.opsForValue().get( openid );    if(StringUtils.isNotBlank( skey_redis )){        //存在 删除 skey 重新生成skey 将skey返回        redisTemplate.delete( skey_redis );    }        //  缓存一份新的        JSONObject sessionObj = new JSONObject(  );        sessionObj.put( &quot;openId&quot;,openid );        sessionObj.put( &quot;sessionKey&quot;,sessionKey );        redisTemplate.opsForValue().set( skey,sessionObj.toJSONString() );        redisTemplate.opsForValue().set( openid,skey );        //把新的sessionKey和oppenid返回给小程序        map.put( &quot;skey&quot;,skey );    map.put( &quot;result&quot;,&quot;0&quot; );    JSONObject userInfo = getUserInfo( encrypteData, sessionKey, iv );    System.out.println(&quot;根据解密算法获取的userInfo=&quot;+userInfo);    userInfo.put( &quot;balance&quot;,user.getUbalance() );    map.put( &quot;userInfo&quot;,userInfo );    return map;}</code></pre><p>获取openid和sessionKey方法</p><pre><code>public static JSONObject getSessionKeyOrOpenId(String code){    //微信端登录code    String wxCode = code;    String requestUrl = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;    Map&lt;String,String&gt; requestUrlParam = new HashMap&lt;String, String&gt;(  );    requestUrlParam.put( &quot;appid&quot;,&quot;你的小程序appId&quot; );//小程序appId    requestUrlParam.put( &quot;secret&quot;,&quot;你的小程序appSecret&quot; );    requestUrlParam.put( &quot;js_code&quot;,wxCode );//小程序端返回的code    requestUrlParam.put( &quot;grant_type&quot;,&quot;authorization_code&quot; );//默认参数    //发送post请求读取调用微信接口获取openid用户唯一标识    JSONObject jsonObject = JSON.parseObject( UrlUtil.sendPost( requestUrl,requestUrlParam ));    return jsonObject;}</code></pre><p>解密用户敏感数据获取用户信息</p><pre><code>public static JSONObject getUserInfo(String encryptedData,String sessionKey,String iv){    // 被加密的数据    byte[] dataByte = Base64.decode(encryptedData);    // 加密秘钥    byte[] keyByte = Base64.decode(sessionKey);    // 偏移量    byte[] ivByte = Base64.decode(iv);    try {        // 如果密钥不足16位，那么就补足.  这个if 中的内容很重要        int base = 16;        if (keyByte.length % base != 0) {            int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0);            byte[] temp = new byte[groups * base];            Arrays.fill(temp, (byte) 0);            System.arraycopy(keyByte, 0, temp, 0, keyByte.length);            keyByte = temp;        }        // 初始化        Security.addProvider(new BouncyCastleProvider());        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;,&quot;BC&quot;);        SecretKeySpec spec = new SecretKeySpec(keyByte, &quot;AES&quot;);        AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;AES&quot;);        parameters.init(new IvParameterSpec(ivByte));        cipher.init( Cipher.DECRYPT_MODE, spec, parameters);// 初始化        byte[] resultByte = cipher.doFinal(dataByte);        if (null != resultByte &amp;&amp; resultByte.length &gt; 0) {            String result = new String(resultByte, &quot;UTF-8&quot;);            return JSON.parseObject(result);        }    } catch (NoSuchAlgorithmException e) {        log.error(e.getMessage(), e);    } catch (NoSuchPaddingException e) {        log.error(e.getMessage(), e);    } catch (InvalidParameterSpecException e) {        log.error(e.getMessage(), e);    } catch (IllegalBlockSizeException e) {        log.error(e.getMessage(), e);    } catch (BadPaddingException e) {        log.error(e.getMessage(), e);    } catch (UnsupportedEncodingException e) {        log.error(e.getMessage(), e);    } catch (InvalidKeyException e) {        log.error(e.getMessage(), e);    } catch (InvalidAlgorithmParameterException e) {        log.error(e.getMessage(), e);    } catch (NoSuchProviderException e) {        log.error(e.getMessage(), e);    }    return null;}</code></pre><h1 id="四、流程"><a href="#四、流程" class="headerlink" title="四、流程"></a>四、流程</h1><p>1.小程序端发起请求并携带主要参数</p><p>2.java后台接到/login请求后，根据code去调用微信接口获取用户唯一标识openid和sessionKey</p><p>3.根据openid查询mysql数据库，判断该用户是否存在，如果不存在将用户非敏感信息和其他初始化数据存入到数据库中，如果已存在，不操作</p><p>4.根据openid查询redis数据库，判断openid对应的skey是否存在，如果存在则删除原来老的skey以及对应的openid和sessionKey</p><p>5.通过uuid生成唯一的skey，用openid做键，skey做值，存入到redis中</p><p>6.然后把skey做键，openid和sessionKey的json串做值也重新存入到redis中</p><p>7.根据解密算法，参数有encryptedData、sessionKey和iv，获取用户信息userInfo,如果userInfo字段不满足需要，可通过userInfo.put( “balance”,user.getUbalance() );添加所需要的字段和值</p><p>8.将微信小程序需要的数据封装到map中，返回给小程序端</p><pre><code>map.put( &quot;skey&quot;,skey );map.put( &quot;result&quot;,&quot;0&quot; );map.put( &quot;userInfo&quot;,userInfo );    return map;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、登录流程图&quot;&gt;&lt;a href=&quot;#一、登录流程图&quot; class=&quot;headerlink&quot; title=&quot;一、登录流程图&quot;&gt;&lt;/a&gt;一、登录流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wiki/w
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信登录" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>web调试代理工具Whistle</title>
    <link href="https://wanglinyong.github.io/2018/05/10/Whistle/"/>
    <id>https://wanglinyong.github.io/2018/05/10/Whistle/</id>
    <published>2018-05-10T12:15:18.000Z</published>
    <updated>2018-05-10T13:14:40.425Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。</p><p>完成https代理请求总共需要5个步骤。</p><h1 id="一、安装Node-js"><a href="#一、安装Node-js" class="headerlink" title="一、安装Node.js"></a>一、安装Node.js</h1><p>下载地址：</p><pre><code>https://nodejs.org/en/</code></pre><p>下载长期支持版：LTS版本</p><p>下载后按步骤进行安装，安装完成后打开cmd命令窗口，执行</p><pre><code>$ node -v</code></pre><p>查看版本号，如果出现版本号即安装正确。</p><pre><code>v8.11.1</code></pre><h1 id="二、安装并启动Whistle"><a href="#二、安装并启动Whistle" class="headerlink" title="二、安装并启动Whistle"></a>二、安装并启动Whistle</h1><h2 id="1-安装Whistle"><a href="#1-安装Whistle" class="headerlink" title="1.安装Whistle"></a>1.安装Whistle</h2><p>打开cmd命令窗口，执行</p><pre><code>$ npm install -g whistle</code></pre><p>npm默认镜像是在国外，有时候安装速度很慢或者出现安装不了的情况，如果无法安装或者安装很慢，可以使用taobao的镜像安装：</p><pre><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org$ cnpm install -g whistle</code></pre><p>或者直接指定镜像安装：</p><pre><code>$ npm install whistle -g --registry=https://registry.npm.taobao.org</code></pre><h2 id="2-启动Whistle"><a href="#2-启动Whistle" class="headerlink" title="2.启动Whistle"></a>2.启动Whistle</h2><p>在cmd命令窗口中执行启动命令：</p><pre><code>w2 start</code></pre><p>停止命令：</p><pre><code>w2 stop</code></pre><p>重启命令：</p><pre><code>w2 restart</code></pre><h2 id="3-访问Whistle-访问网址："><a href="#3-访问Whistle-访问网址：" class="headerlink" title="3.访问Whistle,访问网址："></a>3.访问Whistle,访问网址：</h2><pre><code>127.0.0.1:8899</code></pre><h2 id="三、配置代理"><a href="#三、配置代理" class="headerlink" title="三、配置代理"></a>三、配置代理</h2><p>打开控制面板–&gt;网络和 Internet–&gt;Internet 选项–&gt;连接–&gt;局域网设置</p><p>勾选 为LAN使用代理服务器</p><pre><code>地址(E): 127.0.0.1 端口(T): 8899</code></pre><p>然后确定配置。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle.png" alt=""></p><p>此时就可以配置http请求转发了</p><p>1.打开whistle网页（127.0.0.1:8899）</p><p>2.在Rules规则中有一个默认的Default窗口，在此可以配置转发请求</p><pre><code>www.myurl.com 127.0.0.1:8080</code></pre><p>这样访问www.myurl.com就会访问127.0.0.1:8080这个地址</p><p>如果不在Default窗口配置，也可以自己新建一个，点击Create创建</p><p>这样只能代理非https请求  如果想代理https请求还得下载https安全证书</p><h1 id="四、下载https安全证书"><a href="#四、下载https安全证书" class="headerlink" title="四、下载https安全证书"></a>四、下载https安全证书</h1><p>点击whistle网页上的HTTPS,会出现一个二维码，在二维码上方有一个Download RootCA,点击下载，在二维码下方有一个Capture HTTPS CONNECTs单选框，勾选表明拦截HTTPS请求。如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-2.png" alt=""></p><p>htpps安全证书下载好以后，打开 –&gt;安装证书–&gt;将所有的证书放入下列存储–&gt;受信任的根证书颁发机构。如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-3.png" alt=""></p><p>下载安装完成以后得重新配置转发请求。</p><h2 id="五、配置请求转发"><a href="#五、配置请求转发" class="headerlink" title="五、配置请求转发"></a>五、配置请求转发</h2><p>如果配置成：</p><pre><code>https://www.myurl.com 127.0.0.1:8080</code></pre><p>会报下面的错误</p><pre><code>From: whistle@1.9.10Node: v8.11.1Date: 2018-5-4 09:31:21Error: write EPROTO 101057795:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:openssl\ssl\s23_clnt.c:827:at _errnoException (util.js:1022:11)at WriteWrap.afterWrite [as oncomplete] (net.js:880:14)</code></pre><p>是因为没办法用https请求去访问http服务器，改成下面的配置就OK</p><pre><code>www.myurl.com 127.0.0.1:8080 http://www.myurl.com</code></pre><p>这样访问<a href="https://www.myurl.com" target="_blank" rel="external">https://www.myurl.com</a> 就可以访问127.0.0.1:8080这个地址了。</p><p>记得开启拦截HTTPS：勾选 Capture HTTPS CONNECTs</p><p>点击Network可以查看请求信息，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-4.png" alt=""></p><p>这只是Whistle的冰山一角，了解更多功能请访问：</p><pre><code>http://wproxy.org/whistle/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。&lt;/p&gt;
&lt;p&gt;完成https代理请求总共需要5个步骤。&lt;/p&gt;
&lt;h1 id=&quot;一、安装Node-js&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="whistle" scheme="https://wanglinyong.github.io/categories/whistle/"/>
    
    
      <category term="whistle" scheme="https://wanglinyong.github.io/tags/whistle/"/>
    
      <category term="web调试工具" scheme="https://wanglinyong.github.io/tags/web%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>linux文件服务器httpd开机自启动</title>
    <link href="https://wanglinyong.github.io/2018/04/27/linux%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8httpd%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/27/linux文件服务器httpd开机自启动/</id>
    <published>2018-04-27T12:15:18.000Z</published>
    <updated>2018-04-27T12:15:08.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、相关命令"><a href="#一、相关命令" class="headerlink" title="一、相关命令"></a>一、相关命令</h1><p>1.查看所有系统服务</p><pre><code>systemctl list-units --all --type=service</code></pre><p>2.查询服务状态</p><pre><code>systemctl status httpd.service</code></pre><p>3.查询服务是否为开机启动</p><pre><code>systemctl is-enabled httpd.service</code></pre><p>enabled是 disabled否</p><p>4.设置服务为开机启动状态</p><pre><code>systemctl enable httpd.service</code></pre><p>会自动创建一个系统链接</p><pre><code>Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.</code></pre><p>5.设置服务为开机不启动状态</p><p>systemctl disable httpd.service</p><p>会自动移除系统链接</p><pre><code>Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service.</code></pre><p>二、设置httpd开机自启动</p><pre><code>systemctl enable httpd.service</code></pre><p>重启即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、相关命令&quot;&gt;&lt;a href=&quot;#一、相关命令&quot; class=&quot;headerlink&quot; title=&quot;一、相关命令&quot;&gt;&lt;/a&gt;一、相关命令&lt;/h1&gt;&lt;p&gt;1.查看所有系统服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl list-units --all -
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="httpd" scheme="https://wanglinyong.github.io/tags/httpd/"/>
    
      <category term="文件服务器" scheme="https://wanglinyong.github.io/tags/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux系统mysql的远程访问</title>
    <link href="https://wanglinyong.github.io/2018/04/22/linux%E7%B3%BB%E7%BB%9Fmysql%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <id>https://wanglinyong.github.io/2018/04/22/linux系统mysql的远程访问/</id>
    <published>2018-04-22T02:46:18.000Z</published>
    <updated>2018-04-27T12:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建用户设置权限"><a href="#一、创建用户设置权限" class="headerlink" title="一、创建用户设置权限"></a>一、创建用户设置权限</h1><p>以root身份登录mysql</p><pre><code>[root@ ~]mysql -uroot -p[root@ ~]Enter password: xxxxxx</code></pre><p>创建用户</p><pre><code>mysql&gt;create user &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos;;</code></pre><p>授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>其中’wanglinyong’@’%’是允许该用户在任何主机上远程连接，如果只允许在某一台主机上连接，可指定ip</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;10.xx.xx.x&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>授权之后记得要刷新权限</p><pre><code>mysql&gt;flush privileges;</code></pre><h1 id="二、Navicate远程连接测试"><a href="#二、Navicate远程连接测试" class="headerlink" title="二、Navicate远程连接测试"></a>二、Navicate远程连接测试</h1><p>1.如果连接失败，提示：</p><pre><code>1045-Access denied for user&apos;wanglinyong&apos;@&apos;ip&apos;(using password:YES)</code></pre><p>则表示密码输入错误。</p><p>2.如果提示：</p><pre><code>ERROR 2003(HY000): Can’t connect to MySQL server on xxxxx</code></pre><p>如果服务器是阿里云的，可能没有开通3306端口，要去服务器上添加安全组，增加3360端口即可</p><p>3.Navicate连接成功后，只有information_schema一个数据库</p><p>在linux系统以root用户登录</p><p>先查一下其他数据库是否被删除</p><pre><code>mysql&gt;show databases;</code></pre><p>如果还在，查看下mysql库的用户表</p><pre><code>mysql&gt;select host,user from mysql.user;</code></pre><p>结果如下：</p><pre><code>+----------------+-----------------+| host           | user            |+----------------+-----------------+| %              | wanglinyong     || localhost      | mysql.session   || localhost      | root            |+----------------+-----------------+3 rows in set (0.00 sec)</code></pre><p>说明wanglinyong用户允许在任何远程主机登录</p><p>然后查看，远程登录的用户是否有权限</p><pre><code>mysql&gt; show grants for &apos;wanglinyong&apos;@&apos;%&apos;;</code></pre><p>结果不是</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO &apos;wanglinyong5112&apos;@&apos;%&apos; WITH GRANT OPTION </code></pre><p>说明权限不够，重新授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>刷新权限：</p><pre><code>mysql&gt;flush privileges;</code></pre><p>重新连接应该就OK了！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果还不行, vi /etc/mysql/mysql.conf.d/mysqld.cnf,检查下是否有</p><pre><code>bind-address = 127.0.0.1</code></pre><p>如果有，请把它注释掉（加#号注释）。如果找不到mysqld.cnf,有的可能在 /etc/my.cnf文件内</p><p>保存退出后重启mysql服务</p><pre><code>sudo /etc/init.d/mysql restart</code></pre><p>或者</p><pre><code>systemctl restart mysqld</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、创建用户设置权限&quot;&gt;&lt;a href=&quot;#一、创建用户设置权限&quot; class=&quot;headerlink&quot; title=&quot;一、创建用户设置权限&quot;&gt;&lt;/a&gt;一、创建用户设置权限&lt;/h1&gt;&lt;p&gt;以root身份登录mysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@ ~
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Mysql" scheme="https://wanglinyong.github.io/tags/Mysql/"/>
    
      <category term="远程访问" scheme="https://wanglinyong.github.io/tags/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>JAVA十六进制数据接收与传输</title>
    <link href="https://wanglinyong.github.io/2018/04/17/JAVA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E4%B8%8E%E4%BC%A0%E8%BE%93/"/>
    <id>https://wanglinyong.github.io/2018/04/17/JAVA十六进制数据接收与传输/</id>
    <published>2018-04-17T14:28:56.000Z</published>
    <updated>2018-04-22T02:05:12.243Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。</p><h1 id="一、十六进制转换工具类"><a href="#一、十六进制转换工具类" class="headerlink" title="一、十六进制转换工具类"></a>一、十六进制转换工具类</h1><p>主要包含十六进制字符串转ASCII，ASCII转十六进制字符串以及十六进制字符串转Byte数组等方法：</p><pre><code> /**   * Created by wly on 2018/4/17.  */public class HexConvert {public static String  convertStringToHex(String str){char[] chars = str.toCharArray();StringBuffer hex = new StringBuffer();for(int i = 0; i &lt; chars.length; i++){    hex.append(Integer.toHexString((int)chars[i]));}return hex.toString();}public static String convertHexToString(String hex){StringBuilder sb = new StringBuilder();StringBuilder sb2 = new StringBuilder();for( int i=0; i&lt;hex.length()-1; i+=2 ){    String s = hex.substring(i, (i + 2));               int decimal = Integer.parseInt(s, 16);              sb.append((char)decimal);    sb2.append(decimal);}return sb.toString();}public static byte[] hexStringToBytes(String hexString) {    if (hexString == null || hexString.equals(&quot;&quot;)) {            return null;}        // toUpperCase将字符串中的所有字符转换为大写        hexString = hexString.toUpperCase();        int length = hexString.length() / 2;        // toCharArray将此字符串转换为一个新的字符数组。    char[] hexChars = hexString.toCharArray();    byte[] d = new byte[length];for (int i = 0; i &lt; length; i++) {    int pos = i * 2;    d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos + 1]));}        return d;}    //返回匹配字符private static byte charToByte(char c) {    return (byte) &quot;0123456789ABCDEF&quot;.indexOf(c);}//将字节数组转换为short类型，即统计字符串长度public static short bytes2Short2(byte[] b) {       short i = (short) (((b[1] &amp; 0xff) &lt;&lt; 8) | b[0] &amp; 0xff);    return i;}//将字节数组转换为16进制字符串public static String BinaryToHexString(byte[] bytes) {    String hexStr = &quot;0123456789ABCDEF&quot;;    String result = &quot;&quot;;    String hex = &quot;&quot;;for (byte b : bytes) {    hex = String.valueOf(hexStr.charAt((b &amp; 0xF0) &gt;&gt; 4));    hex += String.valueOf(hexStr.charAt(b &amp; 0x0F));    result += hex + &quot; &quot;;}return result;}public static void main(String[] args) {System.out.println(&quot;======ASCII码转换为16进制======&quot;);String str = &quot;*00007VERSION\\n1$&quot;;System.out.println(&quot;字符串: &quot; + str);String hex = HexConvert.convertStringToHex(str);System.out.println(&quot;====转换为16进制=====&quot; + hex);System.out.println(&quot;======16进制转换为ASCII======&quot;);System.out.println(&quot;Hex : &quot; + hex);System.out.println(&quot;ASCII : &quot; + HexConvert.convertHexToString(hex));byte[] bytes = HexConvert.hexStringToBytes( hex );System.out.println(HexConvert.BinaryToHexString( bytes ));}}</code></pre><h1 id="二、接收数据"><a href="#二、接收数据" class="headerlink" title="二、接收数据"></a>二、接收数据</h1><pre><code>public class UdpReceiverThread {public static void main(String[] args) throws Exception {// 定义一个接收端，并且指定了接收的端口号DatagramSocket socket = new DatagramSocket(6070);while (true) {byte[] buf = new byte[1024*5];// 解析数据包DatagramPacket packet = new DatagramPacket(buf, buf.length);socket.receive(packet);String ip = packet.getAddress().getHostAddress();buf = packet.getData();//将字节数组转换为16进制字符串String hexString = HexConvert.BinaryToHexString( buf );//含有空格，如：2A 30 30 30 30 37 56 45 52 53 49 4F 4E 5C 6E 31 24 hexString =  hexString.replace( &quot; &quot;,&quot;&quot; );//去除空格String asc = HexConvert.convertHexToString( hexString );//转为ASCII,如：*00007VERSION\n1$System.out.println(&quot;收到 &quot; + ip + &quot; 发来的消息：&quot; + asc);}}}</code></pre><h1 id="三、发送数据"><a href="#三、发送数据" class="headerlink" title="三、发送数据"></a>三、发送数据</h1><pre><code>public class UDPSenderThread {public static void main(String[] args) throws Exception {DatagramSocket socket = new DatagramSocket();String serial = &quot;*00007VERSION\\n1$&quot;;//串口字符串String hex = HexConvert.convertStringToHex(serial);//转化为十六进制字符串：2a303030303756455253494f4e5c6e3124byte[] buf = HexConvert.hexStringToBytes( hex );//将十六进制字符串转为字节数组//将数据打包DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(&quot;192.168.11.139&quot;), 6070);socket.send(packet);socket.close();}}</code></pre><h2 id="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"><a href="#在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。" class="headerlink" title="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"></a>在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。&lt;/p&gt;
&lt;h1 id=&quot;一、十六进制转换工具类&quot;&gt;&lt;a href=&quot;#一、十六进制转换工具类&quot; class=&quot;headerlink&quot; title=&quot;一、十
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wanglinyong.github.io/tags/Java/"/>
    
      <category term="十六进制" scheme="https://wanglinyong.github.io/tags/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>BadBoy+Jmeter压力测试</title>
    <link href="https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter压力测试/</id>
    <published>2018-04-10T11:42:48.000Z</published>
    <updated>2018-04-10T11:28:32.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载BadBoy和Jmeter"><a href="#一、下载BadBoy和Jmeter" class="headerlink" title="一、下载BadBoy和Jmeter"></a>一、下载BadBoy和Jmeter</h1><h2 id="1-下载链接"><a href="#1-下载链接" class="headerlink" title="1.下载链接"></a>1.下载链接</h2><p>BadBoy</p><pre><code>http://www.badboy.com.au/download/index</code></pre><p>Jmeter</p><pre><code>http://jmeter.apache.org/download_jmeter.cgi</code></pre><h2 id="2-下载过程如图"><a href="#2-下载过程如图" class="headerlink" title="2.下载过程如图"></a>2.下载过程如图</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-1.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-1.png" alt=""></p><h2 id="3-解压并配置环境变量"><a href="#3-解压并配置环境变量" class="headerlink" title="3.解压并配置环境变量"></a>3.解压并配置环境变量</h2><p>将下载好的BadBoy和Jmeter解压到合适的地方</p><p>配置环境变量</p><pre><code>变量名称：JMETER_HOME变量值：  G:\wly\apache-jmeter-4.0</code></pre><p> 在classpath后面加入：                          </p><pre><code>%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;</code></pre><h2 id="二、录制Jmeter脚本"><a href="#二、录制Jmeter脚本" class="headerlink" title="二、录制Jmeter脚本"></a>二、录制Jmeter脚本</h2><h2 id="1-打开BadBoy"><a href="#1-打开BadBoy" class="headerlink" title="1.打开BadBoy"></a>1.打开BadBoy</h2><p>（1）点击badboy.exe ,打开BadBoy,界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-3.png" alt=""></p><p>（2）输入URL，点击回车开始录制</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-4.png" alt=""></p><p>（3）此时左侧script下多了一条记录，右侧出现调试页面的首页</p><p>然后点击登录，访问首页，然后退出，badboy界面如下，总共有五条记录</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-5.png" alt=""></p><p>（4）接下来导出jmter脚本，点击</p><pre><code>file-&gt;Export to Jmeter</code></pre><p>导出后缀为.jmx的文件</p><h2 id="2-打开Jmeter"><a href="#2-打开Jmeter" class="headerlink" title="2.打开Jmeter"></a>2.打开Jmeter</h2><p>（1）进入Jmeter的bin目录，点击jmeter.bat运行Jmeter</p><p>（2）File-&gt;Open打开刚才导出的jmeter脚本 界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-2.png" alt=""></p><p>（3）Thread Group线程组就是定义并发数量的，step就是压测的步骤。<br>Number of Threads(users) 表示线程数量，如果设置为5000，就是模拟5000个人不断重复刚才的 首页-&gt;登录-&gt;首页-&gt;退出 操作</p><p>Ram-Up Period(in seconds)表示间隔时间</p><p>Loop Count 表示循环次数</p><p>压力测试：线程数越多压力越大，间隔时间越短压力越大</p><p>（4）添加监听器</p><p>添加聚合报告、查看结果树和用表格查看，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-3.png" alt=""></p><p>（5）运行</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-4.png" alt=""></p><p>（6）查看结果</p><p>查看结果树，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-5.png" alt=""></p><p>聚合报告，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-6.png" alt=""></p><p>表格查看，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;a href=&quot;#一、下载BadBoy和Jmeter&quot; class=&quot;headerlink&quot; title=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;/a&gt;一、下载BadBoy和Jmeter&lt;/h1&gt;&lt;h2 id=&quot;1-下载链
      
    
    </summary>
    
      <category term="性能测试" scheme="https://wanglinyong.github.io/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="https://wanglinyong.github.io/tags/Jmeter/"/>
    
      <category term="BadBoy" scheme="https://wanglinyong.github.io/tags/BadBoy/"/>
    
  </entry>
  
  <entry>
    <title>linux系统搭建文件服务器</title>
    <link href="https://wanglinyong.github.io/2018/04/06/linux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/06/linux系统搭建文件服务器/</id>
    <published>2018-04-06T02:48:23.000Z</published>
    <updated>2018-04-10T11:26:35.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装-httpd-服务"><a href="#一、安装-httpd-服务" class="headerlink" title="一、安装 httpd 服务"></a>一、安装 httpd 服务</h2><pre><code>yum install httpd</code></pre><p>查看版本号</p><pre><code>httpd -version</code></pre><h2 id="二、启动-httpd-服务"><a href="#二、启动-httpd-服务" class="headerlink" title="二、启动 httpd 服务"></a>二、启动 httpd 服务</h2><pre><code>service httpd start</code></pre><h2 id="三、容易出现的问题"><a href="#三、容易出现的问题" class="headerlink" title="三、容易出现的问题"></a>三、容易出现的问题</h2><p>1.防火墙未开放端口</p><pre><code>开启端口：firewall-cmd --zone=public --add-port=8989/tcp --permanent重启防火墙：firewall-cmd --reload 查看已开放端口：firewall-cmd --list-ports</code></pre><p>2.端口被占用</p><pre><code>更改端口号</code></pre><p>修改配置文件，默认路径是</p><pre><code>/etc/httpd/conf/httpd.conf </code></pre><p>主要修改以下内容</p><pre><code>Listen 80 --&gt; Listen 8987     #监听端口#ServerName www.example.com:80 --&gt; ServerName 192.168.120.132:8987    #服务名称ip:portDocumentRoot &quot;/var/www/html&quot; --&gt;  DocumentRoot &quot;/home/profile&quot;   #文件根目录&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径1&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径2</code></pre><p>3.出现apache CentOS Permission denied: AH00072</p><p>关闭SELINUX</p><pre><code>setenforce 0</code></pre><p>修改配置文件</p><pre><code>vim /etc/selinux/configSELINUX=enforcing 改成--&gt; SELINUX=disabled</code></pre><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><pre><code>service httpd start</code></pre><p>停止服务</p><pre><code>service httpd stop</code></pre><h2 id="五、远程访问"><a href="#五、远程访问" class="headerlink" title="五、远程访问"></a>五、远程访问</h2><p>在浏览器中输入 ip:port 即可访问设置的 /home/profile 目录;</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ftp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、安装-httpd-服务&quot;&gt;&lt;a href=&quot;#一、安装-httpd-服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装 httpd 服务&quot;&gt;&lt;/a&gt;一、安装 httpd 服务&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;yum install httpd

      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux系统安装git</title>
    <link href="https://wanglinyong.github.io/2018/03/31/linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85git/"/>
    <id>https://wanglinyong.github.io/2018/03/31/linux系统安装git/</id>
    <published>2018-03-31T06:36:00.000Z</published>
    <updated>2018-04-10T11:24:32.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装git依赖包"><a href="#一、安装git依赖包" class="headerlink" title="一、安装git依赖包"></a>一、安装git依赖包</h1><pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</code></pre><h1 id="二、删除已有的git"><a href="#二、删除已有的git" class="headerlink" title="二、删除已有的git"></a>二、删除已有的git</h1><pre><code>yum remove git</code></pre><h1 id="三、下载git源码"><a href="#三、下载git源码" class="headerlink" title="三、下载git源码"></a>三、下载git源码</h1><p>切换到你的包文件存放目录下</p><pre><code>　cd /home/softs</code></pre><p>下载git安装包</p><pre><code>wget https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz</code></pre><p>解压git安装包</p><pre><code>tar -zxvf git-2.8.3.tar.gzcd git-2.8.3</code></pre><p>配置git安装路径</p><pre><code>./configure prefix=/usr/local/git/</code></pre><p>编译并且安装</p><pre><code>make &amp;&amp; make install</code></pre><h1 id="四、将git指令添加到bash中"><a href="#四、将git指令添加到bash中" class="headerlink" title="四、将git指令添加到bash中"></a>四、将git指令添加到bash中</h1><pre><code>vi /etc/profile</code></pre><p>在最后一行加入</p><pre><code>export PATH=$PATH:/usr/local/git/bin</code></pre><p>让该配置文件立即生效</p><pre><code>source /etc/profile</code></pre><p>查看git版本号</p><pre><code>git --version</code></pre><p>git已经安装完毕 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装git依赖包&quot;&gt;&lt;a href=&quot;#一、安装git依赖包&quot; class=&quot;headerlink&quot; title=&quot;一、安装git依赖包&quot;&gt;&lt;/a&gt;一、安装git依赖包&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install curl-devel expat-d
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Git" scheme="https://wanglinyong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>DES加密解密</title>
    <link href="https://wanglinyong.github.io/2018/03/24/DES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>https://wanglinyong.github.io/2018/03/24/DES加密解密/</id>
    <published>2018-03-24T11:39:28.000Z</published>
    <updated>2018-03-24T11:40:53.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h1><p>我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！</p><p>查看日志后发现每次加密的结果都不同，后来百度得知是DES在linux和windows系统的加密算法不一致导致的。主要是DES补位导致，把补位规则改成”DES/ECB/PKCS5Padding”即可。</p><h1 id="二、DES加密解密代码"><a href="#二、DES加密解密代码" class="headerlink" title="二、DES加密解密代码"></a>二、DES加密解密代码</h1><pre><code>package wang.dreamland.www.common;import java.security.Key;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;public class MyDes {/** * 加密数据 * @param encryptString * @param encryptKey * @return * @throws Exception */public static String encryptDES(String encryptString, String encryptKey) throws Exception {    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getKey(encryptKey), &quot;DES&quot;));    byte[] encryptedData = cipher.doFinal(encryptString.getBytes(&quot;UTF-8&quot;));    return Base64.encodeBase64String(encryptedData);}/** * key  不足8位补位 * @param */public static byte[] getKey(String keyRule) {    Key key = null;    byte[] keyByte = keyRule.getBytes();    // 创建一个空的八位数组,默认情况下为0    byte[] byteTemp = new byte[8];    // 将用户指定的规则转换成八位数组    for (int i = 0; i &lt; byteTemp.length &amp;&amp; i &lt; keyByte.length; i++) {        byteTemp[i] = keyByte[i];    }    key = new SecretKeySpec(byteTemp, &quot;DES&quot;);    return key.getEncoded();}/*** * 解密数据 * @param decryptString * @param decryptKey * @return * @throws Exception */public static String decryptDES(String decryptString, String decryptKey) throws Exception {    byte[] sourceBytes = Base64.decodeBase64(decryptString);    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(getKey(decryptKey), &quot;DES&quot;));    byte[] decoded = cipher.doFinal(sourceBytes);    return new String(decoded, &quot;UTF-8&quot;);}public static void main(String[] args) throws Exception {    String clearText = &quot;wanglinyong@163.com&quot;;    String key = &quot;123456&quot;;//密钥    System.out.println(&quot;明文：&quot;+clearText+&quot;\n密钥：&quot;+key);    String encryptText = encryptDES(clearText, key);    System.out.println(&quot;加密后：&quot;+encryptText);    String decryptText = decryptDES(encryptText, key);    System.out.println(&quot;解密后：&quot;+decryptText);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、场景&quot;&gt;&lt;a href=&quot;#一、场景&quot; class=&quot;headerlink&quot; title=&quot;一、场景&quot;&gt;&lt;/a&gt;一、场景&lt;/h1&gt;&lt;p&gt;我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！&lt;/p&gt;
&lt;p&gt;查看日
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统使用Gogs搭建自己的git服务</title>
    <link href="https://wanglinyong.github.io/2018/03/24/linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Gogs%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84git%E6%9C%8D%E5%8A%A1/"/>
    <id>https://wanglinyong.github.io/2018/03/24/linux系统使用Gogs搭建自己的git服务/</id>
    <published>2018-03-24T07:25:42.000Z</published>
    <updated>2018-04-10T11:29:24.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装Gogs服务"><a href="#一、安装Gogs服务" class="headerlink" title="一、安装Gogs服务"></a>一、安装Gogs服务</h1><h2 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户"></a>1.新建用户</h2><p>Gogs默认以 git 用户运行（你不会想用一个能修改 ssh 配置的程序以 root 用户运行吧）。 </p><pre><code>sudo adduser git  # 新建git用户。 </code></pre><p> 以 git 用户登录，到 git 用户的主目录中新建好 .ssh 文件夹。(新建git用户后我的出现在/home目录下)</p><pre><code>su gitcd /home/gitmkdir .ssh</code></pre><h2 id="2-下载安装包并解压"><a href="#2-下载安装包并解压" class="headerlink" title="2.下载安装包并解压"></a>2.下载安装包并解压</h2><p>我使用的是预编译的二进制包。下载链接</p><pre><code>https://gogs.io/docs/installation/install_from_binary</code></pre><p>查看linux系统是32位还是64位系统命令，32位选择386，64位选择amd64</p><pre><code>getconf LONG_BIT</code></pre><p>需要从源码编译的话，请参考一般 Go 语言项目的编译。下载后解包到你喜欢的地方，例如 /usr/share/gogs/ 或者 /home/git/gogs/ 。文件夹的内容如下。</p><pre><code>gogs  LICENSE  public  README.md  README_ZH.md  scripts  templates</code></pre><h2 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3.创建数据库"></a>3.创建数据库</h2><p>创建database,名称为gogs</p><pre><code>CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;GRANT ALL PRIVILEGES ON gogs.* TO &apos;root&apos;@&apos;localhost&apos; identified by &apos;root&apos;;FLUSH PRIVILEGES;</code></pre><p>在 Gogs 目录的 scripts/mysql.sql 文件是数据库初始化文件。执行</p><pre><code>mysql -u root -p &lt; scripts/mysql.sql （需要输入密码）即可初始化好数据库。</code></pre><p>然后登录 MySQL 创建一个新用户 gogs，并将数据库 gogs 的所有权限都赋予该用户。</p><pre><code>$ mysql -u root -p&gt; # （输入密码）&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;密码&apos;;&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;;&gt; flush privileges;&gt; exit;</code></pre><h2 id="4-运行-gogs-web"><a href="#4-运行-gogs-web" class="headerlink" title="4.运行 gogs web"></a>4.运行 gogs web</h2><p>进入gogs目录下，并运行gogs</p><pre><code>cd /home/git/gogs/gogsnohup ./gogs web &amp; tail -f nohup.out #并打印日志nohup ./gogs web &amp; #仅后台运行 ./gogs web  #前台运行</code></pre><p>然后访问 <a href="http://服务器IP:3000/" target="_blank" rel="external">http://服务器IP:3000/</a> 来进行安装，填写好表单之后提交就可以了。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.如果访问网页失败，可能防火墙没有打开3000的端口，防火墙相关配置请查看linux系统相关服务这篇博客。</p><p>2.还有0.6.9.0903 Beta 版本有个 bug，允许在关闭注册的情况下不添加管理员，这样安装完成之后将没有任何用户可以登录。所以请务必在安装界面指定一个管理员帐号。</p><h2 id="5-相关配置"><a href="#5-相关配置" class="headerlink" title="5.相关配置"></a>5.相关配置</h2><p>1.配置文件位于 Gogs 目录的 custom/conf/app.ini ，是 INI 格式的文本文件。详细的配置解释和默认值请参考官方文档 ，其中关键的配置大概是下面这些。</p><pre><code>RUN_USER 默认是 git ，指定 Gogs 以哪个用户运行ROOT 所有仓库的存储根路径PROTOCOL 如果你使用 nginx 反代的话请使用 http ，如果直接裸跑对外服务的话随意DOMAIN 域名。会影响 SSH clone 地址ROOT_URL 完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址HTTP_ADDR 监听地址，使用 nginx 的话建议 127.0.0.1 ，否则 0.0.0.0 也可以HTTP_PORT 监听端口，默认 3000INSTALL_LOCK 锁定安装页面Mailer 相关的选项</code></pre><p>其中，Mailer 可以使用 Mailgun 的免费邮件发送服务，将 Mailgun 的 SMTP 配置填入到配置中就好。</p><p>2.附app.ini(192.168.120.132为我使用的虚拟机ip)</p><pre><code>APP_NAME = GogsRUN_USER = gitRUN_MODE = prod[database]DB_TYPE  = mysqlHOST     = 127.0.0.1:3306NAME     = gogsUSER     = gogsPASSWD   = gogsSSL_MODE = disablePATH     = data/gogs.db[repository]ROOT = /home/git/gogs-repositories[server]DOMAIN           = 192.168.120.132HTTP_PORT        = 3000ROOT_URL         = http://192.168.120.132:3000/DISABLE_SSH      = falseSSH_PORT         = 1111START_SSH_SERVER = trueOFFLINE_MODE     = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL     = falseDISABLE_REGISTRATION   = falseENABLE_CAPTCHA         = trueREQUIRE_SIGNIN_VIEW    = false[picture]DISABLE_GRAVATAR        = falseENABLE_FEDERATED_AVATAR = true[session]PROVIDER = file[log]MODE      = fileLEVEL     = InfoROOT_PATH = /home/git/gogs/gogs/log[security]INSTALL_LOCK = trueSECRET_KEY   = YfaCLhKinQVLlb7</code></pre><h2 id="6-nginx-反向代理"><a href="#6-nginx-反向代理" class="headerlink" title="6.nginx 反向代理"></a>6.nginx 反向代理</h2><p>在 /etc/nginx/sites-available 中新建一个文件，把以下内容写入文件中。</p><pre><code>server {server_name 域名或IP;listen 80; # 或者 443，如果你使用 HTTPS 的话# ssl on; 是否启用加密连接# 如果你使用 HTTPS，还需要填写 ssl_certificate 和 ssl_certificate_keylocation / { # 如果你希望通过子路径访问，此处修改为子路径，注意以 / 开头并以 / 结束    proxy_pass http://127.0.0.1:3000/;}}</code></pre><p>然后进入 /etc/nginx/sites-enabled 中，执行 </p><pre><code>ln -s ../sites-available/配置文件名   #启用这个配置文件。</code></pre><p>最后重启 nginx 就好了，Centos下是</p><pre><code>service nginx restart   #重启/etc/init.d/nginx stop  #停止/etc/init.d/nginx start #开始</code></pre><p>Ubuntu 下是 </p><pre><code>sudo service nginx restart 。</code></pre><h2 id="7-开机自动重启等脚本"><a href="#7-开机自动重启等脚本" class="headerlink" title="7.开机自动重启等脚本"></a>7.开机自动重启等脚本</h2><p>在scripts/文件夹下有关于多个系统的服务脚本：</p><pre><code>autoboot.sh  build_freebsd.sh  build_linux64.sh  build.sh  init launchd  mysql.sql  README  supervisor  systemd  windows</code></pre><p>其中init,systemd以及windows目录分别为linux、Windows下服务脚本。<br>在此仅以CentOS为例:</p><p>复制scripts/init/centos/gogs到/etc/init.d/目录下:</p><pre><code>sudo cp scripts/init/centos/gogs /etc/init.d/</code></pre><p>切换到/etc/init.d/目录为脚本赋予可执行权限</p><pre><code>sudo chmod +x gogs</code></pre><p>更改gogs脚本内关于GOGS_HOME目录位置的设置(这儿使用vim编辑)</p><pre><code>GOGS_HOME=/data/gogs/gogs</code></pre><p>使用服务管理命令管理服务</p><pre><code>sudo service gogs start/stop/restart/status</code></pre><p>配置Gogs开机自启动</p><pre><code>sudo chkconfig --add gogs</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装Gogs服务&quot;&gt;&lt;a href=&quot;#一、安装Gogs服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装Gogs服务&quot;&gt;&lt;/a&gt;一、安装Gogs服务&lt;/h1&gt;&lt;h2 id=&quot;1-新建用户&quot;&gt;&lt;a href=&quot;#1-新建用户&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Git" scheme="https://wanglinyong.github.io/tags/Git/"/>
    
      <category term="Gogs" scheme="https://wanglinyong.github.io/tags/Gogs/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式数据库H2</title>
    <link href="https://wanglinyong.github.io/2018/03/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93H2/"/>
    <id>https://wanglinyong.github.io/2018/03/15/嵌入式数据库H2/</id>
    <published>2018-03-15T12:08:23.000Z</published>
    <updated>2018-03-16T09:32:16.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>由于项目中需要将数据库嵌入到程序中，一起打包发给客户使用，所以需要使用嵌入式数据库，目前常用的嵌入式数据库有：Berkeley DB、Couchbase Lite、LevelDB、SQLite、UnQLite、H2等，由于H2具有以下特点，所以最终选择了H2作为存储数据库。</p><pre><code>1、纯Java编写，不受平台的限制；2、只有一个jar文件，适合作为嵌入式数据库使用；3、h2提供了一个十分方便的web控制台用于操作和管理数据库内容；4、功能完整，支持标准SQL和JDBC。麻雀虽小五脏俱全；5、支持内嵌模式、服务器模式和集群。</code></pre><h1 id="一、H2简介"><a href="#一、H2简介" class="headerlink" title="一、H2简介"></a>一、H2简介</h1><p>H2是一个用Java开发的嵌入式数据库，它本身只是一个类库，可以直接嵌入到应用项目中。</p><p>Ｈ2最大的用途在于可以同应用程序打包在一起发布，这样可以非常方便地存储少量结构化数据。<br>它的另一个用途是用于单元测试。启动速度快，而且可以关闭持久化功能，每一个用例执行完随即还原到初始状态。</p><p>Ｈ2的第三个用处是作为缓存，作为NoSQL的一个补充。当某些场景下数据模型必须为关系型，可以拿它当Memcached使，作为后端MySQL/Oracle的一个缓冲层，缓存一些不经常变化但需要频繁访问的数据，比如字典表、权限表。不过这样系统架构就会比较复杂了。</p><h1 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h1><p>1、下载</p><pre><code>H2数据库下载地址：http://www.h2database.com/html/download.html</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-1.png" alt=""></p><p>Windows、Linux下都可以直接解压缩就用。</p><p>2、安装</p><p>解压缩后的目录结构：</p><p>　　h2</p><p>　　|—bin</p><p>　　|    |—h2-1.1.116.jar 　　//H2数据库的jar包（驱动也在里面）</p><p>　　|    |—h2.bat         　　   //Windows控制台启动脚本</p><p>　　|    |—h2.sh                  //Linux控制台启动脚本</p><p>　　|    |—h2w.bat              //Windows控制台启动脚本（不带黑屏窗口）</p><p>　　|—docs                       //H2数据库的帮助文档（内有H2数据库的使用手册）</p><p>　　|—service //通过wrapper包装成服务。</p><p>　　|—src //H2数据库的源代码</p><p>　　|—build.bat //windows构建脚本</p><p>　　|—build.sh //linux构建脚本</p><p>　　此时就算“安装”完成了。</p><h1 id="三、运行模式与运行方式"><a href="#三、运行模式与运行方式" class="headerlink" title="三、运行模式与运行方式"></a>三、运行模式与运行方式</h1><h2 id="1、运行模式"><a href="#1、运行模式" class="headerlink" title="1、运行模式"></a>1、运行模式</h2><p>　　Ｈ2有三种运行模式。</p><pre><code>（1）内嵌模式（Embedded Mode）内嵌模式下，应用和数据库同在一个JVM中，通过JDBC进行连接。 可持久化，但同时只能一个客户端连接。内嵌模式性能会比较好。（2）服务器模式（Server Mode）使用服务器模式和内嵌模式一样，只不过它可以跑在另一个进程里。（3）混合模式第一个应用以内嵌模式启动它，对于后面的应用来说它是服务器模式跑着的。混合模式是内嵌模式和服务器模式的组合。第一个应用通过内嵌模式与数据库建立连接，同时也作为一个服务器启动，于是另外的应用（运行在不同的进程或是虚拟机上）可以同时访问同样的数据。第一个应用的本地连接与嵌入式模式的连接性能一样的快，而其它连接理论上会略慢。 </code></pre><h2 id="2、运行方式"><a href="#2、运行方式" class="headerlink" title="2、运行方式"></a>2、运行方式</h2><p>　　开发中肯定是Server Mode方便，因为需要用工具管理数据。所以进入Ｈ2的bin目录。如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-2.png" alt=""></p><p>如果你在Win环境可以运行h2.bat或h2w.bat。区别只是后者是后台静默运行</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-3.png" alt=""></p><h1 id="四、应用程序开发"><a href="#四、应用程序开发" class="headerlink" title="四、应用程序开发"></a>四、应用程序开发</h1><h2 id="1、通过远程浏览器来访问h2"><a href="#1、通过远程浏览器来访问h2" class="headerlink" title="1、通过远程浏览器来访问h2"></a>1、通过远程浏览器来访问h2</h2><pre><code>访问地址：http://服务器ip:8082/ ，出现如下页面：</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-5.png" alt=""></p><h2 id="２、路径的配置"><a href="#２、路径的配置" class="headerlink" title="２、路径的配置"></a>２、路径的配置</h2><pre><code>jdbc:h2:~/test是H2的路径。User name : sa是h2默认的用户，密码可空。最好设置下密码，尤其当你的Ｈ2部署在公网时。不然会被无聊人把数据删掉。</code></pre><h2 id="3、连接"><a href="#3、连接" class="headerlink" title="3、连接"></a>3、连接</h2><pre><code>点击如图Test connect按钮测试连接。此时如果数据库文件本身不存在则会自动创建。点击Connect，进入管理终端。</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-6.png" alt=""></p><p>Ｈ２的管理终端做得很不错的。按Ctrl+Enter执行输入区的SQL，按Shift+Enter执行当前选中的SQL。</p><h1 id="五、应用程序开发"><a href="#五、应用程序开发" class="headerlink" title="五、应用程序开发"></a>五、应用程序开发</h1><h2 id="1、加入Maven依赖"><a href="#1、加入Maven依赖" class="headerlink" title="1、加入Maven依赖"></a>1、加入Maven依赖</h2><pre><code>&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;version&gt;1.4.195&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="2、创建db-properties"><a href="#2、创建db-properties" class="headerlink" title="2、创建db.properties"></a>2、创建db.properties</h2><pre><code>driverClassName=org.h2.Driver</code></pre><p>此处的写法是使用嵌入模式链接H2库，紧接着那行是使用Server Mode用tcp连接。区别一个是前者性能更好，后者可同时多个客户端连接</p><pre><code>url=jdbc:h2:D:/test#url=jdbc:h2:tcp://1localhost//usr/h2/data/rlibusername=sapassword=</code></pre><h2 id="PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下："><a href="#PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下：" class="headerlink" title="PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下："></a>PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下：</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-4.png" alt=""></p><h1 id="六、H2管理工具-DBeaver"><a href="#六、H2管理工具-DBeaver" class="headerlink" title="六、H2管理工具-DBeaver"></a>六、H2管理工具-DBeaver</h1><p>可通过数据库管理工具DBeaver来有效管理H2，直接从网上下载即可，这里不提供下载和安装过程</p><p>打开DBeaver.exe,操作如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-7.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-8.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-9.png" alt=""></p><p>输入用户名sa  </p><p>密码自己设置一个  也可以不设，点击下一步</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-10.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-11.png" alt=""></p><p>打开test数据库，即可对表进行增删改查操作了</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-12.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;由于项目中需要将数据库嵌入到程序中，一起打包发给客户使用，所以需要使用嵌入式数据库，目前常用的嵌入式数据库有：Berkeley DB、Cou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA-UDP接收和发送json数据</title>
    <link href="https://wanglinyong.github.io/2018/03/06/UDP%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81json%E6%95%B0%E6%8D%AE/"/>
    <id>https://wanglinyong.github.io/2018/03/06/UDP接收和发送json数据/</id>
    <published>2018-03-06T11:49:09.000Z</published>
    <updated>2018-03-16T07:21:44.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、UDP服务端发送数据"><a href="#一、UDP服务端发送数据" class="headerlink" title="一、UDP服务端发送数据"></a>一、UDP服务端发送数据</h1><pre><code>public class UdpClient {public static void main(String[] args) throws Exception {    DatagramSocket socket = new DatagramSocket();    String s = getJsonStr();    byte[] buf = s.getBytes();    //将数据打包    DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(&quot;192.168.11.139&quot;), 6070);    socket.send(packet);    socket.close();}public  static  String getJsonStr(){    Person p = new Person();    p.setName( &quot;张三&quot; );    p.setAge( 18 );    p.setGender( &quot;男&quot; );    return JSONObject.toJSONString( p );}}</code></pre><p>利用fastjson将对象转换为json字符串</p><pre><code>JSONObject.toJSONString( p );</code></pre><h1 id="二、UDP客户端接收数据"><a href="#二、UDP客户端接收数据" class="headerlink" title="二、UDP客户端接收数据"></a>二、UDP客户端接收数据</h1><pre><code>public class UdpServer {public static void main(String[] args) throws Exception {    // 定义一个接收端，并且指定了接收的端口号    DatagramSocket socket = new DatagramSocket(6070);    while (true) {        byte[] buf = new byte[1024];        // 解析数据包        DatagramPacket packet = new DatagramPacket(buf, buf.length);        socket.receive(packet);        String ip = packet.getAddress().getHostAddress();        buf = packet.getData();        String data = new String(buf, 0, packet.getLength());        System.out.println(&quot;收到 &quot; + ip + &quot; 发来的消息：&quot; + data);        //Person p = JSON.parseObject(data, new TypeReference&lt;Person&gt;() {});        Person p=JSONObject.parseObject(data, Person.class);//JSON字符串转对象        System.out.println(p.toString());    }}}</code></pre><p>利用fastjson将接收到的json字符串转为对象</p><pre><code>Person p=JSONObject.parseObject(data, Person.class);//JSON字符串转对象</code></pre><p>三、实体类Person</p><pre><code>public class Person {private  String  name;private  int age;private String gender;public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}public String getGender() {    return gender;}public void setGender(String gender) {    this.gender = gender;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &quot;, gender=&apos;&quot; + gender + &apos;\&apos;&apos; +            &apos;}&apos;;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、UDP服务端发送数据&quot;&gt;&lt;a href=&quot;#一、UDP服务端发送数据&quot; class=&quot;headerlink&quot; title=&quot;一、UDP服务端发送数据&quot;&gt;&lt;/a&gt;一、UDP服务端发送数据&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public class UdpClient
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql每天定时清空表</title>
    <link href="https://wanglinyong.github.io/2018/01/26/mysql%E5%AE%9A%E6%97%B6%E6%B8%85%E7%A9%BA%E8%A1%A8/"/>
    <id>https://wanglinyong.github.io/2018/01/26/mysql定时清空表/</id>
    <published>2018-01-26T11:16:36.000Z</published>
    <updated>2018-03-08T01:16:02.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql每天定时清空表"><a href="#Mysql每天定时清空表" class="headerlink" title="Mysql每天定时清空表"></a>Mysql每天定时清空表</h1><p>1.设置开启event scheduler</p><pre><code>SET GLOBAL event_scheduler=1;</code></pre><p>2.验证event_scheduler是否已经开启</p><pre><code>show variables like &apos;%event%&apos;;  #值为 ON 表明已开启SHOW VARIABLES LIKE &apos;event_scheduler&apos;;</code></pre><p>3.创建event</p><pre><code>DROP EVENT IF EXISTS e_delete_upvote; CREATE  EVENT e_delete_upvote    ON SCHEDULE EVERY 1 day STARTS date_add(concat(current_date(), &apos; 00:00:00&apos;), interval 0 second) ON COMPLETION PRESERVE ENABLE DO TRUNCATE TABLE dreamland.upvote;#说明： ON SCHEDULE EVERY 1 day 指定循环间隔为每天执行 STARTS date_add(concat(current_date(), &apos; 23:59:00&apos;), interval 0 second) 指定运行时间为23:59:00 ON COMPLETION PRESERVE ENABLE 指定创建完成后即启用，否则需手动启动</code></pre><p>4.手动关闭事件</p><pre><code>ALTER EVENT e_delete_upvote DISABLE;</code></pre><p>5.手动该事件为可用</p><pre><code>ALTER EVENT e_delete_upvote ENABLE;</code></pre><p>6.查看已有的定时事件任务</p><pre><code>SHOW EVENTS;</code></pre><p>7.删除事件</p><pre><code>DROP EVENT e_delete_upvote;</code></pre><h3 id="注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql-ini文件中加入event-scheduler-ON-的语句"><a href="#注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql-ini文件中加入event-scheduler-ON-的语句" class="headerlink" title="注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql.ini文件中加入event_scheduler = ON; 的语句"></a>注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql.ini文件中加入event_scheduler = ON; 的语句</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql每天定时清空表&quot;&gt;&lt;a href=&quot;#Mysql每天定时清空表&quot; class=&quot;headerlink&quot; title=&quot;Mysql每天定时清空表&quot;&gt;&lt;/a&gt;Mysql每天定时清空表&lt;/h1&gt;&lt;p&gt;1.设置开启event scheduler&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 打开Excel文件方法</title>
    <link href="https://wanglinyong.github.io/2018/01/23/csharp%E6%89%93%E5%BC%80Excel%E6%96%87%E4%BB%B6/"/>
    <id>https://wanglinyong.github.io/2018/01/23/csharp打开Excel文件/</id>
    <published>2018-01-23T11:43:06.000Z</published>
    <updated>2018-03-24T13:22:27.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、C-怎样打开Excel文件"><a href="#一、C-怎样打开Excel文件" class="headerlink" title="一、C#怎样打开Excel文件"></a>一、C#怎样打开Excel文件</h1><p>1.右键–Add DevExpress Item – New Item，新建一个Form窗体</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e1.png" alt=""></p><p>2.打开工具箱，搜索spreadsheetControl</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e2.png" alt=""></p><p>3.将工具spreadsheetControl拖入新建的窗体中</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e3.png" alt=""></p><p>4.可添加打开，保存，打印等按钮，我是随窗体打开一起打开excel，所以没有添加按钮，主要代码如下：</p><pre><code>using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Text;using System.Linq;using System.Threading.Tasks;using System.Windows.Forms;using DevExpress.XtraEditors;using System.IO;using DevExpress.Spreadsheet;namespace rdms.Forms{public partial class frmARFCN : Form{    private static log4net.ILog LOG = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);    //记录窗体的名称    readonly string mainFormText;    public frmARFCN()    {        InitializeComponent();        //记录窗体的名称，并实现文档变化事件的处理，方便显示新的文件名称        mainFormText = this.Text;        this.spreadsheetControl1.DocumentLoaded += new EventHandler(spreadsheetControl1_DocumentLoaded);        openFile();    }    /// &lt;summary&gt;    /// 文档变化后，实现对新文件名称的显示    /// &lt;/summary&gt;    void spreadsheetControl1_DocumentLoaded(object sender, EventArgs e)    {        string fileName = Path.GetFileName(this.spreadsheetControl1.Document.Path);        if (String.IsNullOrEmpty(fileName))        {            Text = mainFormText;        }        else        {            Text = fileName + &quot; - &quot; + mainFormText;        }    }    /// &lt;summary&gt;    /// 打开Excel文件    /// &lt;/summary&gt;    private void openFile()    {        string path = Application.StartupPath;        LOG.Info(&quot;path===&quot;+path);        string filePath = path + &quot;\\Data\\about.xls&quot;;        if (!string.IsNullOrEmpty(filePath))        {            IWorkbook workbook = spreadsheetControl1.Document;            workbook.LoadDocument(filePath);        }    }    /// &lt;summary&gt;    /// 保存Excel文件    /// &lt;/summary&gt;    private void btnSaveFile_Click(object sender, EventArgs e)    {        spreadsheetControl1.SaveDocument();    }    /// &lt;summary&gt;    /// Excel文件打印    /// &lt;/summary&gt;    private void btnPreview_Click(object sender, EventArgs e)    {        this.spreadsheetControl1.ShowPrintPreview();    }}}</code></pre><p>5.点击某个按钮弹出frmARFCN的form窗体</p><pre><code> private void btn_Click(object sender, EventArgs e){            using (frmARFCN frm = new frmARFCN())    {        DialogResult ret = frm.ShowDialog(this);    }       }</code></pre><p>6.显示效果如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、C-怎样打开Excel文件&quot;&gt;&lt;a href=&quot;#一、C-怎样打开Excel文件&quot; class=&quot;headerlink&quot; title=&quot;一、C#怎样打开Excel文件&quot;&gt;&lt;/a&gt;一、C#怎样打开Excel文件&lt;/h1&gt;&lt;p&gt;1.右键–Add DevExpres
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# Gridview 改变行字体颜色或背景色</title>
    <link href="https://wanglinyong.github.io/2018/01/19/csharp%E6%94%B9%E5%8F%98%E8%A1%8C%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E6%88%96%E8%83%8C%E6%99%AF%E8%89%B2/"/>
    <id>https://wanglinyong.github.io/2018/01/19/csharp改变行字体颜色或背景色/</id>
    <published>2018-01-19T11:43:06.000Z</published>
    <updated>2018-03-24T13:21:59.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、根据列表数据改变行字体颜色或者背景色"><a href="#一、根据列表数据改变行字体颜色或者背景色" class="headerlink" title="一、根据列表数据改变行字体颜色或者背景色"></a>一、根据列表数据改变行字体颜色或者背景色</h1><p>1.ALT+ENTER键打开属性列表，根据Name.Color.Name获取颜色字符串</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color.png" alt=""></p><pre><code>string color =  tePhone1.Color.Name;</code></pre><p>2.将颜色字符串存入数据库，附上数据库Dao代码</p><pre><code>    namespace rdms.DB   {public class StudentDao{    private static ILog LOG = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);    public static List&lt;Student&gt; GetAll()    {        return DBContext.ScodeSession.From&lt;Student&gt;().Select().ToList();    }    public static int Update(Student s)    {                // DBContext.ScodeSession.FromSql(&quot;UPDATE  Student  SET  color = &apos;&quot;+s.color+ &quot;&apos; where s_id = &quot; + s.s_id);        return DBContext.ScodeSession.Update(s);    }    public static Student getStudent(int id)    {        List&lt;Student&gt; list = DBContext.ScodeSession.FromSql(&quot;SELECT *  FROM Student  where s_id = &quot; + id).ToList&lt;Student&gt;();        if (list != null &amp;&amp; list.Count &gt; 0)        {            return list[0];        }        else        {            return null;        }    }    public static int Add(Student s)    {        return DBContext.ScodeSession.Insert(s);    }    public static void Delete(Student s)    {        DBContext.ScodeSession.Delete&lt;Student&gt;(s);    }}</code></pre><p>}</p><p>3.在显示列表点击Run Designer，在事件列表中找到RowStyle,给一个事件名称</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color4.png" alt=""></p><p>4.具体实现代码如下</p><pre><code>//颜色字符串转颜色对象public static Color GetColor(string ColorStr)  {      int ARGBvalue = 0;      Color newColor = Color.FromName(ColorStr);      if ((newColor.A + newColor.R + newColor.G + newColor.B) == 0)      {          int.TryParse(ColorStr, System.Globalization.NumberStyles.HexNumber, null, out ARGBvalue);          newColor = Color.FromArgb(ARGBvalue);      }      return newColor;  }private void gridView2_RowStyle_2(object sender, RowStyleEventArgs e)  {      List&lt;Student&gt; list = StudentDao.GetAll();      string name = &quot;&quot;;                          while(e.RowHandle &gt;= 0) {          if (gridView2.GetRowCellValue(e.RowHandle, &quot;NAME&quot;)!=null) { //NAME为列的字段名fildName             name = gridView2.GetRowCellValue(e.RowHandle, &quot;NAME&quot;).ToString();          }          if (list != null &amp;&amp; list.Count &gt; 0)          {              for (int i = 0; i &lt; list.Count; i++)              {                  Student s = list[i];                                         if (name != &quot;&quot; )                  {                      if (name.Equals(s.name))                      {                          Color color = GetColor(s.color);                          e.Appearance.ForeColor = color;//改变字体颜色                          //e.Appearance.BackColor = Color.Red;//改变背景色                      }                  }              }          }                  break;      }  }</code></pre><p>5.效果预览如下:</p><p>点击添加名单–选择颜色等</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color1.png" alt=""></p><p>显示列表如下，根据条件显示字体颜色</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、根据列表数据改变行字体颜色或者背景色&quot;&gt;&lt;a href=&quot;#一、根据列表数据改变行字体颜色或者背景色&quot; class=&quot;headerlink&quot; title=&quot;一、根据列表数据改变行字体颜色或者背景色&quot;&gt;&lt;/a&gt;一、根据列表数据改变行字体颜色或者背景色&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
