<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang&#39;s Blog</title>
  
  
  <link href="/wanglinyong.github.io/atom.xml" rel="self"/>
  
  <link href="https://wanglinyong.github.io/"/>
  <updated>2018-03-24T11:40:53.382Z</updated>
  <id>https://wanglinyong.github.io/</id>
  
  <author>
    <name>WangLinYong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DES加密解密</title>
    <link href="https://wanglinyong.github.io/2018/03/24/DES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>https://wanglinyong.github.io/2018/03/24/DES加密解密/</id>
    <published>2018-03-24T11:39:28.000Z</published>
    <updated>2018-03-24T11:40:53.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h1><p>我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！</p><p>查看日志后发现每次加密的结果都不同，后来百度得知是DES在linux和windows系统的加密算法不一致导致的。主要是DES补位导致，把补位规则改成”DES/ECB/PKCS5Padding”即可。</p><h1 id="二、DES加密解密代码"><a href="#二、DES加密解密代码" class="headerlink" title="二、DES加密解密代码"></a>二、DES加密解密代码</h1><pre><code>package wang.dreamland.www.common;import java.security.Key;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;public class MyDes {/** * 加密数据 * @param encryptString * @param encryptKey * @return * @throws Exception */public static String encryptDES(String encryptString, String encryptKey) throws Exception {    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getKey(encryptKey), &quot;DES&quot;));    byte[] encryptedData = cipher.doFinal(encryptString.getBytes(&quot;UTF-8&quot;));    return Base64.encodeBase64String(encryptedData);}/** * key  不足8位补位 * @param */public static byte[] getKey(String keyRule) {    Key key = null;    byte[] keyByte = keyRule.getBytes();    // 创建一个空的八位数组,默认情况下为0    byte[] byteTemp = new byte[8];    // 将用户指定的规则转换成八位数组    for (int i = 0; i &lt; byteTemp.length &amp;&amp; i &lt; keyByte.length; i++) {        byteTemp[i] = keyByte[i];    }    key = new SecretKeySpec(byteTemp, &quot;DES&quot;);    return key.getEncoded();}/*** * 解密数据 * @param decryptString * @param decryptKey * @return * @throws Exception */public static String decryptDES(String decryptString, String decryptKey) throws Exception {    byte[] sourceBytes = Base64.decodeBase64(decryptString);    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(getKey(decryptKey), &quot;DES&quot;));    byte[] decoded = cipher.doFinal(sourceBytes);    return new String(decoded, &quot;UTF-8&quot;);}public static void main(String[] args) throws Exception {    String clearText = &quot;wanglinyong@163.com&quot;;    String key = &quot;123456&quot;;//密钥    System.out.println(&quot;明文：&quot;+clearText+&quot;\n密钥：&quot;+key);    String encryptText = encryptDES(clearText, key);    System.out.println(&quot;加密后：&quot;+encryptText);    String decryptText = decryptDES(encryptText, key);    System.out.println(&quot;解密后：&quot;+decryptText);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、场景&quot;&gt;&lt;a href=&quot;#一、场景&quot; class=&quot;headerlink&quot; title=&quot;一、场景&quot;&gt;&lt;/a&gt;一、场景&lt;/h1&gt;&lt;p&gt;我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！&lt;/p&gt;
&lt;p&gt;查看日
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统使用Gogs搭建自己的git服务</title>
    <link href="https://wanglinyong.github.io/2018/03/24/linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Gogs%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84git%E6%9C%8D%E5%8A%A1/"/>
    <id>https://wanglinyong.github.io/2018/03/24/linux系统使用Gogs搭建自己的git服务/</id>
    <published>2018-03-24T07:25:42.000Z</published>
    <updated>2018-04-04T13:44:42.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装Gogs服务"><a href="#一、安装Gogs服务" class="headerlink" title="一、安装Gogs服务"></a>一、安装Gogs服务</h1><h2 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户"></a>1.新建用户</h2><p>Gogs默认以 git 用户运行（你不会想用一个能修改 ssh 配置的程序以 root 用户运行吧）。 </p><pre><code>sudo adduser git  # 新建git用户。 </code></pre><p> 以 git 用户登录，到 git 用户的主目录中新建好 .ssh 文件夹。(新建git用户后我的出现在/home目录下)</p><pre><code>su gitcd /home/gitmkdir .ssh</code></pre><h2 id="2-下载安装包并解压"><a href="#2-下载安装包并解压" class="headerlink" title="2.下载安装包并解压"></a>2.下载安装包并解压</h2><p>我使用的是预编译的二进制包。下载链接</p><pre><code>https://gogs.io/docs/installation/install_from_binary</code></pre><p>查看linux系统是32位还是64位系统命令，32位选择386，64位选择amd64</p><pre><code>getconf LONG_BIT</code></pre><p>需要从源码编译的话，请参考一般 Go 语言项目的编译。下载后解包到你喜欢的地方，例如 /usr/share/gogs/ 或者 /home/git/gogs/ 。文件夹的内容如下。</p><pre><code>gogs  LICENSE  public  README.md  README_ZH.md  scripts  templates</code></pre><h2 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3.创建数据库"></a>3.创建数据库</h2><p>创建database,名称为gogs</p><pre><code>CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;GRANT ALL PRIVILEGES ON gogs.* TO &apos;root&apos;@&apos;localhost&apos; identified by &apos;root&apos;;FLUSH PRIVILEGES;</code></pre><p>在 Gogs 目录的 scripts/mysql.sql 文件是数据库初始化文件。执行</p><pre><code>mysql -u root -p &lt; scripts/mysql.sql （需要输入密码）即可初始化好数据库。</code></pre><p>然后登录 MySQL 创建一个新用户 gogs，并将数据库 gogs 的所有权限都赋予该用户。</p><pre><code>$ mysql -u root -p&gt; # （输入密码）&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;密码&apos;;&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;;&gt; flush privileges;&gt; exit;</code></pre><h2 id="4-运行-gogs-web"><a href="#4-运行-gogs-web" class="headerlink" title="4.运行 gogs web"></a>4.运行 gogs web</h2><p>进入gogs目录下，并运行gogs</p><pre><code>cd /home/git/gogs/gogsnohup ./gogs web &amp; tail -f nohup.out #并打印日志nohup ./gogs web &amp; #仅后台运行 ./gogs web  #前台运行</code></pre><p>然后访问 <a href="http://服务器IP:3000/" target="_blank" rel="external">http://服务器IP:3000/</a> 来进行安装，填写好表单之后提交就可以了。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.如果访问网页失败，可能防火墙没有打开3000的端口，防火墙相关配置请查看linux系统相关服务这篇博客。</p><p>2.还有0.6.9.0903 Beta 版本有个 bug，允许在关闭注册的情况下不添加管理员，这样安装完成之后将没有任何用户可以登录。所以请务必在安装界面指定一个管理员帐号。</p><h2 id="5-相关配置"><a href="#5-相关配置" class="headerlink" title="5.相关配置"></a>5.相关配置</h2><p>1.配置文件位于 Gogs 目录的 custom/conf/app.ini ，是 INI 格式的文本文件。详细的配置解释和默认值请参考官方文档 ，其中关键的配置大概是下面这些。</p><pre><code>RUN_USER 默认是 git ，指定 Gogs 以哪个用户运行ROOT 所有仓库的存储根路径PROTOCOL 如果你使用 nginx 反代的话请使用 http ，如果直接裸跑对外服务的话随意DOMAIN 域名。会影响 SSH clone 地址ROOT_URL 完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址HTTP_ADDR 监听地址，使用 nginx 的话建议 127.0.0.1 ，否则 0.0.0.0 也可以HTTP_PORT 监听端口，默认 3000INSTALL_LOCK 锁定安装页面Mailer 相关的选项</code></pre><p>其中，Mailer 可以使用 Mailgun 的免费邮件发送服务，将 Mailgun 的 SMTP 配置填入到配置中就好。</p><p>2.附app.ini(192.168.120.132为我使用的虚拟机ip)</p><pre><code>APP_NAME = GogsRUN_USER = gitRUN_MODE = prod[database]DB_TYPE  = mysqlHOST     = 127.0.0.1:3306NAME     = gogsUSER     = gogsPASSWD   = gogsSSL_MODE = disablePATH     = data/gogs.db[repository]ROOT = /home/git/gogs-repositories[server]DOMAIN           = 192.168.120.132HTTP_PORT        = 3000ROOT_URL         = http://192.168.120.132:3000/DISABLE_SSH      = falseSSH_PORT         = 1111START_SSH_SERVER = trueOFFLINE_MODE     = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL     = falseDISABLE_REGISTRATION   = falseENABLE_CAPTCHA         = trueREQUIRE_SIGNIN_VIEW    = false[picture]DISABLE_GRAVATAR        = falseENABLE_FEDERATED_AVATAR = true[session]PROVIDER = file[log]MODE      = fileLEVEL     = InfoROOT_PATH = /home/git/gogs/gogs/log[security]INSTALL_LOCK = trueSECRET_KEY   = YfaCLhKinQVLlb7</code></pre><h2 id="6-nginx-反向代理"><a href="#6-nginx-反向代理" class="headerlink" title="6.nginx 反向代理"></a>6.nginx 反向代理</h2><p>在 /etc/nginx/sites-available 中新建一个文件，把以下内容写入文件中。</p><pre><code>server {server_name 域名或IP;listen 80; # 或者 443，如果你使用 HTTPS 的话# ssl on; 是否启用加密连接# 如果你使用 HTTPS，还需要填写 ssl_certificate 和 ssl_certificate_keylocation / { # 如果你希望通过子路径访问，此处修改为子路径，注意以 / 开头并以 / 结束    proxy_pass http://127.0.0.1:3000/;}}</code></pre><p>然后进入 /etc/nginx/sites-enabled 中，执行 </p><pre><code>ln -s ../sites-available/配置文件名   #启用这个配置文件。</code></pre><p>最后重启 nginx 就好了，Centos下是</p><pre><code>service nginx restart   #重启/etc/init.d/nginx stop  #停止/etc/init.d/nginx start #开始</code></pre><p>Ubuntu 下是 </p><pre><code>sudo service nginx restart 。</code></pre><h2 id="7-开机自动重启等脚本"><a href="#7-开机自动重启等脚本" class="headerlink" title="7.开机自动重启等脚本"></a>7.开机自动重启等脚本</h2><p>在scripts/文件夹下有关于多个系统的服务脚本：</p><pre><code>autoboot.sh  build_freebsd.sh  build_linux64.sh  build.sh  init launchd  mysql.sql  README  supervisor  systemd  windows</code></pre><p>其中init,systemd以及windows目录分别为linux、Windows下服务脚本。<br>在此仅以CentOS为例:</p><p>复制scripts/init/centos/gogs到/etc/init.d/目录下:</p><pre><code>sudo cp scripts/init/centos/gogs /etc/init.d/</code></pre><p>切换到/etc/init.d/目录为脚本赋予可执行权限</p><pre><code>sudo chmod +x gogs</code></pre><p>更改gogs脚本内关于GOGS_HOME目录位置的设置(这儿使用vim编辑)</p><pre><code>GOGS_HOME=/data/gogs/gogs</code></pre><p>使用服务管理命令管理服务</p><pre><code>sudo service gogs start/stop/restart/status</code></pre><p>配置Gogs开机自启动</p><pre><code>sudo chkconfig --add gogs</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装Gogs服务&quot;&gt;&lt;a href=&quot;#一、安装Gogs服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装Gogs服务&quot;&gt;&lt;/a&gt;一、安装Gogs服务&lt;/h1&gt;&lt;h2 id=&quot;1-新建用户&quot;&gt;&lt;a href=&quot;#1-新建用户&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Git" scheme="https://wanglinyong.github.io/tags/Git/"/>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Gogs" scheme="https://wanglinyong.github.io/tags/Gogs/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式数据库H2</title>
    <link href="https://wanglinyong.github.io/2018/03/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93H2/"/>
    <id>https://wanglinyong.github.io/2018/03/15/嵌入式数据库H2/</id>
    <published>2018-03-15T12:08:23.000Z</published>
    <updated>2018-03-16T09:32:16.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>由于项目中需要将数据库嵌入到程序中，一起打包发给客户使用，所以需要使用嵌入式数据库，目前常用的嵌入式数据库有：Berkeley DB、Couchbase Lite、LevelDB、SQLite、UnQLite、H2等，由于H2具有以下特点，所以最终选择了H2作为存储数据库。</p><pre><code>1、纯Java编写，不受平台的限制；2、只有一个jar文件，适合作为嵌入式数据库使用；3、h2提供了一个十分方便的web控制台用于操作和管理数据库内容；4、功能完整，支持标准SQL和JDBC。麻雀虽小五脏俱全；5、支持内嵌模式、服务器模式和集群。</code></pre><h1 id="一、H2简介"><a href="#一、H2简介" class="headerlink" title="一、H2简介"></a>一、H2简介</h1><p>H2是一个用Java开发的嵌入式数据库，它本身只是一个类库，可以直接嵌入到应用项目中。</p><p>Ｈ2最大的用途在于可以同应用程序打包在一起发布，这样可以非常方便地存储少量结构化数据。<br>它的另一个用途是用于单元测试。启动速度快，而且可以关闭持久化功能，每一个用例执行完随即还原到初始状态。</p><p>Ｈ2的第三个用处是作为缓存，作为NoSQL的一个补充。当某些场景下数据模型必须为关系型，可以拿它当Memcached使，作为后端MySQL/Oracle的一个缓冲层，缓存一些不经常变化但需要频繁访问的数据，比如字典表、权限表。不过这样系统架构就会比较复杂了。</p><h1 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h1><p>1、下载</p><pre><code>H2数据库下载地址：http://www.h2database.com/html/download.html</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-1.png" alt=""></p><p>Windows、Linux下都可以直接解压缩就用。</p><p>2、安装</p><p>解压缩后的目录结构：</p><p>　　h2</p><p>　　|—bin</p><p>　　|    |—h2-1.1.116.jar 　　//H2数据库的jar包（驱动也在里面）</p><p>　　|    |—h2.bat         　　   //Windows控制台启动脚本</p><p>　　|    |—h2.sh                  //Linux控制台启动脚本</p><p>　　|    |—h2w.bat              //Windows控制台启动脚本（不带黑屏窗口）</p><p>　　|—docs                       //H2数据库的帮助文档（内有H2数据库的使用手册）</p><p>　　|—service //通过wrapper包装成服务。</p><p>　　|—src //H2数据库的源代码</p><p>　　|—build.bat //windows构建脚本</p><p>　　|—build.sh //linux构建脚本</p><p>　　此时就算“安装”完成了。</p><h1 id="三、运行模式与运行方式"><a href="#三、运行模式与运行方式" class="headerlink" title="三、运行模式与运行方式"></a>三、运行模式与运行方式</h1><h2 id="1、运行模式"><a href="#1、运行模式" class="headerlink" title="1、运行模式"></a>1、运行模式</h2><p>　　Ｈ2有三种运行模式。</p><pre><code>（1）内嵌模式（Embedded Mode）内嵌模式下，应用和数据库同在一个JVM中，通过JDBC进行连接。 可持久化，但同时只能一个客户端连接。内嵌模式性能会比较好。（2）服务器模式（Server Mode）使用服务器模式和内嵌模式一样，只不过它可以跑在另一个进程里。（3）混合模式第一个应用以内嵌模式启动它，对于后面的应用来说它是服务器模式跑着的。混合模式是内嵌模式和服务器模式的组合。第一个应用通过内嵌模式与数据库建立连接，同时也作为一个服务器启动，于是另外的应用（运行在不同的进程或是虚拟机上）可以同时访问同样的数据。第一个应用的本地连接与嵌入式模式的连接性能一样的快，而其它连接理论上会略慢。 </code></pre><h2 id="2、运行方式"><a href="#2、运行方式" class="headerlink" title="2、运行方式"></a>2、运行方式</h2><p>　　开发中肯定是Server Mode方便，因为需要用工具管理数据。所以进入Ｈ2的bin目录。如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-2.png" alt=""></p><p>如果你在Win环境可以运行h2.bat或h2w.bat。区别只是后者是后台静默运行</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-3.png" alt=""></p><h1 id="四、应用程序开发"><a href="#四、应用程序开发" class="headerlink" title="四、应用程序开发"></a>四、应用程序开发</h1><h2 id="1、通过远程浏览器来访问h2"><a href="#1、通过远程浏览器来访问h2" class="headerlink" title="1、通过远程浏览器来访问h2"></a>1、通过远程浏览器来访问h2</h2><pre><code>访问地址：http://服务器ip:8082/ ，出现如下页面：</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-5.png" alt=""></p><h2 id="２、路径的配置"><a href="#２、路径的配置" class="headerlink" title="２、路径的配置"></a>２、路径的配置</h2><pre><code>jdbc:h2:~/test是H2的路径。User name : sa是h2默认的用户，密码可空。最好设置下密码，尤其当你的Ｈ2部署在公网时。不然会被无聊人把数据删掉。</code></pre><h2 id="3、连接"><a href="#3、连接" class="headerlink" title="3、连接"></a>3、连接</h2><pre><code>点击如图Test connect按钮测试连接。此时如果数据库文件本身不存在则会自动创建。点击Connect，进入管理终端。</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-6.png" alt=""></p><p>Ｈ２的管理终端做得很不错的。按Ctrl+Enter执行输入区的SQL，按Shift+Enter执行当前选中的SQL。</p><h1 id="五、应用程序开发"><a href="#五、应用程序开发" class="headerlink" title="五、应用程序开发"></a>五、应用程序开发</h1><h2 id="1、加入Maven依赖"><a href="#1、加入Maven依赖" class="headerlink" title="1、加入Maven依赖"></a>1、加入Maven依赖</h2><pre><code>&lt;dependency&gt;&lt;groupId&gt;com.h2database&lt;/groupId&gt;&lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;version&gt;1.4.195&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="2、创建db-properties"><a href="#2、创建db-properties" class="headerlink" title="2、创建db.properties"></a>2、创建db.properties</h2><pre><code>driverClassName=org.h2.Driver</code></pre><p>此处的写法是使用嵌入模式链接H2库，紧接着那行是使用Server Mode用tcp连接。区别一个是前者性能更好，后者可同时多个客户端连接</p><pre><code>url=jdbc:h2:D:/test#url=jdbc:h2:tcp://1localhost//usr/h2/data/rlibusername=sapassword=</code></pre><h2 id="PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下："><a href="#PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下：" class="headerlink" title="PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下："></a>PS：在使用嵌入模式链接H2库时，使用管理页面连接会报错如下：</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-4.png" alt=""></p><h1 id="六、H2管理工具-DBeaver"><a href="#六、H2管理工具-DBeaver" class="headerlink" title="六、H2管理工具-DBeaver"></a>六、H2管理工具-DBeaver</h1><p>可通过数据库管理工具DBeaver来有效管理H2，直接从网上下载即可，这里不提供下载和安装过程</p><p>打开DBeaver.exe,操作如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-7.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-8.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-9.png" alt=""></p><p>输入用户名sa  </p><p>密码自己设置一个  也可以不设，点击下一步</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-10.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-11.png" alt=""></p><p>打开test数据库，即可对表进行增删改查操作了</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/h2-12.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;由于项目中需要将数据库嵌入到程序中，一起打包发给客户使用，所以需要使用嵌入式数据库，目前常用的嵌入式数据库有：Berkeley DB、Cou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA-UDP接收和发送json数据</title>
    <link href="https://wanglinyong.github.io/2018/03/06/UDP%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81json%E6%95%B0%E6%8D%AE/"/>
    <id>https://wanglinyong.github.io/2018/03/06/UDP接收和发送json数据/</id>
    <published>2018-03-06T11:49:09.000Z</published>
    <updated>2018-03-16T07:21:44.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、UDP服务端发送数据"><a href="#一、UDP服务端发送数据" class="headerlink" title="一、UDP服务端发送数据"></a>一、UDP服务端发送数据</h1><pre><code>public class UdpClient {public static void main(String[] args) throws Exception {    DatagramSocket socket = new DatagramSocket();    String s = getJsonStr();    byte[] buf = s.getBytes();    //将数据打包    DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(&quot;192.168.11.139&quot;), 6070);    socket.send(packet);    socket.close();}public  static  String getJsonStr(){    Person p = new Person();    p.setName( &quot;张三&quot; );    p.setAge( 18 );    p.setGender( &quot;男&quot; );    return JSONObject.toJSONString( p );}}</code></pre><p>利用fastjson将对象转换为json字符串</p><pre><code>JSONObject.toJSONString( p );</code></pre><h1 id="二、UDP客户端接收数据"><a href="#二、UDP客户端接收数据" class="headerlink" title="二、UDP客户端接收数据"></a>二、UDP客户端接收数据</h1><pre><code>public class UdpServer {public static void main(String[] args) throws Exception {    // 定义一个接收端，并且指定了接收的端口号    DatagramSocket socket = new DatagramSocket(6070);    while (true) {        byte[] buf = new byte[1024];        // 解析数据包        DatagramPacket packet = new DatagramPacket(buf, buf.length);        socket.receive(packet);        String ip = packet.getAddress().getHostAddress();        buf = packet.getData();        String data = new String(buf, 0, packet.getLength());        System.out.println(&quot;收到 &quot; + ip + &quot; 发来的消息：&quot; + data);        //Person p = JSON.parseObject(data, new TypeReference&lt;Person&gt;() {});        Person p=JSONObject.parseObject(data, Person.class);//JSON字符串转对象        System.out.println(p.toString());    }}}</code></pre><p>利用fastjson将接收到的json字符串转为对象</p><pre><code>Person p=JSONObject.parseObject(data, Person.class);//JSON字符串转对象</code></pre><p>三、实体类Person</p><pre><code>public class Person {private  String  name;private  int age;private String gender;public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}public String getGender() {    return gender;}public void setGender(String gender) {    this.gender = gender;}@Overridepublic String toString() {    return &quot;Person{&quot; +            &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +            &quot;, age=&quot; + age +            &quot;, gender=&apos;&quot; + gender + &apos;\&apos;&apos; +            &apos;}&apos;;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、UDP服务端发送数据&quot;&gt;&lt;a href=&quot;#一、UDP服务端发送数据&quot; class=&quot;headerlink&quot; title=&quot;一、UDP服务端发送数据&quot;&gt;&lt;/a&gt;一、UDP服务端发送数据&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;public class UdpClient
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mysql每天定时清空表</title>
    <link href="https://wanglinyong.github.io/2018/01/26/mysql%E5%AE%9A%E6%97%B6%E6%B8%85%E7%A9%BA%E8%A1%A8/"/>
    <id>https://wanglinyong.github.io/2018/01/26/mysql定时清空表/</id>
    <published>2018-01-26T11:16:36.000Z</published>
    <updated>2018-03-08T01:16:02.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql每天定时清空表"><a href="#Mysql每天定时清空表" class="headerlink" title="Mysql每天定时清空表"></a>Mysql每天定时清空表</h1><p>1.设置开启event scheduler</p><pre><code>SET GLOBAL event_scheduler=1;</code></pre><p>2.验证event_scheduler是否已经开启</p><pre><code>show variables like &apos;%event%&apos;;  #值为 ON 表明已开启SHOW VARIABLES LIKE &apos;event_scheduler&apos;;</code></pre><p>3.创建event</p><pre><code>DROP EVENT IF EXISTS e_delete_upvote; CREATE  EVENT e_delete_upvote    ON SCHEDULE EVERY 1 day STARTS date_add(concat(current_date(), &apos; 00:00:00&apos;), interval 0 second) ON COMPLETION PRESERVE ENABLE DO TRUNCATE TABLE dreamland.upvote;#说明： ON SCHEDULE EVERY 1 day 指定循环间隔为每天执行 STARTS date_add(concat(current_date(), &apos; 23:59:00&apos;), interval 0 second) 指定运行时间为23:59:00 ON COMPLETION PRESERVE ENABLE 指定创建完成后即启用，否则需手动启动</code></pre><p>4.手动关闭事件</p><pre><code>ALTER EVENT e_delete_upvote DISABLE;</code></pre><p>5.手动该事件为可用</p><pre><code>ALTER EVENT e_delete_upvote ENABLE;</code></pre><p>6.查看已有的定时事件任务</p><pre><code>SHOW EVENTS;</code></pre><p>7.删除事件</p><pre><code>DROP EVENT e_delete_upvote;</code></pre><h3 id="注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql-ini文件中加入event-scheduler-ON-的语句"><a href="#注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql-ini文件中加入event-scheduler-ON-的语句" class="headerlink" title="注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql.ini文件中加入event_scheduler = ON; 的语句"></a>注意：真实的开发环境中，会遇到mysql服务重启或者断电的情况，此时则会出现事件调度器被关闭的情况，所有事件都不在起作用，要想解决这个办法，则需要在mysql.ini文件中加入event_scheduler = ON; 的语句</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql每天定时清空表&quot;&gt;&lt;a href=&quot;#Mysql每天定时清空表&quot; class=&quot;headerlink&quot; title=&quot;Mysql每天定时清空表&quot;&gt;&lt;/a&gt;Mysql每天定时清空表&lt;/h1&gt;&lt;p&gt;1.设置开启event scheduler&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 打开Excel文件方法</title>
    <link href="https://wanglinyong.github.io/2018/01/23/csharp%E6%89%93%E5%BC%80Excel%E6%96%87%E4%BB%B6/"/>
    <id>https://wanglinyong.github.io/2018/01/23/csharp打开Excel文件/</id>
    <published>2018-01-23T11:43:06.000Z</published>
    <updated>2018-03-24T13:22:27.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、C-怎样打开Excel文件"><a href="#一、C-怎样打开Excel文件" class="headerlink" title="一、C#怎样打开Excel文件"></a>一、C#怎样打开Excel文件</h1><p>1.右键–Add DevExpress Item – New Item，新建一个Form窗体</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e1.png" alt=""></p><p>2.打开工具箱，搜索spreadsheetControl</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e2.png" alt=""></p><p>3.将工具spreadsheetControl拖入新建的窗体中</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e3.png" alt=""></p><p>4.可添加打开，保存，打印等按钮，我是随窗体打开一起打开excel，所以没有添加按钮，主要代码如下：</p><pre><code>using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Text;using System.Linq;using System.Threading.Tasks;using System.Windows.Forms;using DevExpress.XtraEditors;using System.IO;using DevExpress.Spreadsheet;namespace rdms.Forms{public partial class frmARFCN : Form{    private static log4net.ILog LOG = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);    //记录窗体的名称    readonly string mainFormText;    public frmARFCN()    {        InitializeComponent();        //记录窗体的名称，并实现文档变化事件的处理，方便显示新的文件名称        mainFormText = this.Text;        this.spreadsheetControl1.DocumentLoaded += new EventHandler(spreadsheetControl1_DocumentLoaded);        openFile();    }    /// &lt;summary&gt;    /// 文档变化后，实现对新文件名称的显示    /// &lt;/summary&gt;    void spreadsheetControl1_DocumentLoaded(object sender, EventArgs e)    {        string fileName = Path.GetFileName(this.spreadsheetControl1.Document.Path);        if (String.IsNullOrEmpty(fileName))        {            Text = mainFormText;        }        else        {            Text = fileName + &quot; - &quot; + mainFormText;        }    }    /// &lt;summary&gt;    /// 打开Excel文件    /// &lt;/summary&gt;    private void openFile()    {        string path = Application.StartupPath;        LOG.Info(&quot;path===&quot;+path);        string filePath = path + &quot;\\Data\\about.xls&quot;;        if (!string.IsNullOrEmpty(filePath))        {            IWorkbook workbook = spreadsheetControl1.Document;            workbook.LoadDocument(filePath);        }    }    /// &lt;summary&gt;    /// 保存Excel文件    /// &lt;/summary&gt;    private void btnSaveFile_Click(object sender, EventArgs e)    {        spreadsheetControl1.SaveDocument();    }    /// &lt;summary&gt;    /// Excel文件打印    /// &lt;/summary&gt;    private void btnPreview_Click(object sender, EventArgs e)    {        this.spreadsheetControl1.ShowPrintPreview();    }}}</code></pre><p>5.点击某个按钮弹出frmARFCN的form窗体</p><pre><code> private void btn_Click(object sender, EventArgs e){            using (frmARFCN frm = new frmARFCN())    {        DialogResult ret = frm.ShowDialog(this);    }       }</code></pre><p>6.显示效果如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/e4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、C-怎样打开Excel文件&quot;&gt;&lt;a href=&quot;#一、C-怎样打开Excel文件&quot; class=&quot;headerlink&quot; title=&quot;一、C#怎样打开Excel文件&quot;&gt;&lt;/a&gt;一、C#怎样打开Excel文件&lt;/h1&gt;&lt;p&gt;1.右键–Add DevExpres
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# Gridview 改变行字体颜色或背景色</title>
    <link href="https://wanglinyong.github.io/2018/01/19/csharp%E6%94%B9%E5%8F%98%E8%A1%8C%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E6%88%96%E8%83%8C%E6%99%AF%E8%89%B2/"/>
    <id>https://wanglinyong.github.io/2018/01/19/csharp改变行字体颜色或背景色/</id>
    <published>2018-01-19T11:43:06.000Z</published>
    <updated>2018-03-24T13:21:59.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、根据列表数据改变行字体颜色或者背景色"><a href="#一、根据列表数据改变行字体颜色或者背景色" class="headerlink" title="一、根据列表数据改变行字体颜色或者背景色"></a>一、根据列表数据改变行字体颜色或者背景色</h1><p>1.ALT+ENTER键打开属性列表，根据Name.Color.Name获取颜色字符串</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color.png" alt=""></p><pre><code>string color =  tePhone1.Color.Name;</code></pre><p>2.将颜色字符串存入数据库，附上数据库Dao代码</p><pre><code>    namespace rdms.DB   {public class StudentDao{    private static ILog LOG = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);    public static List&lt;Student&gt; GetAll()    {        return DBContext.ScodeSession.From&lt;Student&gt;().Select().ToList();    }    public static int Update(Student s)    {                // DBContext.ScodeSession.FromSql(&quot;UPDATE  Student  SET  color = &apos;&quot;+s.color+ &quot;&apos; where s_id = &quot; + s.s_id);        return DBContext.ScodeSession.Update(s);    }    public static Student getStudent(int id)    {        List&lt;Student&gt; list = DBContext.ScodeSession.FromSql(&quot;SELECT *  FROM Student  where s_id = &quot; + id).ToList&lt;Student&gt;();        if (list != null &amp;&amp; list.Count &gt; 0)        {            return list[0];        }        else        {            return null;        }    }    public static int Add(Student s)    {        return DBContext.ScodeSession.Insert(s);    }    public static void Delete(Student s)    {        DBContext.ScodeSession.Delete&lt;Student&gt;(s);    }}</code></pre><p>}</p><p>3.在显示列表点击Run Designer，在事件列表中找到RowStyle,给一个事件名称</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color4.png" alt=""></p><p>4.具体实现代码如下</p><pre><code>//颜色字符串转颜色对象public static Color GetColor(string ColorStr)  {      int ARGBvalue = 0;      Color newColor = Color.FromName(ColorStr);      if ((newColor.A + newColor.R + newColor.G + newColor.B) == 0)      {          int.TryParse(ColorStr, System.Globalization.NumberStyles.HexNumber, null, out ARGBvalue);          newColor = Color.FromArgb(ARGBvalue);      }      return newColor;  }private void gridView2_RowStyle_2(object sender, RowStyleEventArgs e)  {      List&lt;Student&gt; list = StudentDao.GetAll();      string name = &quot;&quot;;                          while(e.RowHandle &gt;= 0) {          if (gridView2.GetRowCellValue(e.RowHandle, &quot;NAME&quot;)!=null) { //NAME为列的字段名fildName             name = gridView2.GetRowCellValue(e.RowHandle, &quot;NAME&quot;).ToString();          }          if (list != null &amp;&amp; list.Count &gt; 0)          {              for (int i = 0; i &lt; list.Count; i++)              {                  Student s = list[i];                                         if (name != &quot;&quot; )                  {                      if (name.Equals(s.name))                      {                          Color color = GetColor(s.color);                          e.Appearance.ForeColor = color;//改变字体颜色                          //e.Appearance.BackColor = Color.Red;//改变背景色                      }                  }              }          }                  break;      }  }</code></pre><p>5.效果预览如下:</p><p>点击添加名单–选择颜色等</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color1.png" alt=""></p><p>显示列表如下，根据条件显示字体颜色</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/color2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、根据列表数据改变行字体颜色或者背景色&quot;&gt;&lt;a href=&quot;#一、根据列表数据改变行字体颜色或者背景色&quot; class=&quot;headerlink&quot; title=&quot;一、根据列表数据改变行字体颜色或者背景色&quot;&gt;&lt;/a&gt;一、根据列表数据改变行字体颜色或者背景色&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c# 利用Dockmanager工具使窗体显示和隐藏</title>
    <link href="https://wanglinyong.github.io/2018/01/07/csharp%20Dockmanager%E7%AA%97%E4%BD%93%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F/"/>
    <id>https://wanglinyong.github.io/2018/01/07/csharp Dockmanager窗体显示和隐藏/</id>
    <published>2018-01-07T11:28:32.000Z</published>
    <updated>2018-01-05T06:46:35.055Z</updated>
    
    <content type="html"><![CDATA[<p>1.打开工具箱，选择Dockmanager工具，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/panel1.png" alt=""></p><p>2.点击dockManager1的倒三角，点击Add bottom panel 在底部添加panel,如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/panel2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/panel3.png" alt=""></p><p>3.可将内容添加到此panel窗体中，点击图钉按钮即可选择固定与否<br><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/panel4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.打开工具箱，选择Dockmanager工具，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/panel1.png&quot; alt=&quot;&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sqlite 获取一小时内数据sql</title>
    <link href="https://wanglinyong.github.io/2018/01/05/sqlite%E8%8E%B7%E5%8F%96%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E6%95%B0%E6%8D%AEsql/"/>
    <id>https://wanglinyong.github.io/2018/01/05/sqlite获取一小时内数据sql/</id>
    <published>2018-01-05T03:08:05.000Z</published>
    <updated>2018-01-05T03:15:41.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>项目中用到了Sqlite数据库，需要查询距当前一小时内的数据，由于对Sqlite不熟，各种百度找答案，查到了很多日期函数，但是就是不起作用，最后经过摸索最终解决该问题，在此记录一下，有需要的小伙伴也可以看一下。</p><p>1.查询距当前时间一小时内的数据</p><pre><code>SELECT * FROM table_name t where datetime(t.create_time) &gt; datetime(&apos;now&apos;,&apos;-1 hour&apos;,&apos;localtime&apos;) </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;项目中用到了Sqlite数据库，需要查询距当前一小时内的数据，由于对Sqlite不熟，各种百度找答案，查到了很多日期函数，但是就是不起作用，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c#GridView获取选中当前行</title>
    <link href="https://wanglinyong.github.io/2018/01/02/csharp%E8%8E%B7%E5%8F%96%E9%80%89%E4%B8%AD%E5%BD%93%E5%89%8D%E8%A1%8C/"/>
    <id>https://wanglinyong.github.io/2018/01/02/csharp获取选中当前行/</id>
    <published>2018-01-02T08:23:05.000Z</published>
    <updated>2018-01-02T08:56:08.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、添加右击菜单"><a href="#一、添加右击菜单" class="headerlink" title="一、添加右击菜单"></a>一、添加右击菜单</h1><p>1、打开工具箱，选择ContextMenuStrip如下图</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/tool1.png" alt=""></p><p>2、可输入右键菜单名称及添加图标，如下图</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/tool2.png" alt=""></p><p>3、如果想在哪个窗口右击显示就在哪个窗口ALT+ENTER打开属性窗口，将<br>ContextMenuStrip选项的值设为刚才添加的名字，如下图</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/tool3.png" alt=""></p><p>4、双击右键添加的菜单即可添加单击事件</p><h1 id="二、添加回车Enter事件"><a href="#二、添加回车Enter事件" class="headerlink" title="二、添加回车Enter事件"></a>二、添加回车Enter事件</h1><p>1、在要添加回车事件的文本框ALT+ENTER打开属性窗口，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/enter1.png" alt=""></p><p>2、将KeyDown选项的值填上触发回车事件的方法名，如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/enter2.png" alt=""></p><p>3、写入触发事件方法，如：</p><pre><code>private void txtPwd_KeyDown(object sender, KeyEventArgs e)  {      if (e.KeyCode == Keys.Enter)      {          this.btnSearch_Click(sender, e);//触发与点击按钮一样的效果      }  }</code></pre><h1 id="三、获取选中行数据"><a href="#三、获取选中行数据" class="headerlink" title="三、获取选中行数据"></a>三、获取选中行数据</h1><p>1、右击AddToBlack后触发点击事件，代码如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/s1.png" alt=""></p><pre><code>private void addToBlackToolStripMenuItem_Click_1(object sender, EventArgs e) {     int[] rows = gridView1.GetSelectedRows();     rdms_ueidinfo info = null;     if (rows.Length &gt; 0)     {         if (list != null &amp;&amp; list.Count &gt; 0)         {             info = list[rows[0]];         }         else         {             info = xxData.Ueidinfos[rows[0]];         }         Contact contact = new Contact();         contact.IMSI = info.imsi;         contact.IMEI = info.imei;         DialogResult ret = DialogResult.Cancel;         Cursor.Current = Cursors.WaitCursor;         using (frmEditContact frm = new frmEditContact(contact, OwnerForm.Ribbon))         {             ret = frm.ShowDialog(OwnerForm);         }         Cursor.Current = Cursors.Default;     } }</code></pre><p>2、双击行获取选中行数据，代码如下</p><pre><code>    private void addToBlackListByDouble(object sender, EventArgs e){    int[] rows = gridView1.GetSelectedRows();    rdms_ueidinfo info = null;    if (rows.Length &gt; 0)    {        if (list != null &amp;&amp; list.Count &gt; 0)        {             info = list[rows[0]];        }        else {             info = xxData.Ueidinfos[rows[0]];        }        Contact contact = new Contact();        contact.IMSI = info.imsi;        contact.IMEI = info.imei;        DialogResult ret = DialogResult.Cancel;        Cursor.Current = Cursors.WaitCursor;        using (frmEditContact frm = new frmEditContact(contact, OwnerForm.Ribbon))        {            ret = frm.ShowDialog(OwnerForm);        }        Cursor.Current = Cursors.Default;    }}</code></pre><p>3、代码解释：</p><pre><code>rdms_ueidinfo info = null;if (list != null &amp;&amp; list.Count &gt; 0)           {                info = list[rows[0]];           }           else {                info = xxData.Ueidinfos[rows[0]];           }</code></pre><p>点击查询后，将根据查询条件查询的结果list再次显示到该列表，此时要获取选中行，就需要判断，如果list不为null表示当前列表是根据查询后显示的结果，否则就是初始列表，要做不同的判断才能选中想要的结果，之前一直选不中，甚是烦恼，真的是难者不会，会者不难，经过多次摸索才明白。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、添加右击菜单&quot;&gt;&lt;a href=&quot;#一、添加右击菜单&quot; class=&quot;headerlink&quot; title=&quot;一、添加右击菜单&quot;&gt;&lt;/a&gt;一、添加右击菜单&lt;/h1&gt;&lt;p&gt;1、打开工具箱，选择ContextMenuStrip如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C#通过Devexpress控件实现进度条功能</title>
    <link href="https://wanglinyong.github.io/2017/12/10/csharp%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>https://wanglinyong.github.io/2017/12/10/csharp进度条/</id>
    <published>2017-12-10T12:28:25.000Z</published>
    <updated>2017-12-08T05:55:51.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Devexpress默认的等待提示框"><a href="#一、Devexpress默认的等待提示框" class="headerlink" title="一、Devexpress默认的等待提示框"></a>一、Devexpress默认的等待提示框</h1><p>效果如下:</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/old_jdt.png" alt=""></p><p>主要代码如下：</p><pre><code>WaitDialogForm wdf = new WaitDialogForm(&quot;提示&quot;, &quot;正在加载配置......&quot;);     int i = 100;     for (int j = 1; j &lt; i; j++)     {         Thread.Sleep(3000);         string id = i.ToString() + &quot;%&quot;;         string jd = j.ToString() + &quot;%&quot;;         wdf.SetCaption(&quot;执行进度（&quot; +jd + &quot;/&quot; +id+ &quot;）&quot;);     }     wdf.Close();</code></pre><p>如果提示错误，记得引入：</p><pre><code>using DevExpress.Utils;</code></pre><p>Devexpress默认的等待提示框看起来不够友好，所以我在它的基础上进行了重写。</p><h1 id="二、Devexpress升级版含等待条的提示框"><a href="#二、Devexpress升级版含等待条的提示框" class="headerlink" title="二、Devexpress升级版含等待条的提示框"></a>二、Devexpress升级版含等待条的提示框</h1><p>效果如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/new_jdt.png" alt=""></p><p>是不是感觉高大上好多！</p><p>下面上主要代码：</p><pre><code>int i = 100;      ShowDialogForm sdf = new ShowDialogForm(&quot;Point&quot;, &quot;Loading...&quot;, &quot;Please be patient for dozens of seconds &quot;, i);      for (int j = 1; j &lt; i; j++)      {          Thread.Sleep(300);          string id = j.ToString() + &quot;%&quot;;          string jd = i.ToString() + &quot;%&quot;;          sdf.SetCaption(&quot;Execution Progress（&quot; + id + &quot;/&quot; + jd + &quot;）&quot;);      }      sdf.Close();</code></pre><p>注意引入：</p><pre><code>using ET.ManagerApp;</code></pre><h2 id="主要文件如下"><a href="#主要文件如下" class="headerlink" title="主要文件如下"></a>主要文件如下</h2><p>1.ShowDialogForm.cs文件</p><pre><code>using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Text;using System.Windows.Forms;using DevExpress.XtraEditors;namespace ET.ManagerApp{public partial class ShowDialogForm : DevExpress.XtraEditors.XtraForm{    #region Fields &amp; Properties    /// &lt;summary&gt;    /// 标题    /// &lt;/summary&gt;    private string caption;    public string Caption    {        get { return caption; }        set { caption = value; }    }    /// &lt;summary&gt;    /// 消息    /// &lt;/summary&gt;    private string message;    public string Message    {        get { return message; }        set { message = value; }    }    /// &lt;summary&gt;    /// 描述    /// &lt;/summary&gt;    private string content;    public string Content    {        get { return content; }        set { content = value; }    }    /// &lt;summary&gt;    /// 进度条最小值    /// &lt;/summary&gt;    private int minProcess = 1;    public int MinProcess    {        get { return minProcess; }        set { minProcess = value; }    }    /// &lt;summary&gt;    /// 进度条最大值    /// &lt;/summary&gt;    private int maxProcess = 100;    public int MaxProcess    {        get { return maxProcess; }        set { maxProcess = value; }    }    #endregion    #region Constructed Function    public ShowDialogForm()    {        InitializeComponent();    }    /// &lt;summary&gt;    /// 设置    /// &lt;/summary&gt;    /// &lt;param name=&quot;_caption&quot;&gt;提示&lt;/param&gt;    public ShowDialogForm(string _caption)        : this(_caption, &quot;&quot;, &quot;&quot;, 100)    {    }    /// &lt;summary&gt;    /// 设置    /// &lt;/summary&gt;    /// &lt;param name=&quot;_caption&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;_message&quot;&gt;&lt;/param&gt;    public ShowDialogForm(string _caption,string _message)         : this(_caption, _message, &quot;&quot;,100)    {    }    /// &lt;summary&gt;    /// 设置    /// &lt;/summary&gt;    /// &lt;param name=&quot;_caption&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;_message&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;_content&quot;&gt;&lt;/param&gt;    public ShowDialogForm(string _caption, string _message,string _content)        : this(_caption, _message, _content, 100)    {    }    /// &lt;summary&gt;    /// 设置    /// &lt;/summary&gt;    /// &lt;param name=&quot;_caption&quot;&gt;提示&lt;/param&gt;    /// &lt;param name=&quot;_message&quot;&gt;消息内容&lt;/param&gt;    /// &lt;param name=&quot;_content&quot;&gt;详细描述&lt;/param&gt;    /// &lt;param name=&quot;_maxProcess&quot;&gt;进度条最大值&lt;/param&gt;    public ShowDialogForm(string _caption, string _message,string _content,int _maxProcess)        : this()    {        this.Caption = &quot;&quot;;        this.Message = &quot;&quot;;        this.Content = &quot;&quot;;        this.Caption = _caption == &quot;&quot; ? &quot;提示&quot; : _caption;        this.Message = _message == &quot;&quot; ? &quot;正在加载，请稍后......&quot; : _message;        this.Content = _content;        this.maxProcess = _maxProcess &gt; this.MinProcess ? _maxProcess : MinProcess;        lblCaption.Text = this.Caption;        lblMessage.Text = this.Message;        lblContent.Text = this.Content;        progressShow.Properties.Minimum = MinProcess;        progressShow.Properties.Maximum = MaxProcess;        progressShow.Properties.Step = 1;        progressShow.PerformStep();        this.ShowInTaskbar = false;        this.TopMost = true;        this.Show();        this.Refresh();    }    #endregion    #region Methods    /// &lt;summary&gt;    /// 设置提示    /// &lt;/summary&gt;    /// &lt;param name=&quot;newCaption&quot;&gt;&lt;/param&gt;    public void SetCaption(string newCaption)    {        this.Caption = newCaption;        lblCaption.Text = this.Caption;        progressShow.PerformStep();        this.Refresh();    }    /// &lt;summary&gt;    /// 设置消息    /// &lt;/summary&gt;    /// &lt;param name=&quot;newMessage&quot;&gt;&lt;/param&gt;    public void SetMessage(string newMessage)    {        this.Message = newMessage;        lblMessage.Text = this.Message;        progressShow.PerformStep();        this.Refresh();    }    /// &lt;summary&gt;    /// 设置描述    /// &lt;/summary&gt;    /// &lt;param name=&quot;newContent&quot;&gt;&lt;/param&gt;    public void SetContent(string newContent)    {        this.Content = newContent;        lblContent.Text = this.Content;        progressShow.PerformStep();        this.Refresh();    }    #endregion    #region Events    protected override void OnClosing(CancelEventArgs e)    {        base.OnClosing(e);    }    #endregion}}</code></pre><p>2.ShowDialogForm.Designer.cs文件</p><pre><code>namespace ET.ManagerApp{partial class ShowDialogForm{    /// &lt;summary&gt;    /// Required designer variable.    /// &lt;/summary&gt;    private System.ComponentModel.IContainer components = null;    /// &lt;summary&gt;    /// Clean up any resources being used.    /// &lt;/summary&gt;    /// &lt;param name=&quot;disposing&quot;&gt;true if managed resources should be disposed; otherwise, false.&lt;/param&gt;    protected override void Dispose(bool disposing)    {        if (disposing &amp;&amp; (components != null))        {            components.Dispose();        }        base.Dispose(disposing);    }    #region Windows Form Designer generated code    /// &lt;summary&gt;    /// Required method for Designer support - do not modify    /// the contents of this method with the code editor.    /// &lt;/summary&gt;    private void InitializeComponent()    {        this.panelControl1 = new DevExpress.XtraEditors.PanelControl();        this.lblCaption = new DevExpress.XtraEditors.LabelControl();        this.lblMessage = new DevExpress.XtraEditors.LabelControl();        this.lblContent = new DevExpress.XtraEditors.LabelControl();        this.progressShow = new DevExpress.XtraEditors.ProgressBarControl();        this.panelControl2 = new DevExpress.XtraEditors.PanelControl();        ((System.ComponentModel.ISupportInitialize)(this.panelControl1)).BeginInit();        this.panelControl1.SuspendLayout();        ((System.ComponentModel.ISupportInitialize)(this.progressShow.Properties)).BeginInit();        ((System.ComponentModel.ISupportInitialize)(this.panelControl2)).BeginInit();        this.panelControl2.SuspendLayout();        this.SuspendLayout();        //         // panelControl1        //         this.panelControl1.BorderStyle = DevExpress.XtraEditors.Controls.BorderStyles.Style3D;        this.panelControl1.Controls.Add(this.lblCaption);        this.panelControl1.Dock = System.Windows.Forms.DockStyle.Top;        this.panelControl1.Location = new System.Drawing.Point(0, 0);        this.panelControl1.Name = &quot;panelControl1&quot;;        this.panelControl1.Size = new System.Drawing.Size(436, 34);        this.panelControl1.TabIndex = 0;        //         // lblCaption        //         this.lblCaption.Location = new System.Drawing.Point(5, 9);        this.lblCaption.Name = &quot;lblCaption&quot;;        this.lblCaption.Size = new System.Drawing.Size(41, 14);        this.lblCaption.TabIndex = 0;        this.lblCaption.Text = &quot;Caption&quot;;        //         // lblMessage        //         this.lblMessage.Location = new System.Drawing.Point(24, 7);        this.lblMessage.Name = &quot;lblMessage&quot;;        this.lblMessage.Size = new System.Drawing.Size(46, 14);        this.lblMessage.TabIndex = 2;        this.lblMessage.Text = &quot;Message&quot;;        //         // lblContent        //         this.lblContent.Location = new System.Drawing.Point(24, 31);        this.lblContent.Name = &quot;lblContent&quot;;        this.lblContent.Size = new System.Drawing.Size(45, 14);        this.lblContent.TabIndex = 3;        this.lblContent.Text = &quot;Content&quot;;        //         // progressShow        //         this.progressShow.EditValue = 1;        this.progressShow.Location = new System.Drawing.Point(24, 59);        this.progressShow.Name = &quot;progressShow&quot;;        this.progressShow.Properties.Appearance.BackColor = System.Drawing.Color.Transparent;        this.progressShow.Properties.Appearance.ForeColor = System.Drawing.Color.Black;        this.progressShow.Properties.EndColor = System.Drawing.Color.Empty;        this.progressShow.Properties.LookAndFeel.SkinName = &quot;Blue&quot;;        this.progressShow.Properties.LookAndFeel.UseDefaultLookAndFeel = false;        this.progressShow.Properties.LookAndFeel.UseWindowsXPTheme = true;        this.progressShow.Properties.ReadOnly = true;        this.progressShow.Properties.ShowTitle = true;        this.progressShow.Properties.StartColor = System.Drawing.Color.Empty;        this.progressShow.Properties.Step = 1;        this.progressShow.Size = new System.Drawing.Size(400, 15);        this.progressShow.TabIndex = 4;        //         // panelControl2        //         this.panelControl2.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)         | System.Windows.Forms.AnchorStyles.Left)         | System.Windows.Forms.AnchorStyles.Right)));        this.panelControl2.Controls.Add(this.lblContent);        this.panelControl2.Controls.Add(this.progressShow);        this.panelControl2.Controls.Add(this.lblMessage);        this.panelControl2.Location = new System.Drawing.Point(0, 38);        this.panelControl2.Name = &quot;panelControl2&quot;;        this.panelControl2.Size = new System.Drawing.Size(436, 83);        this.panelControl2.TabIndex = 5;        //         // ShowDialogForm        //         this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 14F);        this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;        this.ClientSize = new System.Drawing.Size(436, 124);        this.Controls.Add(this.panelControl2);        this.Controls.Add(this.panelControl1);        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;        this.MaximizeBox = false;        this.MinimizeBox = false;        this.Name = &quot;ShowDialogForm&quot;;        this.ShowIcon = false;        this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;        this.Text = &quot;ShowDialogForm&quot;;        ((System.ComponentModel.ISupportInitialize)(this.panelControl1)).EndInit();        this.panelControl1.ResumeLayout(false);        this.panelControl1.PerformLayout();        ((System.ComponentModel.ISupportInitialize)(this.progressShow.Properties)).EndInit();        ((System.ComponentModel.ISupportInitialize)(this.panelControl2)).EndInit();        this.panelControl2.ResumeLayout(false);        this.panelControl2.PerformLayout();        this.ResumeLayout(false);    }    #endregion    private DevExpress.XtraEditors.PanelControl panelControl1;    private DevExpress.XtraEditors.LabelControl lblCaption;    private DevExpress.XtraEditors.LabelControl lblMessage;    private DevExpress.XtraEditors.LabelControl lblContent;    private DevExpress.XtraEditors.ProgressBarControl progressShow;    private DevExpress.XtraEditors.PanelControl panelControl2;}}</code></pre><p>3.ShowDialogForm.resx文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt;  &lt;!-- Microsoft ResX Schema Version 2.0The primary goals of this format is to allow a simple XML format that is mostly human readable. The generation and parsing of the various data types are done through the TypeConverter classes associated with the data types.Example:... ado.net/XML headers &amp; schema ...&lt;resheader name=&quot;resmimetype&quot;&gt;text/microsoft-resx&lt;/resheader&gt;&lt;resheader name=&quot;version&quot;&gt;2.0&lt;/resheader&gt;&lt;resheader name=&quot;reader&quot;&gt;System.Resources.ResXResourceReader, System.Windows.Forms, ...&lt;/resheader&gt;&lt;resheader name=&quot;writer&quot;&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, ...&lt;/resheader&gt;&lt;data name=&quot;Name1&quot;&gt;&lt;value&gt;this is my long string&lt;/value&gt;&lt;comment&gt;this is a comment&lt;/comment&gt;&lt;/data&gt;&lt;data name=&quot;Color1&quot; type=&quot;System.Drawing.Color, System.Drawing&quot;&gt;Blue&lt;/data&gt;&lt;data name=&quot;Bitmap1&quot; mimetype=&quot;application/x-microsoft.net.object.binary.base64&quot;&gt;    &lt;value&gt;[base64 mime encoded serialized .NET Framework object]&lt;/value&gt;&lt;/data&gt;&lt;data name=&quot;Icon1&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;    &lt;value&gt;[base64 mime encoded string representing a byte array form of the .NET Framework object]&lt;/value&gt;    &lt;comment&gt;This is a comment&lt;/comment&gt;&lt;/data&gt;There are any number of &quot;resheader&quot; rows that contain simple name/value pairs.Each data row contains a name, and value. The row also contains a type or mimetype. Type corresponds to a .NET class that support text/value conversion through the TypeConverter architecture. Classes that don&apos;t support this are serialized and stored with the mimetype set.The mimetype is used for serialized objects, and tells the ResXResourceReader how to depersist the object. This is currently not extensible. For a given mimetype the value must be set accordingly:Note - application/x-microsoft.net.object.binary.base64 is the format that the ResXResourceWriter will generate, however the reader can read any of the formats listed below.mimetype: application/x-microsoft.net.object.binary.base64value   : The object must be serialized with         : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter        : and then encoded with base64 encoding.mimetype: application/x-microsoft.net.object.soap.base64value   : The object must be serialized with         : System.Runtime.Serialization.Formatters.Soap.SoapFormatter        : and then encoded with base64 encoding.mimetype: application/x-microsoft.net.object.bytearray.base64value   : The object must be serialized into a byte array         : using a System.ComponentModel.TypeConverter        : and then encoded with base64 encoding.--&gt;  &lt;xsd:schema id=&quot;root&quot; xmlns=&quot;&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;&gt;&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; /&gt;&lt;xsd:element name=&quot;root&quot; msdata:IsDataSet=&quot;true&quot;&gt;  &lt;xsd:complexType&gt;    &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt;      &lt;xsd:element name=&quot;metadata&quot;&gt;        &lt;xsd:complexType&gt;          &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; /&gt;          &lt;/xsd:sequence&gt;          &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot; /&gt;          &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; /&gt;          &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; /&gt;          &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;      &lt;xsd:element name=&quot;assembly&quot;&gt;        &lt;xsd:complexType&gt;          &lt;xsd:attribute name=&quot;alias&quot; type=&quot;xsd:string&quot; /&gt;          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; /&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;      &lt;xsd:element name=&quot;data&quot;&gt;        &lt;xsd:complexType&gt;          &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;            &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;2&quot; /&gt;          &lt;/xsd:sequence&gt;          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; msdata:Ordinal=&quot;1&quot; /&gt;          &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;3&quot; /&gt;          &lt;xsd:attribute name=&quot;mimetype&quot; type=&quot;xsd:string&quot; msdata:Ordinal=&quot;4&quot; /&gt;          &lt;xsd:attribute ref=&quot;xml:space&quot; /&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;      &lt;xsd:element name=&quot;resheader&quot;&gt;        &lt;xsd:complexType&gt;          &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;value&quot; type=&quot;xsd:string&quot; minOccurs=&quot;0&quot; msdata:Ordinal=&quot;1&quot; /&gt;          &lt;/xsd:sequence&gt;          &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:string&quot; use=&quot;required&quot; /&gt;        &lt;/xsd:complexType&gt;      &lt;/xsd:element&gt;    &lt;/xsd:choice&gt;  &lt;/xsd:complexType&gt;&lt;/xsd:element&gt;  &lt;/xsd:schema&gt;  &lt;resheader name=&quot;resmimetype&quot;&gt;&lt;value&gt;text/microsoft-resx&lt;/value&gt;  &lt;/resheader&gt;  &lt;resheader name=&quot;version&quot;&gt;&lt;value&gt;2.0&lt;/value&gt;  &lt;/resheader&gt;  &lt;resheader name=&quot;reader&quot;&gt;&lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;  &lt;/resheader&gt;  &lt;resheader name=&quot;writer&quot;&gt;&lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;  &lt;/resheader&gt;&lt;/root&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Devexpress默认的等待提示框&quot;&gt;&lt;a href=&quot;#一、Devexpress默认的等待提示框&quot; class=&quot;headerlink&quot; title=&quot;一、Devexpress默认的等待提示框&quot;&gt;&lt;/a&gt;一、Devexpress默认的等待提示框&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSP遍历两个集合的情况</title>
    <link href="https://wanglinyong.github.io/2017/12/05/jsp%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E6%83%85%E5%86%B5/"/>
    <id>https://wanglinyong.github.io/2017/12/05/jsp遍历两个集合情况/</id>
    <published>2017-12-05T11:36:06.000Z</published>
    <updated>2017-12-05T09:23:03.216Z</updated>
    
    <content type="html"><![CDATA[<p>比如后台系统传递两个集合:</p><pre><code>model.addAttribute(&quot;list&quot;,list);model.addAttribute(&quot;numbers&quot;,numbers);</code></pre><p>前台系统:</p><p>1.首先引入标签库</p><pre><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;  </code></pre><p>2.编写js代码</p><pre><code>&lt;c:forEach var=&quot;item&quot; items=&quot;${list.list }&quot; varStatus=&quot;s&quot;&gt;        &lt;tr target=&quot;item_id&quot; rel=&quot;${item.id}&quot;&gt;            &lt;td&gt;${item.name }&lt;/td&gt;            &lt;td&gt;${numbers[s.count-1].name}&lt;/td&gt;            &lt;td&gt;${item.area }&lt;/td&gt;            &lt;td&gt;${item.moduleName }&lt;/td&gt;            &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.rptTime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;&lt;/td&gt;                   &lt;/tr&gt;&lt;/c:forEach&gt;</code></pre><p>说明：</p><pre><code>&lt;td&gt;${numbers[s.count-1].name}&lt;/td&gt;其中name是numbers集合存储的对象类型的属性，如果numbers集合存储的是String，可以直接使用&lt;td&gt;${numbers[s.count-1]}&lt;/td&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比如后台系统传递两个集合:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;model.addAttribute(&amp;quot;list&amp;quot;,list);
model.addAttribute(&amp;quot;numbers&amp;quot;,numbers);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统各服务相关设置</title>
    <link href="https://wanglinyong.github.io/2017/11/26/linux%E7%B3%BB%E7%BB%9F%E5%90%84%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"/>
    <id>https://wanglinyong.github.io/2017/11/26/linux系统各服务相关设置/</id>
    <published>2017-11-26T12:36:06.000Z</published>
    <updated>2018-03-25T02:10:19.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、配置JDK环境变量"><a href="#一、配置JDK环境变量" class="headerlink" title="一、配置JDK环境变量"></a>一、配置JDK环境变量</h1><pre><code>#vi /etc/profile</code></pre><p>在该profile文件中最下面添加：</p><pre><code>export JAVA_HOME=/root/softs/jdk1.8.0_77export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin添加完毕保存退出</code></pre><p>友情提示：</p><p>1.使用G 使光标跳到最后一行（区分大小写）</p><p>2.gg可以使光标回到首行（区分大小写）</p><pre><code>source /etc/profile 使配置的环境变量立即生效</code></pre><p>检测是否安装成功</p><p>1.查看版本</p><pre><code># java-version</code></pre><p>java version “1.7.0”</p><p>Java(TM) SE Runtime Environment (build 1.7.0-b147)</p><p>Java HotSpot(TM) Client VM (build 21.0-b17, mixed mode, sharing)</p><p>2.查看JAVA_HOME路径</p><pre><code># echo $JAVA_HOME</code></pre><p>/usr/java/jdk1.7.0</p><p>出现以上提示说明配置成功！</p><h1 id="二、防火墙设置"><a href="#二、防火墙设置" class="headerlink" title="二、防火墙设置"></a>二、防火墙设置</h1><p>1.要开放的端口如下：</p><p>61616/tcp —activemq端口</p><p>80/tcp —可以省略的端口，网站常用端口</p><p>6080/tcp—程序中使用的TCP端口 </p><p>6080/udp —程序中使用的UDP端口 </p><p>8080/tcp —tomcat默认端口</p><p>3306/tcp—mysql默认端口</p><p>2.查看已经开放的端口：</p><pre><code>firewall-cmd --list-ports</code></pre><p>3.开启端口：</p><pre><code>firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --zone=public --add-port=6080/udp --permanentfirewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --zone=public --add-port=6080/tcp --permanentfirewall-cmd --zone=public --add-port=61616/tcp --permanent</code></pre><p>4.重启防火墙：</p><pre><code>firewall-cmd --reload </code></pre><p>5.再次查看已经开放的端口：</p><pre><code>firewall-cmd --list-ports</code></pre><p>结果如下：</p><pre><code>61616/tcp 80/tcp 6080/tcp 6080/udp 8080/tcp 3306/tcp</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>1.开启端口命令含义：</p><p>–zone #作用域</p><p>–add-port=80/tcp #添加端口，格式为：端口/通讯协议</p><p>–permanent #永久生效，没有此参数重启后失效</p><p>2.firewall重启、停止、禁止命令</p><pre><code>firewall-cmd --reload #重启firewallsystemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动</code></pre><p>3.CentOS 7 以下版本 iptables 命令</p><p>如要开放80，22，8080 端口，输入以下命令即可</p><pre><code>/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPTsbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><p>然后保存：</p><pre><code>/etc/rc.d/init.d/iptables save</code></pre><p>查看打开的端口：</p><pre><code>/etc/init.d/iptables status</code></pre><p>关闭防火墙 </p><p>1） 永久性生效，重启后不会复原</p><pre><code>开启： chkconfig iptables on关闭： chkconfig iptables off</code></pre><p>2） 即时生效，重启后复原</p><pre><code>开启： service iptables start关闭： service iptables stop</code></pre><h1 id="三、Tomcat开机自启动配置"><a href="#三、Tomcat开机自启动配置" class="headerlink" title="三、Tomcat开机自启动配置"></a>三、Tomcat开机自启动配置</h1><p>1.vi编辑rc.local文件</p><pre><code>vi /etc/rc.d/rc.local </code></pre><p>在文件最后加上下面俩行脚本。</p><pre><code>export JAVA_HOME=/root/softs/jdk1.8.0_77  /root/softs/apache-tomcat-8.0.39/bin/startup.sh start</code></pre><p>JAVA_HOME 是jdk的安装路径</p><p>/root/softs/apache-tomcat-8.0.39  是tomcat的安装目录</p><p>2、修改rc.local文件为可执行:</p><pre><code>chmod +x rc.local</code></pre><p>3、重启linux：</p><pre><code>shutdown -r now</code></pre><p>4、可以配置内存等相关设置。</p><p>Linux下修改JVM内存大小：</p><p>要添加在tomcat 的bin 下catalina.sh 里，位置cygwin=false前 。注意引号要带上,第二行为新添加的.</p><pre><code># OS specific support. $var _must_ be set to either true or false.export JAVA_OPTS=&quot;-Xms512m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=256m&quot;cygwin=false</code></pre><h1 id="四、ActiveMQ开机自启动配置"><a href="#四、ActiveMQ开机自启动配置" class="headerlink" title="四、ActiveMQ开机自启动配置"></a>四、ActiveMQ开机自启动配置</h1><p>1、在root权限下操作</p><p>2、拷贝activemq文件到/etc/init.d下</p><pre><code>cp /root/softs/apache-activemq-5.13.2/bin/activemq /etc/init.d</code></pre><p>3、进入/etc/init.d目录</p><pre><code>cd /etc/init.d/</code></pre><p>4、编辑activemq</p><pre><code>vi activemq</code></pre><p>5、在#!/bin/sh后添加</p><pre><code>#!/bin/sh### BEGIN INIT INFO# chkconfig: 345 63 37# description: Auto start ActiveMQ# Provides:          activemq# Required-Start:    $remote_fs $network $syslog# Required-Stop:     $remote_fs $network $syslog# Default-Start:     3 5# Default-Stop:      0 1 6# Short-Description: Starts ActiveMQ# Description:       Starts ActiveMQ Message Broker Server### END INIT INFO</code></pre><p>在最后一个#后面添加</p><pre><code>export JAVA_HOME=/root/softs/jdk1.8.0_77ACTIVEMQ_HOME=/root/softs/apache-activemq-5.13.2</code></pre><p>如下图(路径改为自己的)：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/mqc.png" alt=""></p><p>7、修改权限</p><pre><code>chmod +x activemq</code></pre><p>8、添加系统服务</p><pre><code>chkconfig --add activemq</code></pre><p>9、显示所有运行级系统服务的运行状态信息</p><pre><code>chkconfig --list #显示该服务则成功</code></pre><p>结果如下：</p><pre><code>activemq           0:关    1:关    2:开    3:开    4:开    5:开    6:关netconsole         0:关    1:关    2:关    3:关    4:关    5:关    6:关network            0:关    1:关    2:开    3:开    4:开    5:开    6:关rds_start          0:关    1:关    2:开    3:开    4:开    5:开    6:关redis              0:关    1:关    2:开    3:开    4:开    5:开    6:关</code></pre><p>如果想通过网页访问activemq,还需开启8161端口</p><pre><code>firewall-cmd --zone=public --add-port=8161/tcp --permanentfirewall-cmd --reload </code></pre><p>然后通过8161端口即可访问activemq网页</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/mq.png" alt=""></p><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>在Ubuntu中，有可能没有chkconfig命令或者执行失败，可以用Ubuntu的update-rc.d命令替换</p><p>问题：<br>cp 到/etc/init.d目录下的时候，有时候启动会提示找不到路径等等问题，但是在安装目录启动就可以，所以可以通过软连接来实现启动脚本：</p><pre><code>ln -s /usr/local/activemq/bin/activemq /etc/init.d/ /etc/init.d/activemq</code></pre><hr><pre><code># 第二行插入# chkconfig: 345 63 37# description: Auto start ActiveMQ</code></pre><hr><p>然后就可以添加开机启动了</p><pre><code>chkconfig activemq onchkconfig --list activemq</code></pre><p>也可以正常用服务的命令启动和停止</p><pre><code>service activemq startservice activemq statusservice activemq stop</code></pre><h1 id="五、Redis开机自启动配置"><a href="#五、Redis开机自启动配置" class="headerlink" title="五、Redis开机自启动配置"></a>五、Redis开机自启动配置</h1><p>1、设置redis.conf中daemonize为yes,确保守护进程开启。此步骤可让redis后台运行</p><pre><code>vi /root/softs/redis-3.2.5/redis.conf </code></pre><p>友情提示：</p><p>(1)使用下面命令可查找redis.conf文件的位置</p><pre><code>find / -name redis.conf</code></pre><p>(2)在vi编辑页面输入下面命令可查找单词位置，用 n 或shift n 寻找上一个或下一个</p><pre><code>/daemonize </code></pre><p>(3)在vi编辑页面 输入下面命令显示所有匹配daemonize的行</p><pre><code>:g/daemonize/ </code></pre><p>2、编写开机自启动脚本</p><pre><code>vi /etc/init.d/redis</code></pre><p>脚本内容如下：</p><pre><code># chkconfig: 2345 10 90  # description: Start and Stop redis   PATH=/usr/local/bin:/sbin:/usr/bin:/binREDISPORT=6379EXEC=/root/softs/redis-3.2.5/src/redis-server    #改为你的server路径#EXEC=/usr/local/bin/redis-serverREDIS_CLI=/root/softs/redis-3.2.5/src/redis-cli   #改为你的client路径PIDFILE=/var/run/redis.pid   CONF=&quot;/root/softs/redis-3.2.5/redis.conf&quot;       #改为你的redis.conf路径AUTH=&quot;1234&quot;  case &quot;$1&quot; in       start)               if [ -f $PIDFILE ]               then                       echo &quot;$PIDFILE exists, process is already running or crashed.&quot;              else                      echo &quot;Starting Redis server...&quot;                      $EXEC $CONF               fi               if [ &quot;$?&quot;=&quot;0&quot; ]               then                       echo &quot;Redis is running...&quot;              fi               ;;       stop)               if [ ! -f $PIDFILE ]               then                       echo &quot;$PIDFILE exists, process is not running.&quot;              else                      PID=$(cat $PIDFILE)                       echo &quot;Stopping...&quot;                     $REDIS_CLI -p $REDISPORT  SHUTDOWN                        sleep 2                     while [ -x $PIDFILE ]                      do                              echo &quot;Waiting for Redis to shutdown...&quot;                             sleep 1                      done                       echo &quot;Redis stopped&quot;              fi               ;;       restart|force-reload)               ${0} stop               ${0} start               ;;       *)              echo &quot;Usage: /etc/init.d/redis {start|stop|restart|force-reload}&quot; &gt;&amp;2              exit 1  esac    </code></pre><p>3、写完后保存退出VI</p><pre><code>:mq!</code></pre><p>4、设置权限</p><pre><code>chmod 755 redis</code></pre><p>5、启动测试</p><pre><code>/etc/init.d/redis start</code></pre><p>启动成功会提示如下信息：</p><pre><code>Starting Redis server...Redis is running...</code></pre><p>使用redis-cli测试：</p><pre><code>[root@rk ~]# /root/softs/redis-3.2.5/src/redis-cli127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo&quot;bar&quot;127.0.0.1:6379&gt; exit</code></pre><p>6、设置开机自启动</p><pre><code>chkconfig redis on</code></pre><p>7、关机重启测试</p><pre><code>reboot</code></pre><p>然后在用redis-cli测试即可。</p><h2 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h2><p>解决windows文件到linux上出现乱码问题：</p><pre><code>dos2unix *</code></pre><p>终止正在运行的程序</p><pre><code>ctrl+z可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行</code></pre><h1 id="六、MySql安装及自启动配置"><a href="#六、MySql安装及自启动配置" class="headerlink" title="六、MySql安装及自启动配置"></a>六、MySql安装及自启动配置</h1><h2 id="1-下载mysql源安装包"><a href="#1-下载mysql源安装包" class="headerlink" title="1.下载mysql源安装包"></a>1.下载mysql源安装包</h2><pre><code>wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</code></pre><p>如果没有wget命令，yum安装</p><pre><code>yum -y install wget</code></pre><h2 id="2-安装mysql源"><a href="#2-安装mysql源" class="headerlink" title="2.安装mysql源"></a>2.安装mysql源</h2><pre><code>yum localinstall mysql57-community-release-el7-8.noarch.rpm</code></pre><p>检查mysql源是否安装成功</p><pre><code>yum repolist enabled | grep &quot;mysql.*-community.*&quot;</code></pre><p>看到下图所示表示安装成功。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/mysql-1.png" alt=""></p><h2 id="3、安装MySQL"><a href="#3、安装MySQL" class="headerlink" title="3、安装MySQL"></a>3、安装MySQL</h2><pre><code>yum install mysql-community-server</code></pre><p>启动MySQL服务</p><pre><code>systemctl start mysqld</code></pre><p>查看MySQL的启动状态，如下图所示</p><pre><code>systemctl status mysqld</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/mysql-2.png" alt=""></p><h2 id="4、设置开机自启动"><a href="#4、设置开机自启动" class="headerlink" title="4、设置开机自启动"></a>4、设置开机自启动</h2><pre><code>systemctl enable mysqldsystemctl daemon-reload</code></pre><p>修改root本地登录密码,mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码</p><pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log</code></pre><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/mysql-3.png" alt=""></p><p>然后登录mysql进行修改：</p><pre><code>mysql -uroot -pmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;root&apos;; </code></pre><h2 id="注意：mysql5-7默认安装了密码安全检查插件"><a href="#注意：mysql5-7默认安装了密码安全检查插件" class="headerlink" title="注意：mysql5.7默认安装了密码安全检查插件"></a>注意：mysql5.7默认安装了密码安全检查插件</h2><p>默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示如下错误</p><pre><code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code></pre><p>修改密码策略</p><p>在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略</p><p>选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</p><pre><code>validate_password_policy=0</code></pre><p>如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：</p><pre><code>validate_password = off</code></pre><p>重新启动mysql服务使配置生效：</p><pre><code>systemctl restart mysqld</code></pre><h2 id="5、添加远程登录用户"><a href="#5、添加远程登录用户" class="headerlink" title="5、添加远程登录用户"></a>5、添加远程登录用户</h2><p>默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，添加一个新的帐户：</p><pre><code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;wanglinyong&apos;@&apos;%&apos; IDENTIFIED BY &apos;wanglinyong0617&apos; WITH GRANT OPTION;</code></pre><h2 id="6、配置默认编码为utf8"><a href="#6、配置默认编码为utf8" class="headerlink" title="6、配置默认编码为utf8"></a>6、配置默认编码为utf8</h2><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p><pre><code>[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos;</code></pre><p>重新启动mysql服务</p><pre><code>systemctl restart mysqld</code></pre><p>默认配置文件路径： </p><pre><code>配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid</code></pre><h1 id="注意"><a href="#注意" class="headerlink" title="注意!!"></a>注意!!</h1><p>如果启动项目之后访问网页总是提示某表找不到，是因为mysql表名区分了大小写</p><p>解决办法</p><pre><code>vi /etc/my.cnf</code></pre><p>加入如下配置即可</p><pre><code>[mysqld]lower_case_table_names=1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、配置JDK环境变量&quot;&gt;&lt;a href=&quot;#一、配置JDK环境变量&quot; class=&quot;headerlink&quot; title=&quot;一、配置JDK环境变量&quot;&gt;&lt;/a&gt;一、配置JDK环境变量&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;#vi /etc/profile
&lt;/code&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux下安装nginx及开机自启动</title>
    <link href="https://wanglinyong.github.io/2017/11/26/linux%E4%B8%8B%E5%AE%89%E8%A3%85nginx%E5%8F%8A%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://wanglinyong.github.io/2017/11/26/linux下安装nginx及开机自启动/</id>
    <published>2017-11-26T12:36:06.000Z</published>
    <updated>2018-01-05T12:41:20.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装nginx"><a href="#一、安装nginx" class="headerlink" title="一、安装nginx"></a>一、安装nginx</h1><p>1.从<a href="http://nginx.org/download/上下载相应的版本(或者wget" target="_blank" rel="external">http://nginx.org/download/上下载相应的版本(或者wget</a> <a href="http://nginx.org/download/nginx-1.5.9.tar.gz直接在Linux上用命令下载" target="_blank" rel="external">http://nginx.org/download/nginx-1.5.9.tar.gz直接在Linux上用命令下载</a>)</p><pre><code>wget http://nginx.org/download/nginx-1.5.9.tar.gz</code></pre><p>2.解压 </p><pre><code>tar -zxvf nginx-1.5.9.tar.gz </code></pre><p>3.设置一下配置信息，或者不执行此步，直接默认配置，与后面配置有关</p><pre><code>./configure --prefix=/usr/local/nginx </code></pre><p>4.make 编译 （make的过程是把各种语言写的源码文件，变成可执行文件和各种库文件）</p><pre><code>make</code></pre><p>5.make install 安装 （make install是把这些编译出来的可执行文件和库文件复制到合适的地方）</p><pre><code>make install</code></pre><p>6.启动nginx</p><pre><code>/usr/local/nginx/sbin/nginx</code></pre><p>7.访问nginx，nginx默认端口为80</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/nginx.png" alt=""></p><p>8.安装过程中可能会遇到的错误</p><p>（1）错误为：./configure: error: the HTTP rewrite module requires the PCRE library.</p><p>安装pcre-devel解决问题</p><pre><code>yum -y install pcre-devel</code></pre><p>（2）错误提示：./configure: error: the HTTP cache module requires md5 functions<br>from OpenSSL library.   You can either disable the module by using<br>–without-http-cache option, or install the OpenSSL library into the system,<br>or build the OpenSSL library statically from the source with nginx by using<br>–with-http_ssl_module –with-openssl=<path></path> options.</p><p>解决办法：</p><pre><code>yum -y install openssl openssl-devel</code></pre><h1 id="二、nginx开机自启动"><a href="#二、nginx开机自启动" class="headerlink" title="二、nginx开机自启动"></a>二、nginx开机自启动</h1><p>1.在linux系统的/etc/init.d/目录下创建nginx文件</p><pre><code>vim /etc/init.d/nginx</code></pre><p>2.在脚本中添加如下命令：</p><pre><code>#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig:   - 85 15# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \#               proxy and IMAP/POP3 proxy server# processname: nginx# config:      /etc/nginx/nginx.conf# config:      /etc/sysconfig/nginx# pidfile:     /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/usr/sbin/nginx&quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/etc/nginx/nginx.conf&quot;[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() {# make required directoriesuser=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &apos;s/[^*]*--user=\([^ ]*\).*/\1/g&apos; -`if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then   useradd -M -s /bin/nologin $userfioptions=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;`for opt in $options; do   if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then       value=`echo $opt | cut -d &quot;=&quot; -f 2`       if [ ! -d &quot;$value&quot; ]; then           # echo &quot;creating&quot; $value           mkdir -p $value &amp;&amp; chown -R $user $value       fi   fidone}start() {[ -x $nginx ] || exit 5[ -f $NGINX_CONF_FILE ] || exit 6make_dirsecho -n $&quot;Starting $prog: &quot;daemon $nginx -c $NGINX_CONF_FILEretval=$?echo[ $retval -eq 0 ] &amp;&amp; touch $lockfilereturn $retval}stop() {echo -n $&quot;Stopping $prog: &quot;killproc $prog -QUITretval=$?echo[ $retval -eq 0 ] &amp;&amp; rm -f $lockfilereturn $retval}restart() {configtest || return $?stopsleep 1start}reload() {configtest || return $?echo -n $&quot;Reloading $prog: &quot;killproc $nginx -HUPRETVAL=$?echo}force_reload() {restart}configtest() {$nginx -t -c $NGINX_CONF_FILE}rh_status() {status $prog}rh_status_q() {rh_status &gt;/dev/null 2&gt;&amp;1}case &quot;$1&quot; instart)    rh_status_q &amp;&amp; exit 0    $1    ;;stop)    rh_status_q || exit 0    $1    ;;restart|configtest)    $1    ;;reload)    rh_status_q || exit 7    $1    ;;force-reload)    force_reload    ;;status)    rh_status    ;;condrestart|try-restart)    rh_status_q || exit 0        ;; *)    echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;    exit 2esac</code></pre><p>3.如果你是自定义编译安装的nginx，需要根据您的安装路径修改下面这两项配置：</p><pre><code>nginx=&quot;/usr/local/nginx/sbin/nginx&quot; 修改成nginx执行程序的路径。NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot; 修改成配置文件的路径。</code></pre><p>4.保存脚本文件后设置文件的执行权限：</p><pre><code>chmod a+x /etc/init.d/nginx</code></pre><p>5.通过该脚本启动停止nginx服务</p><pre><code>/etc/init.d/nginx start/etc/init.d/nginx stop</code></pre><p>6.使用chkconfig进行管理，将nginx服务加入chkconfig管理列表</p><pre><code>chkconfig --add /etc/init.d/nginx</code></pre><p>7.使用service对nginx进行启动，停止。重启等操作</p><pre><code>service nginx startservice nginx stop</code></pre><p>8.设置终端模式开机启动</p><pre><code>chkconfig nginx on</code></pre><h1 id="三、发布静态资源"><a href="#三、发布静态资源" class="headerlink" title="三、发布静态资源"></a>三、发布静态资源</h1><p>1.确定静态资源存放位置</p><pre><code>/home/images</code></pre><p>2.修改nginx.conf配置文件</p><pre><code>vi /usr/local/nginx/conf/nginx.conf</code></pre><p>3.主要修改如下：</p><pre><code>#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {worker_connections  1024;}http {include       mime.types;default_type  application/octet-stream;#log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;#                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;#                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;#access_log  logs/access.log  main;sendfile        on;#tcp_nopush     on;#keepalive_timeout  0;keepalive_timeout  65;#gzip  on;server {    listen       80;    server_name  localhost;    #charset koi8-r;     charset utf-8;        #access_log  logs/host.access.log  main;     location ~ .*\.(gif|jpg|jpeg|png)$ {        expires 24h;            root /home/images/;#指定图片存放路径            access_log /home/softs/nginx-1.5.9/logs/images.log;#日志存放路径            proxy_store on;            proxy_store_access user:rw group:rw all:rw;            proxy_temp_path         /home/images/;#图片访问路径            proxy_redirect          off;            proxy_set_header        Host 127.0.0.1;            client_max_body_size    10m;            client_body_buffer_size 1280k;            proxy_connect_timeout   900;            proxy_send_timeout      900;            proxy_read_timeout      900;            proxy_buffer_size       40k;            proxy_buffers           40 320k;            proxy_busy_buffers_size 640k;            proxy_temp_file_write_size 640k;            if ( !-e $request_filename)            {                 proxy_pass  http://127.0.0.1;#默认80端口            }    }          location / {        root   /home/html; #html访问路径          index  index.html index.htm;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ {    #    proxy_pass   http://127.0.0.1;    #}    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ {    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #}    # deny access to .htaccess files, if Apache&apos;s document root    # concurs with nginx&apos;s one    #    #location ~ /\.ht {    #    deny  all;    #}}# another virtual host using mix of IP-, name-, and port-based configuration##server {#    listen       8000;#    listen       somename:8080;#    server_name  somename  alias  another.alias;#    location / {#        root   html;#        index  index.html index.htm;#    }#}# HTTPS server##server {#    listen       443 ssl;#    server_name  localhost;#    ssl_certificate      cert.pem;#    ssl_certificate_key  cert.key;#    ssl_session_cache    shared:SSL:1m;#    ssl_session_timeout  5m;#    ssl_ciphers  HIGH:!aNULL:!MD5;#    ssl_prefer_server_ciphers  on;#    location / {#        root   html;#        index  index.html index.htm;#    }#}}</code></pre><p>4.查看编译是否出错，如果没出错则成功</p><pre><code>cd /usr/local/nginx/sbin/./nginx -t</code></pre><p>5.显示如下即代表成功（如果报目录不存在错误，就创建目录即可）</p><pre><code>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</code></pre><p>6.访问静态资源:192.168.120.139/1.png</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装nginx&quot;&gt;&lt;a href=&quot;#一、安装nginx&quot; class=&quot;headerlink&quot; title=&quot;一、安装nginx&quot;&gt;&lt;/a&gt;一、安装nginx&lt;/h1&gt;&lt;p&gt;1.从&lt;a href=&quot;http://nginx.org/download/上下载相
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统如何移动mysql存放文件的位置</title>
    <link href="https://wanglinyong.github.io/2017/11/22/linux%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%A7%BB%E5%8A%A8mysql%E5%AD%98%E6%94%BE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>https://wanglinyong.github.io/2017/11/22/linux系统如何移动mysql存放文件的位置/</id>
    <published>2017-11-22T10:58:06.000Z</published>
    <updated>2017-11-22T06:33:07.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看mysql情况"><a href="#查看mysql情况" class="headerlink" title="查看mysql情况"></a>查看mysql情况</h2><p>指令 ps -ef | grep mysql 得出结果</p><p>1.root     17659     1  0  2011 ?        00:00:00 /bin/sh /usr/bin/mysqld_safe –datadir=/var/lib/mysql –socket=/var/lib/mysql/mysql.sock –log-error=/var/log/mysqld.log –pid-file=/var/run/mysqld/mysqld.pid   </p><p>2.mysql    17719 17659  0  2011 ?        03:14:57 /usr/libexec/mysqld –basedir=/usr –datadir=/var/lib/mysql –user=mysql –pid-file=/var/run/mysqld/mysqld.pid –skip-external-locking –socket=/var/lib/mysql/mysql.sock  </p><p>usr/bin/mysql 是指：mysql的运行路径 </p><p>var/lib/mysql 是指：mysql数据库文件的存放路径 </p><p>usr/lib/mysql 是指：mysql的安装路径</p><h2 id="移动mysql存放文件位置"><a href="#移动mysql存放文件位置" class="headerlink" title="移动mysql存放文件位置"></a>移动mysql存放文件位置</h2><p>假如要把目录移到/home/data下需要进行下面几步：</p><p>1、home目录下建立data目录</p><pre><code>cd /homemkdir data</code></pre><p>2、把MySQL服务进程停掉：</p><pre><code>mysqladmin -u root -p shutdown</code></pre><p>3、把/var/lib/mysql整个目录移到/home/data</p><pre><code>mv /var/lib/mysql　/home/data/</code></pre><p>这样就把MySQL的数据文件移动到了/home/data/mysql下</p><p>4、找到my.cnf配置文件<br>　　如果/etc/目录下没有my.cnf配置文件，请到/usr/share/mysql/下找到*.cnf文件，拷贝其中一个到/etc/并改名为my.cnf)中。命令如下：</p><pre><code>[root@test1 mysql]# cp /usr/share/mysql/my-medium.cnf　/etc/my.cnf</code></pre><p>5、编辑MySQL的配置文件/etc/my.cnf<br>　　为保证MySQL能够正常工作，需要指明mysql.sock文件的产生位置。修改socket=/var/lib/mysql/mysql.sock一行中等号右边的值为：/home/mysql/mysql.sock 。操作如下：</p><pre><code>vi　 my.cnf　　　 (用vi工具编辑my.cnf文件，找到下列数据修改之)[mysql]（加上此行）socket=/home/data/mysql/mysql.sock（加上此行）[mysqld]#datadir=/var/lib/mysql（原内容，为了更稳妥用“#”注释此行）#socket=/var/lib/mysql/mysql.sock（原内容，为了更稳妥用“#”注释此行）datadir=/home/data/mysql（加上此行）socket=/home/data/mysql/mysql.sock（加上此行）</code></pre><p>6、修改MySQL启动脚本/etc/init.d/mysql（如果init.d目录下没有mysql文件请忽略此步骤）</p><p>　　最后，需要修改MySQL启动脚本/etc/init.d/mysql，把其中datadir=/var/lib/mysql一行中，等号右边的路径改成你现在的实际存放路径：home/data/mysql。</p><pre><code>[root@test1 etc]# vi　/etc/init.d/mysql#datadir=/var/lib/mysql　　　　（注释此行）datadir=/home/data/mysql　　 （加上此行）</code></pre><p>7、重新启动MySQL服务</p><pre><code>/etc/init.d/mysql　start</code></pre><p>或用reboot命令重启Linux<br>如果工作正常移动就成功了，否则对照前面的7步再检查一下。还要注意目录的属主和权限。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果更换mysql数据目录后出现：</p><p>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)</p><p>说明无法通过socket文件/var/lib/mysql/mysql.sock连接到mysql服务器，也就是说对于mysql程序来说，尽管把socket文件从/var/lib/mysql/mysql.sock转移到了/home/data/mysql/mysql.sock,在my.cnf里设置了，mysqld是知道了，但是对于mysql还是会从默认的安装目录/var/lib/mysql/里找这个mysql.sock文件，找不着，就不知道从哪里启动了。</p><p>解决方案一：设置软连接</p><pre><code>ln –s /home/data/mysql/mysql.sock /var/lib/mysql/</code></pre><p>做完软连接，重启mysql服务，再次通过mysql程序连接就可以连上了。</p><p>解决方案二：检查my.cnf配置，是否有如下配置，如果没有，加上</p><pre><code>[mysql]socket=/home/data/mysql/mysql.sock</code></pre><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>1.查找命令</p><pre><code>find / -name my.cnf　　#在根目录下查找文件my.cnf，表示在整个硬盘查找find /etc -name my.cnf　　#在/etc目录下文件my.cnffind /etc -name &apos;*srm*&apos;　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件find . -name &apos;srm*&apos; 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件</code></pre><p>2.查看文件占用大小</p><pre><code>du -sh /*  查看根目录下所有文件的大小du -sh /home/* 查看 home目录下所有文件的大小du -sh * 查看当前目录下所有文件的大小</code></pre><p>3.查看硬盘使用情况</p><pre><code>df -h </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看mysql情况&quot;&gt;&lt;a href=&quot;#查看mysql情况&quot; class=&quot;headerlink&quot; title=&quot;查看mysql情况&quot;&gt;&lt;/a&gt;查看mysql情况&lt;/h2&gt;&lt;p&gt;指令 ps -ef | grep mysql 得出结果&lt;/p&gt;
&lt;p&gt;1.root 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python-十六进制数据传递与接收</title>
    <link href="https://wanglinyong.github.io/2017/11/17/python-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8E%A5%E6%94%B6/"/>
    <id>https://wanglinyong.github.io/2017/11/17/python-十六进制数据传递与接收/</id>
    <published>2017-11-17T12:58:06.000Z</published>
    <updated>2017-11-19T06:52:09.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h1><p>python客户端与服务端（c程序）进行通讯，需接收服务端发来的16进制码流，并对16进制数据进行解码，得到相应字段的数据，并可以将数据打包成对应格式的码流发送给服务端，多字节整数传输采用网络字节序。</p><h2 id="1-1-网络字节序"><a href="#1-1-网络字节序" class="headerlink" title="1.1 网络字节序"></a>1.1 网络字节序</h2><p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian（大端）排序方式。</p><p>为了同c中的结构体交换数据，还要考虑c或c++编译器使用了字节对齐，通常是以4个字节为单位的32位系统，故而struct根据本地机器字节顺序转换.可以用格式中的第一个字符来改变对齐方式.定义如下</p><pre><code>Character      Byte order          Size               Alignment@(默认)            本机              本机              本机,凑够4字节=                 本机                标准              none,按原字节数&lt;                 小端                标准              none,按原字节数&gt;                 大端                标准              none,按原字节数!              network(大端)         标准              none,按原字节数</code></pre><h2 id="1-2-python-struct的模块"><a href="#1-2-python-struct的模块" class="headerlink" title="1.2 python struct的模块"></a>1.2 python struct的模块</h2><p>作用：按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;<br>按照指定格式将字节流转换为Python指定的数据类型;<br>处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文件;<br>处理c语言中的结构体;</p><p>struct中两个重要的函数：</p><p>（1）pack(fmt,v1,v2…)：打包函数    </p><p>返回值类型：string    </p><p>按照给定的格式(fmt),把数据转换成字符串(字节流),并将该字符串返回.</p><p>（2）unpack(fmt,v1,v2…..)：解包函数</p><p>返回值类型：tuple</p><p>按照给定的格式(fmt)解析字节流,并返回解析结果</p><h2 id="2-消息发送的格式"><a href="#2-消息发送的格式" class="headerlink" title="2.消息发送的格式"></a>2.消息发送的格式</h2><p>消息采用消息头+消息体格式。</p><pre><code>UINT8         1字节            8位无符号整形      UINT16        2字节            16位无符号整形         UINT32        4字节            32位无符号整形UINT64        8字节            64位无符号整形</code></pre><p>1.消息头</p><pre><code>字段                  类型                  说明消息编号            UINT8                    -保留                  UINT8                用0填充消息体长度           UINT16      不包括消息头的长度，范围：0 -- 65535</code></pre><p>1.1消息编号</p><pre><code>编号            消息                    用途                     说明0xe1     W_HEARTBEAT               心跳消息                消息体长度为00xq1      QUERY_SM                  查询SM请求            消息体长度为00xq2     QUERYSM_RPT             查询SM数据上报        0xs1     SCAN_PL                    扫描PL请求            消息体长度为00xs2     SCANPL_ACK                扫描PL请求应答</code></pre><p>1.2消息体格式 </p><p>（1）心跳消息(W_HEARTBEAT)     每30秒发送一次，无消息体</p><p>（2）QUERY_SM       查询SM数据请求   无消息体</p><p>（3）QUERYSM_RPT     查询SM数据应答    消息体长度为27</p><pre><code>  字段           长度      类型           说明reserved         6         CHAR            ——strName            16         CHAR           字符串RS                 4         INT32           信号强度(-140～-44dBm)                                              0：RS值无效Rs_si           1              BYTE            0:SI                                               1:RS</code></pre><p>（4）SCAN_PL     扫描PL请求   消息体长度为0</p><p>（5）SCANPL_ACK   扫描PL请求应答</p><pre><code> 字段                长度      类型           说明reserved         4         UINT32            ——result             2         UINT16           0:成功，1：失败count             2         UINT16           info数量info            13 * 10     info[10]     最多10个info列表</code></pre><p>5-1） info消息体</p><pre><code>字段                长度          类型             说明ID                     4            UINT32              ID值Num                 6            CHAR              号码fn                 2            UINT16              fn频率power               1            UINT8              功率</code></pre><h2 id="3-代码示例如下"><a href="#3-代码示例如下" class="headerlink" title="3.代码示例如下"></a>3.代码示例如下</h2><p>3.1 发送程序（打包程序）：</p><pre><code>def th_heart():    while True:        logging.info(&apos;SEND W_HEARTBEAT&apos;)        cmd_word = 0xe1        tx_buf = struct.pack(&apos;&lt;i&apos;, cmd_word)        ModuleSocket.sendto(tx_buf, (&apos;192.168.1.209&apos;, 2843))           time.sleep(60)def send_query_sm(id):       header = 0xq1      b = 0       b_len = 0       body = struct.pack(&quot;&lt;2BH&quot;, header, b, b_len)      send_msg(id, body)def send_scan_pl(id):       header = 0xs1      b = 0       b_len = 0       body = struct.pack(&quot;&lt;2BH&quot;, header, b, b_len)      send_msg(id, body)def send_msg(id,body):         addr = (192.168.1.209,2843)    ModuleSocket.sendto(body, addr)    msg = repr(body)    logging.info(&apos;send serial %s to %s&apos; % (msg, addr))    </code></pre><p>3.2 接收程序（解包程序）：</p><pre><code> if temp.find(&apos;0xq2&apos;) &gt;=0:    logging.info(&apos;QUERYSM_RPT&apos;)    header,b,b_len,reserved,strName,RS,Rs_si = struct.unpack(&quot;&gt;2BH6s16siB&quot;, body)    strName = strName[0:-1]    logging.info(&quot;header:%s, b:%s, b_len:%s,reserved:%s, strName:%s, RS:%s, Rs_si:%s&quot; % (header, b, b_len, reserved, strName, RS, Rs_si))    sm_rpt(moduleId, strName)if temp.find(&apos;0xs2&apos;) &gt;= 0:    logging.info(&apos;SCANPL_ACK&apos;)    header, b, b_len, reserved, result, count = struct.unpack(&quot;&gt;2BHIHH&quot;, body[0:12])    ID,Num,fn,power = struct.unpack(&quot;&gt;I6sHB&quot;, body[12:25])    logging.info(&quot;reserved:%s, result:%s, count:%s&quot; %(reserved,result,count))    logging.info(&quot;ID:%s, Num:%s, fn:%s, power:%s&quot; % (ID, Num, fn, power))    pl_rpt(moduleId, ID, Num,fn,power)    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实际应用场景&quot;&gt;&lt;a href=&quot;#实际应用场景&quot; class=&quot;headerlink&quot; title=&quot;实际应用场景&quot;&gt;&lt;/a&gt;实际应用场景&lt;/h1&gt;&lt;p&gt;python客户端与服务端（c程序）进行通讯，需接收服务端发来的16进制码流，并对16进制数据进行解码，得到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA-基于TCP的Socket实现</title>
    <link href="https://wanglinyong.github.io/2017/11/05/JAVA-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84Socket%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wanglinyong.github.io/2017/11/05/JAVA-基于TCP的Socket实现/</id>
    <published>2017-11-05T07:58:06.000Z</published>
    <updated>2017-11-06T02:41:59.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、TCP中connect-、listen-和accept-三者之间的关系"><a href="#一、TCP中connect-、listen-和accept-三者之间的关系" class="headerlink" title="一、TCP中connect()、listen()和accept()三者之间的关系"></a>一、TCP中connect()、listen()和accept()三者之间的关系</h1><h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h2><p>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接（三次握手详情，请看《浅谈 TCP 三次握手》），最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。</p><p>通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）。</p><h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h2><p>对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。<br>listen() 函数的主要作用就是将套接字变成被动的连接监听套接字（被动等待客户端的连接）<br>这里需要注意的是，listen()函数不会阻塞，它主要做的事情为，将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束。</p><p>这样的话，当有一个客户端主动连接（connect()），Linux 内核就自动完成TCP 3次握手，将建立好的链接自动存储到队列中，如此重复。</p><p>所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。</p><h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h2><p>accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。</p><h1 id="二、Java为Socket编程封装了几个重要的类"><a href="#二、Java为Socket编程封装了几个重要的类" class="headerlink" title="二、Java为Socket编程封装了几个重要的类"></a>二、Java为Socket编程封装了几个重要的类</h1><h2 id="1-1-Socket类"><a href="#1-1-Socket类" class="headerlink" title="1.1 Socket类"></a>1.1 Socket类</h2><p>Socket类实现了一个客户端socket，作为两台机器通信的终端，默认采用的传输层协议为TCP，是一个可靠传输的协议。Socket类除了构造函数返回一个socket外，还提供了connect, getOutputStream, getInputStream和close方法。connect方法用于请求一个socket连接，getOutputStream用于获得写socket的输出流，getInputStream用于获得读socket的输入流，close方法用于关闭一个流。</p><p>Socket(InetAddress address, int port)<br>创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</p><p>getInetAddress() 返回套接字连接的地址。</p><p>shutdownInput()<br>此套接字的输入流置于“流的末尾”。单方向的关闭输入流，并不会关闭socket</p><p>shutdownOutput()<br>禁用此套接字的输出流。单方向的关闭输出流，并不会关闭socket</p><h2 id="1-2-DatagramSocket类"><a href="#1-2-DatagramSocket类" class="headerlink" title="1.2 DatagramSocket类"></a>1.2 DatagramSocket类</h2><p>DatagramSocket类实现了一个发送和接收数据报的socket，传输层协议使用UDP，不能保证数据报的可靠传输。DataGramSocket主要有send, receive和close三个方法。send用于发送一个数据报，Java提供了DatagramPacket对象用来表达一个数据报。receive用于接收一个数据报，调用该方法后，一直阻塞接收到直到数据报或者超时。close是关闭一个socket。</p><h2 id="1-3-ServerSocket类"><a href="#1-3-ServerSocket类" class="headerlink" title="1.3 ServerSocket类"></a>1.3 ServerSocket类</h2><p>ServerSocket类实现了一个服务器socket，一个服务器socket等待客户端网络请求，然后基于这些请求执行操作，并返回给请求者一个结果。ServerSocket提供了bind、accept和close三个方法。bind方法为ServerSocket绑定一个IP地址和端口，并开始监听该端口。accept方法为ServerSocket接受请求并返回一个Socket对象，accept方法调用后，将一直阻塞直到有请求到达。close方法关闭一个ServerSocket对象。</p><h2 id="1-4-SocketAddress"><a href="#1-4-SocketAddress" class="headerlink" title="1.4 SocketAddress"></a>1.4 SocketAddress</h2><p>SocketAddress提供了一个socket地址，不关心传输层协议。这是一个虚类，由子类来具体实现功能、绑定传输协议。它提供了一个不可变的对象，被socket用来绑定、连接或者返回数值。</p><h2 id="1-5-InetSocketAddress"><a href="#1-5-InetSocketAddress" class="headerlink" title="1.5 InetSocketAddress"></a>1.5 InetSocketAddress</h2><p>InetSocketAddress实现了IP地址的SocketAddress，也就是有IP地址和端口号表达Socket地址。如果不制定具体的IP地址和端口号，那么IP地址默认为本机地址，端口号随机选择一个。</p><h2 id="1-6-DatagramPacket"><a href="#1-6-DatagramPacket" class="headerlink" title="1.6. DatagramPacket"></a>1.6. DatagramPacket</h2><p>DatagramSocket是面向数据报socket通信的一个可选通道。数据报通道不是对网络数据报socket通信的完全抽象。socket通信的控制由DatagramSocket对象实现。DatagramPacket需要与DatagramSocket配合使用才能完成基于数据报的socket通信。</p><h1 id="三、Socket通信步骤：（简单分为4步）"><a href="#三、Socket通信步骤：（简单分为4步）" class="headerlink" title="三、Socket通信步骤：（简单分为4步）"></a>三、Socket通信步骤：（简单分为4步）</h1><p>1.建立服务端ServerSocket和客户端Socket</p><p>2.打开连接到Socket的输出输入流</p><p>3.按照协议进行读写操作</p><p>4.关闭相对应的资源</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="服务端TCPServer-java"><a href="#服务端TCPServer-java" class="headerlink" title="服务端TCPServer.java"></a>服务端TCPServer.java</h3><p>1.创建ServerSocket对象，绑定并监听端口</p><p>2.通过accept监听客户端的请求</p><p>3.建立连接后，通过输出输入流进行读写操作</p><p>4.关闭相关资源</p><p>import java.io.*;<br>import java.net.ServerSocket;<br>import java.net.Socket;</p><p>public class TCPServer {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code>/** * Socket服务端 * @param args */public static void main(String[] args) {    try  {        ServerSocket server = new ServerSocket( 9999 );        System.out.println(&quot;服务器已启动，等待客户端连接...&quot;);        Socket client = server.accept();//侦听客户端 并接收到此套接字的连接  返回一个Socket对象        //根据输入输出流和客户端连接        InputStream in =  client.getInputStream();//得到一个输入流，接收客户端传递的信息        BufferedReader inRead = new BufferedReader( new InputStreamReader( in ) );//提高效率 将自己字节流转化为字符流并加入缓冲区        String temp = null;        String info = &quot;&quot;;        while ((temp = inRead.readLine())!=null){            info += temp;            System.out.println(&quot;已接收到客户端连接&quot;);            System.out.println(&quot;服务端接收到的客户端信息：&quot;+info+&quot;,当前客户端ip为:&quot;+client.getInetAddress().getHostAddress());            System.out.printf( &quot;InetAddress&quot;+client.getInetAddress() );        }        OutputStream out = client.getOutputStream();//获取一个输出流，向客户端发送信息        PrintWriter outWriter = new PrintWriter( out );//将输出流包装成打印流        outWriter.println( &quot;你好,服务端已接收到您的信息&quot; );        outWriter.flush();        client.shutdownOutput();//关闭输出流        //关闭相对应的资源        outWriter.close();        out.close();        inRead.close();        in.close();        client.close();    }catch (Exception e){       e.printStackTrace();    }}</code></pre><p>}</p><h3 id="客户端TCPClient-java"><a href="#客户端TCPClient-java" class="headerlink" title="客户端TCPClient.java"></a>客户端TCPClient.java</h3><p>1.创建Socket对象，指定服务端的地址和端口号</p><p>2.建立连接后，通过输出输入流进行读写操作</p><p>3.通过输出输入流获取服务器返回信息</p><p>4.关闭相关资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.SocketAddress;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code>/** * Socket客户端 * @param args */public static void main(String[] args) {    try {        //创建Socket对象        Socket client = new Socket( &quot;127.0.0.1&quot;, 9999 );        //根据输入输出流和服务端连接        OutputStream outputStream = client.getOutputStream();//获取一个输出流，向服务端发送信息        PrintWriter outWriter = new PrintWriter( outputStream );//将输出流包装成打印流        outWriter.print( &quot;服务器端你好，我是Wang&quot; );        outWriter.flush();        client.shutdownOutput();//关闭输出流        InputStream inputStream = client.getInputStream();//获取一个输入流，接收服务端的信息        BufferedReader inRead = new BufferedReader( new InputStreamReader( inputStream ) );//包装成字符流并加入缓冲区，提高效率        String info = &quot;&quot;;        String temp =  null;//临时变量        while ((temp = inRead.readLine())!=null){            info += temp;            System.out.println(&quot;客户端接收到服务端发送的信息：&quot;+info);        }        //关闭相对应的资源        inRead.close();        inputStream.close();        outWriter.close();        outputStream.close();        client.close();    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>}</p><font color="#A52A2A"><br>以上代码实现了单客户端和服务端的连接，若要实现多客户端操作，需要涉及到多线程，只要你把每个接收到的Socket对象单独开一条线程操作，然后用一个死循环while(true)去监听端口就行，示例代码如下：<br></font><h3 id="线程操作类：SocketThread-java"><a href="#线程操作类：SocketThread-java" class="headerlink" title="线程操作类：SocketThread.java"></a>线程操作类：SocketThread.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div></pre></td></tr></table></figure><pre><code>/** * Socket多线程处理类 用来处理服务端接收到的客户端请求（处理Socket对象） */private Socket socket;public SocketThread(Socket socket) {    this.socket = socket;}public void run(){    //根据输入输出流和客户端连接    try {        InputStream inputStream = socket.getInputStream();//获取一个输入流，接收客户端传递的信息        //将字节流转为字符流并加入缓冲区，提高效率        BufferedReader inReader = new BufferedReader( new InputStreamReader( inputStream ) );        String temp = null;        String info = &quot;&quot;;        while ((temp = inReader.readLine())!=null){            info += temp;            System.out.println(&quot;已接收到客户端连接&quot;);            System.out.println(&quot;服务端接收到的客户端信息：&quot;+info+&quot;,当前客户端Ip为：&quot;+socket.getInetAddress().getHostAddress());        }        OutputStream outputStream = socket.getOutputStream();//获取一个输出流，向服务端发送信息        PrintWriter outWriter = new PrintWriter( outputStream );//将输出流包装成打印流        outWriter.print( &quot;你好，服务端已接收到您的信息&quot; );        outWriter.flush();        //关闭服务端的输出流，单方向的关闭流；        socket.shutdownOutput();//关闭输出流        //直接关闭输入或者输出流，会直接关闭socket        inReader.close();        inputStream.close();        outWriter.close();        outputStream.close();    }catch (Exception e){        e.printStackTrace();    }}</code></pre><p>}</p><h3 id="服务端类：Server-java"><a href="#服务端类：Server-java" class="headerlink" title="服务端类：Server.java"></a>服务端类：Server.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">Server</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code>/** * Socket服务端 */public static void main(String[] args) {    try {        ServerSocket serverSocket = new ServerSocket( 8888 );        System.out.println(&quot;服务端已启动，等待客户端连接...&quot;);        while (true){            Socket socket = serverSocket.accept();//侦听并接收到此套接字的连接，返回一个Socket对象            SocketThread socketThread = new SocketThread( socket );            socketThread.start();        }    }catch (Exception e){        e.printStackTrace();    }}</code></pre><p>}</p><h3 id="客户端类-Client-java"><a href="#客户端类-Client-java" class="headerlink" title="客户端类:Client.java"></a>客户端类:Client.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.net.Socket;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">class</span> <span class="title">Client</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code>/** * Socket客户端 */public static void main(String[] args) {   try {       Socket socket = new Socket( &quot;localhost&quot;, 8888 );//创建Socket对象       //根据输入输出流和服务端连接       OutputStream outputStream = socket.getOutputStream();//获取一个输出流 向服务端发送信息       PrintWriter outWriter = new PrintWriter( outputStream );//将输出流包装成打印流       outWriter.print( &quot;服务器你好，我是客户端1&quot; );       outWriter.flush();       socket.shutdownOutput();//关闭输出流       InputStream inputStream = socket.getInputStream();//获取一个输入流，接收服务端的信息       InputStreamReader inputStreamReader = new InputStreamReader( inputStream );//包装成字符流，提高效率       BufferedReader inReader = new BufferedReader( inputStreamReader );//缓冲区       String info = &quot;&quot;;       String temp = null;       while ((temp=inReader.readLine())!=null){           info += temp;           System.out.println(&quot;客户端接收服务端发送的信息：&quot;+info);       }       //关闭相应的资源       inReader.close();       inputStream.close();       outWriter.close();       outputStream.close();       socket.close();   }catch (Exception e){       e.printStackTrace();   }}</code></pre><p>}</p><font color="#A52A2A"><br>在实际开发中，基于Socket编程，一般传递的并非字符串，很多情况下是对象，让对象实现序列化接口Serializable，依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）进行序列化和反序列化。<br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、TCP中connect-、listen-和accept-三者之间的关系&quot;&gt;&lt;a href=&quot;#一、TCP中connect-、listen-和accept-三者之间的关系&quot; class=&quot;headerlink&quot; title=&quot;一、TCP中connect()、li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA-基于UDP的Socket实现</title>
    <link href="https://wanglinyong.github.io/2017/11/05/JAVA-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84Socket%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wanglinyong.github.io/2017/11/05/JAVA-基于UDP的Socket实现/</id>
    <published>2017-11-05T07:58:06.000Z</published>
    <updated>2017-11-16T12:52:37.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP（User-Data-Protocol，用户数据报协议）"><a href="#UDP（User-Data-Protocol，用户数据报协议）" class="headerlink" title="UDP（User Data Protocol，用户数据报协议）"></a>UDP（User Data Protocol，用户数据报协议）</h1><p>（1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p><p>（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</p><p>（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p><p>（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</p><p>（5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p><p>（6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。<br>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p><h1 id="UDP的Java支持"><a href="#UDP的Java支持" class="headerlink" title="UDP的Java支持"></a>UDP的Java支持</h1><p>UDP协议提供的服务不同于TCP协议的端到端服务，它是面向非连接的，属于不可靠协议，UDP套接字在使用前不需要进行连接。实际上，UDP协议只实现了两个功能：</p><pre><code>1）在IP协议的基础上添加了端口；2）对传输过程中可能产生的数据错误进行了检测，并抛弃已经损坏的数据。</code></pre><p>Java通过DatagramPacket类和DatagramSocket类来使用UDP套接字，客户端和服务器端都通过DatagramSocket的send()方法和receive()方法来发送和接收数据，用DatagramPacket来包装需要发送或者接收到的数据。发送信息时，Java创建一个包含待发送信息的DatagramPacket实例，并将其作为参数传递给DatagramSocket实例的send()方法；接收信息时，Java程序首先创建一个Datagram实例，该实例预先分配了一些空间，并将接收到的信息存放在该空间中，然后把该实例作为参数传递给DatagramSocket实例的receive()方法。在创建DatagramPacket实例时，要注意：如果该实例用来包装待接收的数据，则不指定数据来源的远程主机和端口，只需要制定一个缓存数据的byte数组即可（在调用receive()方法接收到数据后，源地址和端口等信息会自动包含在DatagramPacket实例中），而如果该实例用来包装待发送的数据，则要指定要发送的目的主机和端口</p><p>UDP的通信建立的步骤</p><pre><code>UDP客户端首先被动等待联系的服务器发送一个数据报文。一个典型的UDP客户端要经过下面三步操作：1、创建一个DatagramSocket实例，可以有选择地对本地地址和端口号进行设置，如果设置了端口号，则客户端会在该端口号上监听从服务器端发送来的数据；2、使用DatagramSocket实例的send（）和receive（）方法来发送和接收DatagramPacket实例，进行通信；3、通信完成后，调用DatagramSocket实例的close（）方法来关闭该套接字。</code></pre><p>由于UDP是无连接的，因此UDP服务端不需要等待客户端的请求以建立连接。另外，UDP服务器为所有通信使用同一套接字，这点与TCP服务器不同，TCP服务器则为每个成功返回的accept()方法创建一个新的套接字。一个典型的UDP服务端要经过下面三步操作：</p><pre><code>1、创建一个DatagramSocket实例，指定本地端口号，并可以有选择地指定本地地址，此时，服务器已经准备好从任何客户端接收数据报文；2、使用DatagramSocket实例的receive（）方法接收一个DatagramPacket实例，当receive（）方法返回时，数据报文就包含了客户端的地址，这样就知道了回复信息应该发送到什么地方；3、使用DatagramSocket实例的send（）方法向服务器端返回DatagramPacket实例。</code></pre><p>这里有一点需要注意：</p><p>UDP程序在receive()方法处阻塞，直到收到一个数据报文或等待超时。由于UDP协议是不可靠协议，如果数据报在传输过程中发生丢失，那么程序将会一直阻塞在receive()方法处，这样客户端将永远都接收不到服务器端发送回来的数据，但是又没有任何提示。为了避免这个问题，我们在客户端使用DatagramSocket类的setSoTimeout()方法来制定receive()方法的最长阻塞时间，并指定重发数据报的次数，如果每次阻塞都超时，并且重发次数达到了设置的上限，则关闭客户端。<br>下面给出一个客户端服务端UDP通信的Demo（没有用多线程），该客户端在本地9999端口监听接收到的数据，并将字符串”服务端你好，我是UDP客户端”发送到本地服务器的3333端口，服务端在本地3333端口监听接收到的数据，如果接收到数据，则返回字符串”客服端你好， 我是服务端”到该客户端的9999端口。在客户端，由于程序可能会一直阻塞在receive（）方法处，因此这里我们在客户端用DatagramSocket实例的setSoTimeout（）方法来指定receive（）的最长阻塞时间，并设置重发数据的次数，如果最终依然没有接收到从服务端发送回来的数据，我们就关闭客户端。</p><p>代码如下：<br>服务端UDPServer：</p><p>import java.io.IOException;</p><p>import java.net.DatagramPacket;</p><p>import java.net.DatagramSocket;</p><p>import java.net.SocketException;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code> private static final  String TAG = &quot;UDPServer: &quot;;public static void main(String[] args) {    String sendStr = &quot;客服端你好， 我是服务端&quot;;    byte[] buf = new byte[1024];    //服务端在3333端口监听接收到的数据    try{        DatagramSocket datagramSocket = new DatagramSocket( 3333 );        //接收从客户端发送过来的数据        DatagramPacket packet_receive = new DatagramPacket( buf,buf.length );        System.out.println(&quot;server is on,waiting for client to send data...&quot;);        boolean f =true;        while (f){            //服务器端接收来自客户端的数据            datagramSocket.receive( packet_receive );            System.out.println(&quot;server receive data from client&quot;);            String receiveStr = new String(packet_receive.getData(),0,packet_receive.getLength())+                    &quot; from &quot; + packet_receive.getAddress().getHostAddress()+&quot;:&quot;+packet_receive.getPort();            System.out.println(receiveStr);            //数据发送到客户端的3333端口            // DatagramPacket packet_send = new DatagramPacket( sendStr.getBytes(),sendStr.length(),packet_receive.getAddress(),9999 );           //sendStr.length()为求字符串的长度，它的长度与该字符串转化为字节数组的长度不一致，可能会造成数据末尾丢失,所以改为如下            DatagramPacket packet_send = new DatagramPacket( sendStr.getBytes(),sendStr.getBytes().length,packet_receive.getAddress(),9999 );            datagramSocket.send( packet_send );            //由于packet_receive在接收了数据之后，其内部消息长度值会变为实际接收消息的字节数            //所以这里要将packet_receive的内部消息长度重新设置为1024            packet_receive.setLength( 1024 );        }        datagramSocket.close();    }catch (SocketException e){        System.out.println(TAG+e.getMessage());        e.printStackTrace();    }catch (IOException e){        System.out.println(TAG+e.getMessage());        e.printStackTrace();    }}</code></pre><p>}</p><p>客户端：<br>import java.io.IOException;</p><p>import java.io.InterruptedIOException;</p><p>import java.net.*;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</div></pre></td></tr></table></figure><pre><code>private static final String TAG = &quot;UDPClient: &quot;;//设置标签private static final int TIMEOUT = 5000;//设置接收数据的超时时间private static final int MAXNUM  = 5;//设置重发数据的最多次数public static void main(String[] args) {    String sendStr = &quot;服务端你好，我是UDP客户端&quot;;    byte[] buf = new byte[1024];    try {        //客服端在9999端口监听接收到的数据        DatagramSocket datagramSocket = new DatagramSocket( 9999 );        InetAddress address = InetAddress.getLocalHost();        //定义用来发送数据的DatagramPacket实例        DatagramPacket packet_send = new DatagramPacket( sendStr.getBytes(),sendStr.getBytes().length ,address,3333);        //定义用来接收数据的DatagramPacket实例        DatagramPacket packet_receive = new DatagramPacket( buf,buf.length );        //数据发向本地3333端口        datagramSocket.setSoTimeout( TIMEOUT );//设置接收数据时阻塞的最长时间        int tries = 0;//重发数据的次数        boolean receiveResponse = false;//是否接收到数据的标志位        //直到接收到数据，或者重发次数达到预定值，则退出循环        while (!receiveResponse &amp;&amp; tries &lt; MAXNUM){            //发送数据            datagramSocket.send( packet_send );            try{                //接收从服务端发送回来的数据                datagramSocket.receive( packet_receive );                //如果接收到的数据不是来自目标地址，则抛出异常                if(!packet_receive.getAddress().equals( address )){                    throw new IOException( &quot;Received paket from an unknow source&quot; );                }                //如果接收到数据  则将receiveResponse标志位改为true,退出循环                receiveResponse = true;            }catch (InterruptedIOException e){                //如果接收数据时阻塞超时，重发并减少一次重发的次数                tries += 1;                System.out.println(&quot;Time out,&quot;+(MAXNUM-tries)+&quot; more tries&quot;);            }        }        if(receiveResponse){            //如果收到数据，则打印出来            System.out.println(&quot;client received data from server: &quot;);            String receiveStr = new String( packet_receive.getData(),0,packet_receive.getLength() )+&quot; from &quot;+                    packet_receive.getAddress().getHostAddress()+&quot;:&quot;+packet_receive.getPort();            System.out.println(receiveStr);            //由于packet_receive在接收了数据之后，其内部消息长度值会变为实际接收消息的字节数            //所以这里要将packet_receive的内部消息长度重新设置为1024            packet_receive.setLength( 1024 );        }else{            //如果重发MAXNUM次数据后 仍未获得服务器发送回来的数据，则打印如下信息            System.out.println(&quot;No response -- give up.&quot;);        }        datagramSocket.close();    }catch (SocketException e){        System.out.println(TAG+e.getMessage());        e.printStackTrace();    }catch (UnknownHostException e){        System.out.println(TAG+e.getMessage());        e.printStackTrace();    }catch (IOException e){        System.out.println(TAG+e.getMessage());        e.printStackTrace();    }}</code></pre><p>}</p><p>结果如下：<br>客户端显示</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/client.png" alt=""></p><p>服务端显示如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/server.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UDP（User-Data-Protocol，用户数据报协议）&quot;&gt;&lt;a href=&quot;#UDP（User-Data-Protocol，用户数据报协议）&quot; class=&quot;headerlink&quot; title=&quot;UDP（User Data Protocol，用户数据报协议
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c#结合DevExpress控件制作计时器</title>
    <link href="https://wanglinyong.github.io/2017/11/04/csharp%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <id>https://wanglinyong.github.io/2017/11/04/csharp计时器/</id>
    <published>2017-11-04T11:27:06.000Z</published>
    <updated>2018-03-24T13:21:25.093Z</updated>
    
    <content type="html"><![CDATA[<p>这是我写的第一篇博客，主要将工作中遇到的问题以及技术或工具的使用做一个介绍和记录。</p><h2 id="DevExpress控件"><a href="#DevExpress控件" class="headerlink" title="DevExpress控件"></a>DevExpress控件</h2><h3 id="GaugeControl"><a href="#GaugeControl" class="headerlink" title="GaugeControl"></a>GaugeControl</h3><p>1.从工具箱中查找定时任务timer</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/2.png" alt=""></p><p>2.从工具箱中查找GaugeControl，选择合适的界面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/4.png" alt=""></p><p>3.控件界面效果如下</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/1.png" alt=""></p><p>利用工具箱中的GaugeControl控件制作计时器显示界面.<br>首先要添加一个定时任务：timer,给timer一个timer1_Tick事件<br>主要代码如下：<br>   public int currentCount = 0;<br>        private void timer1_Tick(object sender, EventArgs e)<br>        {<br>            //string[] arr = digitalGauge1.Text.Split(“:”);<br>            //设置定时间隔(毫秒为单位)<br>            System.Timers.Timer timer = new System.Timers.Timer(1000);<br>            //设置执行一次（false）还是一直执行(true)<br>            timer.AutoReset = true;<br>            //设置是否执行System.Timers.Timer.Elapsed事件<br>            timer.Enabled = true;<br>            currentCount += 1;</p><pre><code>    string second = (currentCount % 60)+&quot;&quot;;    string minute = (currentCount / 60 % 60)+&quot;&quot;;    string hour = (currentCount / 3600)+&quot;&quot;;    if (int.Parse(second) &lt; 10)    {        second = &quot;0&quot; + second;    }    else {    }    if (int.Parse(minute) &lt; 10)    {        minute = &quot;0&quot; + minute;    }    if (int.Parse(hour) &lt; 10)    {        hour = &quot;0&quot; + hour;    }    digitalGauge1.Text = hour + &quot;:&quot; + minute + &quot;:&quot; + second;}</code></pre><p>My Blog: <a href="https://wanglinyong.github.io/wanglinyong.github.io">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我写的第一篇博客，主要将工作中遇到的问题以及技术或工具的使用做一个介绍和记录。&lt;/p&gt;
&lt;h2 id=&quot;DevExpress控件&quot;&gt;&lt;a href=&quot;#DevExpress控件&quot; class=&quot;headerlink&quot; title=&quot;DevExpress控件&quot;&gt;&lt;/a&gt;D
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>maven手动安装jar到仓库</title>
    <link href="https://wanglinyong.github.io/2017/10/14/maven%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85jar%E5%88%B0%E4%BB%93%E5%BA%93/"/>
    <id>https://wanglinyong.github.io/2017/10/14/maven手动安装jar到仓库/</id>
    <published>2017-10-14T06:25:06.000Z</published>
    <updated>2017-10-14T06:33:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>1.首先保证有maven环境，可在cmd命令下输入mvn查看</p><p>2.在cmd命令输入如下命令：<br>mvn install:install-file -Dfile=D:\JProject\gsm-location-udp-jar\target\gsm-location.jar -DgroupId=com.dj.nms -DartifactId=gsm-location -Dversion=3.0.0 -Dpackaging=jar -DgeneratePom=true -DcreateChecksum=true</p><p>3.说明：<br>D:\JProject\gsm-location-udp-jar\target\gsm-location.jar：jar包所在位置<br>com.dj.nms：jar在仓库位置<br>gsm-location：jar包在仓库名称<br>3.0.0：jar包在仓库版本信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.首先保证有maven环境，可在cmd命令下输入mvn查看&lt;/p&gt;
&lt;p&gt;2.在cmd命令输入如下命令：&lt;br&gt;mvn install:install-file -Dfile=D:\JProject\gsm-location-udp-jar\target\gsm-loca
      
    
    </summary>
    
    
  </entry>
  
</feed>
