<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang&#39;s Blog</title>
  
  
  <link href="/wanglinyong.github.io/atom.xml" rel="self"/>
  
  <link href="https://wanglinyong.github.io/"/>
  <updated>2018-07-18T13:50:12.700Z</updated>
  <id>https://wanglinyong.github.io/</id>
  
  <author>
    <name>WangLinYong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Solr工作原理</title>
    <link href="https://wanglinyong.github.io/2018/07/13/solr%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/13/solr工作原理/</id>
    <published>2018-07-13T06:56:19.000Z</published>
    <updated>2018-07-18T13:50:12.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solr简介"><a href="#Solr简介" class="headerlink" title="Solr简介"></a>Solr简介</h2><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p><p>要想知道solr的实现原理，首先得了解什么是全文检索、solr的索引创建过程和索引搜索过程。</p><h2 id="一、全文检索"><a href="#一、全文检索" class="headerlink" title="一、全文检索"></a>一、全文检索</h2><p>首先举个例子：比如现在有5个文档，我现在想从5个文档中查找出包含”solr工作原理”的文档，此时有两种做法：</p><p>1.顺序扫描法:对5个文档依次查找，包含目标字段的文档就记录下来，最后查找的结果可能是在2,3文档中，这种查找方式叫做<strong>顺序扫描法</strong>。</p><p>顺序扫描法在文档数量较少的情况下，查找速度还是很快的，但是当文档数量很多时，查找速度就差强人意了。</p><p>2.全文检索:对文档内容进行分词，对分词后的结果创建索引，然后通过对索引进行搜索的方式叫做<strong>全文检索</strong>。</p><p>全文检索就相当于根据偏旁部首或者读音去查找字典，在文档很多的情况，这种查找速度肯定比你一个一个文档查找要快。</p><h2 id="二、索引创建和搜索过程"><a href="#二、索引创建和搜索过程" class="headerlink" title="二、索引创建和搜索过程"></a>二、索引创建和搜索过程</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h3><p>举例子：</p><p>文档一：solr是基于Lucene开发的企业级搜索引擎技术</p><p>文档二：Solr是一个独立的企业级搜索应用服务器，Solr是一个高性能，基于Lucene的全文搜索服务器</p><p>首先经过分词器分词，solr会为分词后的结果（词典）创建索引，然后将索引和文档id列表对应起来，如下图所示：</p><p><img src="https://images.gitbook.cn/2b1670f0-8665-11e8-9b0d-95de449dc107" alt="enter image description here"></p><p>比如：solr在文档1和文档2中都有出现，所以对应的文档ID列表中既包含文档1的ID也包含文档2的ID，文档ID列表对应到具体的文档，并体现该词典在该文档中出现的频次，频次越多说明权重越大，权重越大搜索的结果就会排在前面。</p><p>solr内部会对分词的结果做如下处理：</p><p>1.去除停词和标点符号，例如英文的this，that等， 中文的”的”,”一”等没有特殊含义的词</p><p>2.会将所有的大写英文字母转换成小写，方便统一创建索引和搜索索引</p><p>3.将复数形式转为单数形式，比如students转为student，也是方便统一创建索引和搜索索引</p><h3 id="2-索引搜索过程"><a href="#2-索引搜索过程" class="headerlink" title="2.索引搜索过程"></a>2.索引搜索过程</h3><p>知道了创建索引的过程，那么根据索引进行搜索就变得简单了。</p><p>1.用户输入搜索条件</p><p>2.对搜索条件进行分词处理</p><p>3.根据分词的结果查找索引</p><p>4.根据索引找到文档ID列表</p><p>5.根据文档ID列表找到具体的文档，根据出现的频次等计算权重，最后将文档列表按照权重排序返回</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Solr简介&quot;&gt;&lt;a href=&quot;#Solr简介&quot; class=&quot;headerlink&quot; title=&quot;Solr简介&quot;&gt;&lt;/a&gt;Solr简介&lt;/h2&gt;&lt;p&gt;Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过h
      
    
    </summary>
    
      <category term="Solr" scheme="https://wanglinyong.github.io/categories/Solr/"/>
    
    
      <category term="solr" scheme="https://wanglinyong.github.io/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Security登录认证授权原理</title>
    <link href="https://wanglinyong.github.io/2018/07/10/Spring-Security%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%8E%9F%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/10/Spring-Security登录认证授权原理/</id>
    <published>2018-07-10T02:09:10.000Z</published>
    <updated>2018-07-18T13:47:57.755Z</updated>
    
    <content type="html"><![CDATA[<p>spring-security源码下载地址：</p><pre><code>https://github.com/spring-projects/spring-security</code></pre><h2 id="Spring-Security源码解读："><a href="#Spring-Security源码解读：" class="headerlink" title="Spring-Security源码解读："></a>Spring-Security源码解读：</h2><p>1.使用ctrl+shift+n组合键查找UsernamePasswordAuthenticationFilter过滤器，该过滤器是用来处理用户认证逻辑的，进入后如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security-3.png" alt=""></p><p>(1)可以看到它默认的登录请求url是”/login”，并且只允许POST方式的请求</p><p>(2)obtainUsername()方法点进去发现它默认是根据参数名为”username”和”password”来获取用户名和密码的</p><p>(3)通过构造方法实例化一个UsernamePasswordAuthenticationToken对象，此时调用的是UsernamePasswordAuthenticationToken的两个参数的构造函数,如果点击进不去，可直接用ctrl+shift+n查找(等依赖自动下载完成就可以跟进了)，如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security-4.png" alt=""></p><p>其中super(null)调用的是父类的构造方法，传入的是权限集合，因为目前还没有认证通过，所以不知道有什么权限信息，这里设置为null,然后将用户名和密码分别赋值给principal和credentials，同样因为此时还未进行身份认证，所以setAuthenticated(false)</p><p>(4)setDetails(request, authRequest)是将当前的请求信息设置到UsernamePasswordAuthenticationToken中</p><p>(5)通过调用getAuthenticationManager()来获取AuthenticationManager，通过调用它的authenticate方法来查找支持该token(UsernamePasswordAuthenticationToken)认证方式的provider，然后调用该provider的authenticate方法进行认证)</p><p>2.AuthenticationManager是用来管理AuthenticationProvider的接口，通过查找后进入，然后使用ctrl+H组合键查看它的继承关系，找到ProviderManager实现类，它实现了AuthenticationManager接口，查看它的authenticate方法，它里面有段这样的代码：</p><pre><code>for (AuthenticationProvider provider : getProviders()) {        if (!provider.supports(toTest)) {            continue;        }    ...    try {            result = provider.authenticate(authentication);    ...    }}</code></pre><p>通过for循环遍历AuthenticationProvider对象的集合，找到支持当前认证方式的AuthenticationProvider，找到之后调用该AuthenticationProvider的authenticate方法进行认证处理：</p><pre><code>result = provider.authenticate(authentication);</code></pre><p>3.AuthenticationProvider接口，就是进行身份认证的接口，它里面有两个方法：authenticate认证方法和supports是否支持某种类型token的方法，通过ctrl+h查看继承关系，找到AbstractUserDetailsAuthenticationProvider抽象类，它实现了AuthenticationProvider接口，它的supports方法如下：</p><pre><code>public boolean supports(Class&lt;?&gt; authentication) {    return (UsernamePasswordAuthenticationToken.class        .isAssignableFrom(authentication));    }</code></pre><p>说明它是支持UsernamePasswordAuthenticationToken类型的AuthenticationProvider</p><p>再看它的authenticate认证方法，其中有一段这样的代码：</p><pre><code>boolean cacheWasUsed = true;    UserDetails user = this.userCache.getUserFromCache(username);    if (user == null) {        cacheWasUsed = false;        try {            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);        }    ...    }</code></pre><p>如果从缓存中没有获取到UserDetails，那么它调用retrieveUser方法来获取用户信息UserDetails，这里的retrieveUser是抽象方法，等一会我们看它的子类实现。</p><p>用户信息UserDetails是个接口，我们进入查看，它包含以下6个接口方法：</p><pre><code>Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//获取权限集合String getPassword();  //获取密码String getUsername();    //获取用户名boolean isAccountNonExpired(); //账户未过期boolean isAccountNonLocked();    //账户未锁定boolean isCredentialsNonExpired(); //密码未过期boolean isEnabled();    //账户可用</code></pre><p>查看它的继承关系发现User类实现了该接口，并实现了该接口的所有方法</p><p>接着AbstractUserDetailsAuthenticationProvider往下看，找到下面的代码：</p><pre><code>preAuthenticationChecks.check(user);additionalAuthenticationChecks(user,            (UsernamePasswordAuthenticationToken) authentication);</code></pre><p>preAuthenticationChecks预检查，在最下面的内部类DefaultPreAuthenticationChecks中可以看到，它会检查上面提到的三个boolean方法，即检查账户未锁定、账户可用、账户未过期，如果上面的方法只要有一个返回false，就会抛出异常，那么认证就会失败。</p><p>additionalAuthenticationChecks是附加检查，是个抽象方法，等下看子类的具体实现。</p><p>下面还有个postAuthenticationChecks.check(user)后检查，在最下面的DefaultPostAuthenticationChecks内部类中可以看到，它会检查密码未过期，如果为false就会抛出异常</p><p>如果上面的检查都通过并且没有异常，表示认证通过，会调用下面的方法：</p><pre><code>createSuccessAuthentication(principalToReturn, authentication, user);</code></pre><p>跟进发现此时通过构造方法实例化对象UsernamePasswordAuthenticationToken时，调用的是三个参数的构造方法:</p><pre><code>    public UsernamePasswordAuthenticationToken(Object principal, Object credentials,        Collection&lt;? extends GrantedAuthority&gt; authorities) {    super(authorities);    this.principal = principal;    this.credentials = credentials;    super.setAuthenticated(true); // must use super, as we override}</code></pre><p>此时会调用父类的构造方法设置权限信息，并调用父类的setAuthenticated(true)方法，到这里就表示认证通过了。</p><p>下面我们看看AbstractUserDetailsAuthenticationProvider的子类，同ctrl+h可查看继承关系，找到DaoAuthenticationProvider</p><p>4.DaoAuthenticationProvider类</p><p>(1)查看additionalAuthenticationChecks附加检查方法，它主要是检查用户密码的正确性，如果密码为空或者错误都会抛出异常</p><p>(2)获取用户信息UserDetails的retrieveUser方法，主要看下面这段代码：</p><pre><code>UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</code></pre><p>它是调用了getUserDetailsService先获取到UserDetailsService对象，通过调用UserDetailsService对象的loadUserByUsername方法获取用户信息UserDetails</p><p>找到UserDetailsService，发现它是一个接口，查看继承关系，有很多实现，都是spring-security提供的实现类，并不满足我们的需要，我们想自己制定获取用户信息的逻辑，所以我们可以实现这个接口。比如从我们的数据库中查找用户信息</p><p>5.SecurityContextPersistenceFilter过滤器</p><p>那么用户认证成功之后，又是怎么保存认证信息的呢，在下一次请求过来是如何判断该用户是否已经认证了呢？</p><p>请求进来时会经过SecurityContextPersistenceFilter过滤器，进入SecurityContextPersistenceFilter过滤器并找到以下代码：</p><pre><code>SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</code></pre><p>从session中获取SecurityContext对象，如果没有就实例化一个SecurityContext对象</p><pre><code>SecurityContextHolder.setContext(contextBeforeChainExecution);</code></pre><p>将SecurityContext对象设置到SecurityContextHolder中</p><pre><code>chain.doFilter(holder.getRequest(), holder.getResponse());</code></pre><p>表示放行，执行下一个过滤器</p><p>执行完后面的过滤并经过servlet处理之后，响应给浏览器之前再次经过此过滤器。查看以下代码：</p><pre><code>SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();SecurityContextHolder.clearContext();this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</code></pre><p>通过SecurityContextHolder获取SecurityContext对象，然后清除SecurityContext，最后将获取的SecurityContext对象放入session中</p><p>其中SecurityContextHolder是与ThreadLocal绑定的，即本线程内所有的方法都可以获得SecurityContext对象，而SecurityContext对象中包含了Authentication对象，即用户的认证信息，spring-security判断用户是否认证主要是根据SecurityContext中的Authentication对象来判断。Authentication对象的详细信息如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security.png" alt=""></p><p>最后整个过程的流程大致如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/spring-securityx.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring-security源码下载地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/spring-projects/spring-security
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Spring-Security源码解读：&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
      <category term="spring-security" scheme="https://wanglinyong.github.io/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>读取properties文件内容最简单的两种方式</title>
    <link href="https://wanglinyong.github.io/2018/07/03/%E8%8E%B7%E5%8F%96properties%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F/"/>
    <id>https://wanglinyong.github.io/2018/07/03/获取properties文件内容最简单方式/</id>
    <published>2018-07-03T00:47:49.000Z</published>
    <updated>2018-07-18T13:41:13.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用ResourceBundle读取jdbc-properties文件"><a href="#一、使用ResourceBundle读取jdbc-properties文件" class="headerlink" title="一、使用ResourceBundle读取jdbc.properties文件"></a>一、使用ResourceBundle读取jdbc.properties文件</h2><pre><code>public static void main(String[] args) {    ResourceBundle bundle = ResourceBundle.getBundle(&quot;jdbc&quot;);    String value= bundle.getString(&quot;driverClasss&quot;);    System.out.println(value);}</code></pre><p>结果如下：</p><pre><code>com.mysql.jdbc.Driver</code></pre><h2 id="二、自定义工具类PropertiesUtils读取jdbc-properties文件："><a href="#二、自定义工具类PropertiesUtils读取jdbc-properties文件：" class="headerlink" title="二、自定义工具类PropertiesUtils读取jdbc.properties文件："></a>二、自定义工具类PropertiesUtils读取jdbc.properties文件：</h2><h3 id="1-PropertiesUtils代码如下："><a href="#1-PropertiesUtils代码如下：" class="headerlink" title="1.PropertiesUtils代码如下："></a>1.PropertiesUtils代码如下：</h3><pre><code>import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;/** * Created by wly on 2018/7/3. */public class  {private static Properties props = new Properties();public static String getValue(String key) {    return props.getProperty(key);}public static void updateProperties(String key, String value) {    props.setProperty(key, value);}static {    try {        props.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;));    } catch (FileNotFoundException var1) {        var1.printStackTrace();    } catch (IOException var2) {        var2.printStackTrace();    }}}</code></pre><h3 id="2-main方法测试"><a href="#2-main方法测试" class="headerlink" title="2.main方法测试"></a>2.main方法测试</h3><pre><code>public static void main(String[] args) {    String name = getValue( &quot;driverClasss&quot; );    System.out.println(&quot;mysql的driverClasss===&quot;+name);    updateProperties( &quot;driverClasss&quot;,&quot;oracle.jdbc.driver.OracleDriver&quot; );    name = getValue( &quot;driverClasss&quot; );    System.out.println(&quot;修改成Oracle的driverClasss====&quot;+name);}</code></pre><p>测试结果：</p><pre><code>mysql的driverClasss===com.mysql.jdbc.Driver修改成Oracle的driverClasss====oracle.jdbc.driver.OracleDriver</code></pre><p>一个是根据key获取对应的value值</p><p>一个是根据key值设置对应的value值，注意不会改变propertis文件内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、使用ResourceBundle读取jdbc-properties文件&quot;&gt;&lt;a href=&quot;#一、使用ResourceBundle读取jdbc-properties文件&quot; class=&quot;headerlink&quot; title=&quot;一、使用ResourceBundle
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>AccessDeniedException如何处理</title>
    <link href="https://wanglinyong.github.io/2018/07/02/AccessDeniedException%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/02/AccessDeniedException如何处理/</id>
    <published>2018-07-02T02:46:40.000Z</published>
    <updated>2018-07-18T13:39:13.452Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况：</p><p>1.用户未登录情况下访问受保护资源</p><p>2.用户登录情况下访问被保护资源</p><h2 id="一、用户未登录情况下访问受保护资源"><a href="#一、用户未登录情况下访问受保护资源" class="headerlink" title="一、用户未登录情况下访问受保护资源"></a>一、用户未登录情况下访问受保护资源</h2><p>用户在未登录的情况下访问受保护资源时会自动跳转到配置的登录页面。主要是以下这个配置起作用：</p><pre><code>&lt;security:http auto-config=&quot;false&quot; access-decision-manager-ref=&quot;accessDecisionManager&quot;               use-expressions=&quot;true&quot; entry-point-ref=&quot;loginEntryPoint&quot;&gt; &lt;bean id=&quot;loginEntryPoint&quot;    class=&quot;org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint&quot;&gt;    &lt;!-- 默认登录页的url --&gt;    &lt;constructor-arg value=&quot;/login?error=login&quot;/&gt;&lt;/bean&gt;&lt;/security:http&gt;</code></pre><p>但是这里说的访问路径不包含ajax请求的访问，如果是ajax请求的话，你会看到后台报AccessDeniedException异常，而前台没反应。因为对ajax请求不起作用</p><p>此时你可以这样来解决，在发送ajax请求的页面判断用户是否为空，为空则直接跳转到登录页面，如下：</p><pre><code> var res = &apos;${user.id}&apos;;    if(res==&apos;&apos; || res==null){        window.location.href = &quot;/login.jsp&quot;;    }    $.ajax({    ...})；}</code></pre><p>登录情况下的ajax请求我们下面介绍</p><h2 id="二、用户在登录情况下访问受保护资源"><a href="#二、用户在登录情况下访问受保护资源" class="headerlink" title="二、用户在登录情况下访问受保护资源"></a>二、用户在登录情况下访问受保护资源</h2><p>用户在登录情况下访问受保护资源时，可以有两种解决方案：</p><h3 id="1-配置403错误页面-有瑕疵"><a href="#1-配置403错误页面-有瑕疵" class="headerlink" title="1.配置403错误页面(有瑕疵)"></a>1.配置403错误页面(有瑕疵)</h3><p>因为我们知道访问受保护资源时会返回403错误码，我们可以直接配置403错误页面</p><p>在web.xml中配置错误页面：</p><pre><code>&lt;error-page&gt;    &lt;error-code&gt;403&lt;/error-code&gt;    &lt;location&gt;/WEB-INF/403.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><p>在/WEB-INF/下引入403.jsp即可</p><p>此时访问受保护资源时会直接跳转到我们配置的403错误页面</p><p>但是问题又来了，ajax请求访问受保护资源时同样没有反应，且看下面的解决办法</p><h3 id="2-自定义MyAccessDeniedHandler拒绝访问处理器（完美）"><a href="#2-自定义MyAccessDeniedHandler拒绝访问处理器（完美）" class="headerlink" title="2.自定义MyAccessDeniedHandler拒绝访问处理器（完美）"></a>2.自定义MyAccessDeniedHandler拒绝访问处理器（完美）</h3><p>1.新建MyAccessDeniedHandler并实现AccessDeniedHandler接口：</p><pre><code>public class MyAccessDeniedHandler implements AccessDeniedHandler{private String errorPage;public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {    String header = request.getHeader( &quot;X-Requested-With&quot; );    if (header != null &amp;&amp; &quot;XMLHttpRequest&quot;.equals( header )) {        //ajax请求        String jsonObject = &quot;{\&quot;access-denied\&quot;:true}&quot;;        PrintWriter out = response.getWriter();        out.print( jsonObject );        out.flush();        out.close();        return;    } else {        RequestDispatcher dispatcher = request.getRequestDispatcher( errorPage );        dispatcher.forward( request, response );    }}public void setErrorPage(String errorPage) {    if(errorPage != null &amp;&amp; !errorPage.startsWith(&quot;/&quot;)) {        throw new IllegalArgumentException(&quot;errorPage must begin with &apos;/&apos;&quot;);    } else {        this.errorPage = errorPage;    }}}</code></pre><p>(1)通过setter方法获取配置文件中配置的错误页面</p><p>(2)根据请求头信息判断该请求是不是ajax请求</p><p>(3)如果是ajax请求，则返回json格式数据{access-denied:true}</p><p>(4)如果不是ajax请求则将请求转发到配置的错误页面</p><p>2.spring-security.xml配置自定义的AccessDeniedHandler：</p><pre><code>&lt;security:access-denied-handler ref=&quot;accessDeniedHandler&quot;/&gt;&lt;bean id=&quot;accessDeniedHandler&quot; class=&quot;wang.dreamland.www.security.MyAccessDeniedHandler&quot;&gt;    &lt;property name=&quot;errorPage&quot; value=&quot;/accessDenied.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>3.在webapp目录下新建accessDenied.jsp文件：</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;无访问权限&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;span style=&quot;color: red&quot;&gt;无访问权限&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>4.在发ajax请求的页面做下判断：</p><pre><code>$.ajax({       type:&apos;post&apos;,       url:&apos;/list&apos;,       dataType:&apos;json&apos;,       success:function(data){           var noAccess = data[&quot;access-denied&quot;]           if(noAccess){               window.location.href = &quot;${ctx}/accessDenied.jsp&quot;;               return           }       ...   }   });</code></pre><p>如果noAccess=true则跳转到accessDenied.jsp页面</p><p>这样就完美解决了登陆后无访问权限跳转的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两种情况：&lt;/p&gt;
&lt;p&gt;1.用户未登录情况下访问受保护资源&lt;/p&gt;
&lt;p&gt;2.用户登录情况下访问被保护资源&lt;/p&gt;
&lt;h2 id=&quot;一、用户未登录情况下访问受保护资源&quot;&gt;&lt;a href=&quot;#一、用户未登录情况下访问受保护资源&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
      <category term="security" scheme="https://wanglinyong.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Python压缩解压zip文件</title>
    <link href="https://wanglinyong.github.io/2018/06/28/Python%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/"/>
    <id>https://wanglinyong.github.io/2018/06/28/Python压缩解压zip文件/</id>
    <published>2018-06-28T03:37:40.000Z</published>
    <updated>2018-07-18T13:33:02.308Z</updated>
    
    <content type="html"><![CDATA[<p>导入相关模块</p><pre><code>import osimport shutilimport zipfilefrom os.path import join, getsize</code></pre><h2 id="一、python压缩指定文件夹"><a href="#一、python压缩指定文件夹" class="headerlink" title="一、python压缩指定文件夹"></a>一、python压缩指定文件夹</h2><pre><code>def zip_file(src_dir):    zip_name = src_dir +&apos;.zip&apos;    z = zipfile.ZipFile(zip_name,&apos;w&apos;,zipfile.ZIP_DEFLATED)    for dirpath, dirnames, filenames in os.walk(src_dir):        fpath = dirpath.replace(src_dir,&apos;&apos;)        fpath = fpath and fpath + os.sep or &apos;&apos;        for filename in filenames:            z.write(os.path.join(dirpath, filename),fpath+filename)            print (&apos;==压缩成功==&apos;)    z.close()</code></pre><p>其中</p><pre><code>src_dir：你要压缩的文件夹的路径zip_name：压缩后zip文件的路径及名称</code></pre><h2 id="二、python解压zip"><a href="#二、python解压zip" class="headerlink" title="二、python解压zip"></a>二、python解压zip</h2><pre><code>def unzip_file(zip_src, dst_dir):    r = zipfile.is_zipfile(zip_src)    if r:             fz = zipfile.ZipFile(zip_src, &apos;r&apos;)        for file in fz.namelist():            fz.extract(file, dst_dir)           else:        print(&apos;This is not zip&apos;)</code></pre><p>其中：</p><pre><code>zip_src:是zip文件的全路径dst_dir：是要解压到的目的文件夹</code></pre><h2 id="三、Python其它操作文件方法"><a href="#三、Python其它操作文件方法" class="headerlink" title="三、Python其它操作文件方法"></a>三、Python其它操作文件方法</h2><h3 id="1-剪切（移动）文件到指定目录"><a href="#1-剪切（移动）文件到指定目录" class="headerlink" title="1.剪切（移动）文件到指定目录"></a>1.剪切（移动）文件到指定目录</h3><pre><code>shutil.move(filename, dst_dir)</code></pre><h3 id="2-删除文件夹"><a href="#2-删除文件夹" class="headerlink" title="2.删除文件夹"></a>2.删除文件夹</h3><pre><code>shutil.rmtree(src_dir)</code></pre><h3 id="3-删除指定文件"><a href="#3-删除指定文件" class="headerlink" title="3.删除指定文件"></a>3.删除指定文件</h3><pre><code>os.remove(file_src)</code></pre><h3 id="4-新建文件夹"><a href="#4-新建文件夹" class="headerlink" title="4.新建文件夹"></a>4.新建文件夹</h3><pre><code>os.mkdir(dst_dir)</code></pre><h3 id="5-遍历文件夹"><a href="#5-遍历文件夹" class="headerlink" title="5.遍历文件夹"></a>5.遍历文件夹</h3><pre><code>for filename in os.listdir(src_dir):</code></pre><h3 id="6-复制文件"><a href="#6-复制文件" class="headerlink" title="6.复制文件"></a>6.复制文件</h3><pre><code>shutil.copyfile(src_file,dst_file)  </code></pre><h3 id="7-获取文件夹大小"><a href="#7-获取文件夹大小" class="headerlink" title="7.获取文件夹大小"></a>7.获取文件夹大小</h3><pre><code>def get_dir_size(dir_path):    size = 0L    for root, dirs, files in os.walk(dir_path):        size += sum([getsize(join(root, name)) for name in files])    return size</code></pre><p>可以根据文件大小做不同的判断，如：</p><pre><code>file_size = get_dir_size(DATA_PATH)max_size = file_size / 1024 / 1024   ##获得的是以Mb为单位的值if max_size &lt; 100:    pass</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导入相关模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
import shutil
import zipfile
from os.path import join, getsize
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;一、python压缩指定文件夹&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Python" scheme="https://wanglinyong.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="https://wanglinyong.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>dockpanel动态添加picturebox并绑定图片</title>
    <link href="https://wanglinyong.github.io/2018/06/04/dockpanel%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0picturebox%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://wanglinyong.github.io/2018/06/04/dockpanel动态添加picturebox的方法/</id>
    <published>2018-06-04T12:59:40.000Z</published>
    <updated>2018-06-04T13:03:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。</p><h2 id="1-生成picturebox的方法"><a href="#1-生成picturebox的方法" class="headerlink" title="1.生成picturebox的方法"></a>1.生成picturebox的方法</h2><pre><code> public void generatorPictureBox(){    int imageNum = 20;//图片的数量    PictureBox[] pict;    pict = new PictureBox[imageNum];    for (int i = 1; i &lt; imageNum; i++)    {        pict[i] = new System.Windows.Forms.PictureBox();               pict[i].Location = new Point(5 , 10+(i - 1) * 60);//设置图片位置  竖向排列        pict[i].SizeMode = PictureBoxSizeMode.Zoom;        pict[i].Image = Image.FromFile(@&quot;D:\images\&quot; + i + &quot;.png&quot;);//导入图片        pict[i].Size = new Size(50, 50);//设置图片大小        pict[i].BorderStyle = BorderStyle.None;//取消边框        pict[i].Image.Tag = i;        pict[i].Click += singleClick;//给图片绑定点击事件        dockPanel1.Controls.Add(pict[i]); //添加picturebox    }}</code></pre><h2 id="2-给图片绑定的点击事件"><a href="#2-给图片绑定的点击事件" class="headerlink" title="2.给图片绑定的点击事件"></a>2.给图片绑定的点击事件</h2><pre><code>private void singleClick(object sender, EventArgs e)  {      PictureBox p = sender as PictureBox;             LOG.Info(&quot;Click===============imgIndex====&quot;+p.Image.Tag);  }</code></pre><h2 id="3-在窗体初始化的时候调用generatorPictureBox方法即可"><a href="#3-在窗体初始化的时候调用generatorPictureBox方法即可" class="headerlink" title="3.在窗体初始化的时候调用generatorPictureBox方法即可"></a>3.在窗体初始化的时候调用generatorPictureBox方法即可</h2><h2 id="4-效果如下："><a href="#4-效果如下：" class="headerlink" title="4.效果如下："></a>4.效果如下：</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/doc-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。&lt;/p&gt;
&lt;h2 id=&quot;1-生成picturebox的方法&quot;&gt;&lt;a href=&quot;#1-生成picturebox的方法&quot; class=&quot;he
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="picturebox" scheme="https://wanglinyong.github.io/tags/picturebox/"/>
    
      <category term="c#" scheme="https://wanglinyong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Xshell6下载安装</title>
    <link href="https://wanglinyong.github.io/2018/05/28/Xshell6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
    <id>https://wanglinyong.github.io/2018/05/28/Xshell6下载安装/</id>
    <published>2018-05-28T11:23:20.000Z</published>
    <updated>2018-05-29T11:44:50.606Z</updated>
    
    <content type="html"><![CDATA[<p>随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。</p><p> 1.进入xshell英文官网，链接地址如下：</p><pre><code>http://www.netsarang.com/products/main.html</code></pre><p>2.将鼠标悬浮在Download上会出现三个列表，点击第三个Free License,如下图：</p><p><img src="https://img-blog.csdn.net/20180528160438334" alt=""></p><p>或者点击Download，将窗口滚动到最下方，点击Free for Home &amp; School，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160452206" alt=""></p><p>3.之后会进入Xshell6和Xftp6的下载页面，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160508678" alt=""></p><p>4.点击Xshell6会跳转到填写个人信息的页面，打红星的是必填项，注意邮箱要正确，会将下载链接发到你的邮箱，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160523209" alt=""></p><p>5.填写好信息后，点击Submit提交，这时下载链接就会发送到你填写的邮箱了。</p><p>6.打开邮箱，点击链接进行下载，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160539725" alt=""></p><p>7.下载完成后根据提示进行安装即可。</p><p>xshell6下载完成以后，一般还需要配合xftp6文件上传工具使用，下载步骤同上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。&lt;/p&gt;
&lt;p&gt; 1.进入xshell英文官网，链接地址如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零开始开发SSM项目-博客系统实战</title>
    <link href="https://wanglinyong.github.io/2018/05/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91SSM%E9%A1%B9%E7%9B%AE-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://wanglinyong.github.io/2018/05/26/从零开始开发SSM项目-博客系统实战/</id>
    <published>2018-05-26T11:30:28.000Z</published>
    <updated>2018-05-26T11:30:45.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、项目包含功能"><a href="#一、项目包含功能" class="headerlink" title="一、项目包含功能"></a>一、项目包含功能</h1><p>使用SSM框架开发一个博客系统，包含的功能大致有:</p><p>1.用户注册与激活，激活方式通过邮件激活</p><p>2.用户的登录和退出，包括账号登录和手机快捷登录</p><p>3.用户账号登录和注册时需要输入验证码验证</p><p>4.首页展示及分页，主要展示文章内容，可进行搜索，将搜索结果高亮显示</p><p>5.首页文章的点赞、踩和评论功能</p><p>6.个人主页模块，包括个人的基本信息，梦分类，发布梦，管理梦以及热梦推荐等</p><p>7.书写文章功能</p><p>8.文章管理功能，包括文章的查看、修改和删除</p><p>9.个人信息修改功能</p><p>10.安全框架 spring-security 的整合，对不符合条件的用户或者 URL 进行拦截</p><p>11.记录用户登录信息，包括登录的时间、IP 等</p><h1 id="二、项目所用技术"><a href="#二、项目所用技术" class="headerlink" title="二、项目所用技术"></a>二、项目所用技术</h1><p>使用到的技术主要有</p><p>1.主体框架：SpringMVC + Spring + Mybatis</p><p>2.安全框架：Spring-Security</p><p>3.数据库：Mysql</p><p>4.缓存技术：Redis</p><p>5.消息中间件：ActiveMQ</p><p>6.搜索引擎：solr</p><p>7.富文本编辑器： Kindeditor</p><p>8.异步更新：Ajax</p><p>9.前端框架：zui、bootstrap、Jquery</p><h1 id="三、部分页面效果如下："><a href="#三、部分页面效果如下：" class="headerlink" title="三、部分页面效果如下："></a>三、部分页面效果如下：</h1><p>1.登录页面（账号登录和手机快捷登录）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-y.png" alt=""></p><p>2.注册页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/regist-x.png" alt=""></p><p>3.首页（评论、回复及点赞）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/index-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/chat-x.png" alt=""></p><p>4.写博客页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/write-x.png" alt=""></p><p>5.个人主页</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/personal-x.png" alt=""></p><p>6.个人信息页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/update.png" alt=""></p><p>7.修改密码页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/repassword-x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、项目包含功能&quot;&gt;&lt;a href=&quot;#一、项目包含功能&quot; class=&quot;headerlink&quot; title=&quot;一、项目包含功能&quot;&gt;&lt;/a&gt;一、项目包含功能&lt;/h1&gt;&lt;p&gt;使用SSM框架开发一个博客系统，包含的功能大致有:&lt;/p&gt;
&lt;p&gt;1.用户注册与激活，激活方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 借助阿里大于平台发送短信</title>
    <link href="https://wanglinyong.github.io/2018/05/18/csharp%E5%80%9F%E5%8A%A9%E9%98%BF%E9%87%8C%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    <id>https://wanglinyong.github.io/2018/05/18/csharp借助阿里大于发送短信/</id>
    <published>2018-05-18T12:30:18.000Z</published>
    <updated>2018-05-18T12:34:29.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、首先申请签名和模板"><a href="#一、首先申请签名和模板" class="headerlink" title="一、首先申请签名和模板"></a>一、首先申请签名和模板</h1><p>1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管理，申请一个签名，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-1.png" alt=""></p><p>2.然后找到模板管理，申请一个模板，模板里都有格式内容介绍，申请好以后大概是这样：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-8.png" alt=""></p><p>3.签名名称和模板CODE等会代码中会用到，还有Access Key ID 和 Access Key Secret也要用到，Access Key在个人信息的下拉列表里可以找到，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-3.png" alt=""></p><h1 id="二、下载-Net平台下的SDK"><a href="#二、下载-Net平台下的SDK" class="headerlink" title="二、下载.Net平台下的SDK"></a>二、下载.Net平台下的SDK</h1><p>1.点击短信服务列表中的帮助文档</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-4.png" alt=""></p><p>2.点击SDK下载，进入到SDK及DEMO下载页面，找到第4个[NET],点击即可下载。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-5.png" alt=""></p><p>3.将下载好的压缩包进行解压，找到msg_demo目录，在/msg_demo/alicom-mns-receive有发送短信的demo和dll文件</p><h1 id="三、发短信的具体实现"><a href="#三、发短信的具体实现" class="headerlink" title="三、发短信的具体实现"></a>三、发短信的具体实现</h1><p>1.将/msg_demo/alicom-mns-receive/dll目录下的4个dll文件拷贝到你的项目目录下</p><p>2.在你项目的引用右键添加引用，打开引用管理器，如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-6.png" alt=""></p><p>3.点击浏览，将阿里大于依赖的4个dll文件添加进来，然后点击确定。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-7.png" alt=""></p><p>4.将/msg_demo/alicom-mns-receive下的sendsms文件拷贝到你的项目中，将其中Access Key ID 、 Access Key Secret、签名名称、模板CODE替换成你自己的即可，还有接收短信的手机号，模板内容等，可以将main函数改成一个方法sendMsg(string phone,string code)，直接调用方法即可，参数改为接收短信的手机号和短信内容：</p><pre><code>namespace ConsoleApplication1{class sendsms{    static String product = &quot;Dysmsapi&quot;;//短信API产品名称    static String domain = &quot;dysmsapi.aliyuncs.com&quot;;//短信API产品域名    static String accessId = &quot;你的Key&quot;;    static String accessSecret = &quot;你的Secret&quot;;    static String regionIdForPop = &quot;cn-hangzhou&quot;;   public  static void sendMsg(string phone,string code)    {        IClientProfile profile = DefaultProfile.GetProfile(regionIdForPop, accessId, accessSecret);        DefaultProfile.AddEndpoint(regionIdForPop, regionIdForPop, product, domain);        IAcsClient acsClient = new DefaultAcsClient(profile);        SendSmsRequest request = new SendSmsRequest();        try        {            //request.SignName = &quot;上云预发测试&quot;;//&quot;管理控制台中配置的短信签名（状态必须是验证通过）&quot;            //request.TemplateCode = &quot;SMS_71130001&quot;;//管理控制台中配置的审核通过的短信模板的模板CODE（状态必须是验证通过）&quot;            //request.RecNum = &quot;13567939485&quot;;//&quot;接收号码，多个号码可以逗号分隔&quot;            //request.ParamString = &quot;{\&quot;name\&quot;:\&quot;123\&quot;}&quot;;//短信模板中的变量；数字需要转换为字符串；个人用户每个变量长度必须小于15个字符。&quot;            //SingleSendSmsResponse httpResponse = client.GetAcsResponse(request);            request.PhoneNumbers = phone;//接收短信的手机号            request.SignName = &quot;签名名称&quot;;            request.TemplateCode = &quot;模板CODE&quot;;            request.TemplateParam = &quot;{\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;}&quot;;//模板内容           // request.OutId = &quot;xxxxxxxx&quot;;  //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者            //请求失败这里会抛ClientException异常            SendSmsResponse sendSmsResponse = acsClient.GetAcsResponse(request);            System.Console.WriteLine(sendSmsResponse.Message);        }        catch (ServerException e)        {            System.Console.WriteLine(&quot;ServerException&quot;);        }        catch (ClientException e)        {            System.Console.WriteLine(&quot;ClientException&quot;);        }    }}}</code></pre><p>5.运行程序，调用发送短信方法进行测试，测试成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、首先申请签名和模板&quot;&gt;&lt;a href=&quot;#一、首先申请签名和模板&quot; class=&quot;headerlink&quot; title=&quot;一、首先申请签名和模板&quot;&gt;&lt;/a&gt;一、首先申请签名和模板&lt;/h1&gt;&lt;p&gt;1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="C#" scheme="https://wanglinyong.github.io/tags/C/"/>
    
      <category term="发短信" scheme="https://wanglinyong.github.io/tags/%E5%8F%91%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序日期格式化</title>
    <link href="https://wanglinyong.github.io/2018/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://wanglinyong.github.io/2018/05/11/微信小程序日期格式化/</id>
    <published>2018-05-11T12:15:18.000Z</published>
    <updated>2018-05-14T12:46:48.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-微信小程序util-js下有一个日期格式化函数"><a href="#1-微信小程序util-js下有一个日期格式化函数" class="headerlink" title="1.微信小程序util.js下有一个日期格式化函数"></a>1.微信小程序util.js下有一个日期格式化函数</h2><pre><code>const formatTime = date =&gt; {  var date = new Date(date);    const year = date.getFullYear()  const month = date.getMonth() + 1  const day = date.getDate()  const hour = date.getHours()  const minute = date.getMinutes()  const second = date.getSeconds()  return [year, month, day].map(formatNumber).join(&apos;-&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)}module.exports = {  formatTime: formatTime}</code></pre><p>但是它原来是没有下面的这段代码的  它要求传入的data是一个日期参数，为了方便将日期字符串作为参数传递，将date转换一下（这里的参数date就是日期字符串）：</p><pre><code>var date = new Date(date);  </code></pre><h2 id="2-获取后台的list列表数据后，遍历对其进行日期格式化："><a href="#2-获取后台的list列表数据后，遍历对其进行日期格式化：" class="headerlink" title="2.获取后台的list列表数据后，遍历对其进行日期格式化："></a>2.获取后台的list列表数据后，遍历对其进行日期格式化：</h2><p>引入util.js</p><pre><code>var util = require(&apos;../../utils/util.js&apos;);</code></pre><p>评论列表日期格式化代码：</p><pre><code>  if (res.data.result == 0) {  let comms = res.data.lists  console.log(comms)  for(let c in comms){    let  date = util.formatTime(comms[c].ctime)    comms[c].ctime = date  }  that.setData({    commentList: comms || [],    bookIsBuy: res.data.is_buy  });  setTimeout(function () {    that.setData({      commentLoading: false    });  }, 500);} </code></pre><p>调用util.js中的方法</p><pre><code>let  date = util.formatTime(comms[c].ctime)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-微信小程序util-js下有一个日期格式化函数&quot;&gt;&lt;a href=&quot;#1-微信小程序util-js下有一个日期格式化函数&quot; class=&quot;headerlink&quot; title=&quot;1.微信小程序util.js下有一个日期格式化函数&quot;&gt;&lt;/a&gt;1.微信小程序util
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序Java登录流程</title>
    <link href="https://wanglinyong.github.io/2018/05/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FJava%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"/>
    <id>https://wanglinyong.github.io/2018/05/10/微信小程序Java登录流程/</id>
    <published>2018-05-10T12:48:25.000Z</published>
    <updated>2018-05-10T13:17:06.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、登录流程图"><a href="#一、登录流程图" class="headerlink" title="一、登录流程图"></a>一、登录流程图</h1><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/wx-login.png" alt=""></p><h1 id="二、微信小程序端"><a href="#二、微信小程序端" class="headerlink" title="二、微信小程序端"></a>二、微信小程序端</h1><pre><code>doLogin:function(callback = () =&gt;{}){let that = this;wx.login({  success:function(loginRes){    if(loginRes){      //获取用户信息      wx.getUserInfo({        withCredentials:true,//非必填  默认为true        success:function(infoRes){          console.log(infoRes,&apos;&gt;&gt;&gt;&apos;);          //请求服务端的登录接口          wx.request({            url: api.loginUrl,            data:{              code:loginRes.code,//临时登录凭证              rawData:infoRes.rawData,//用户非敏感信息              signature:infoRes.signature,//签名              encrypteData:infoRes.encryptedData,//用户敏感信息              iv:infoRes.iv//解密算法的向量            },            success:function(res){              console.log(&apos;login success&apos;);              res = res.data;              if(res.result==0){                that.globalData.userInfo = res.userInfo;                wx.setStorageSync(&apos;userInfo&apos;,JSON.stringify(res.userInfo));                wx.setStorageSync(&apos;loginFlag&apos;,res.skey);                console.log(&quot;skey=&quot;+res.skey);                callback();              }else{                that.showInfo(&apos;res.errmsg&apos;);              }            },            fail:function(error){              //调用服务端登录接口失败             // that.showInfo(&apos;调用接口失败&apos;);              console.log(error);            }          });        }      });    }else{    }  }});}</code></pre><p>微信小程序端发起登录请求，携带的参数主要有：</p><pre><code>code:loginRes.code,//临时登录凭证rawData:infoRes.rawData,//用户非敏感信息signature:infoRes.signature,//签名encrypteData:infoRes.encryptedData,//用户敏感信息iv:infoRes.iv//解密算法的向量</code></pre><p>需要的数据主要有：</p><pre><code>result、userInfo和skey</code></pre><p>result用来判断是否登录成功，userInfo是用户的一些信息，保存在缓存中，不用每次都从后台获取，skey是用户登录态标识，也放在缓存中，如果skey存在就直接登录，维护用户的登录状态，具有时效性</p><h1 id="三、Java后台"><a href="#三、Java后台" class="headerlink" title="三、Java后台"></a>三、Java后台</h1><pre><code>@ResponseBody@RequestMapping(&quot;/login&quot;)public Map&lt;String,Object&gt; doLogin(Model model,                                  @RequestParam(value = &quot;code&quot;,required = false) String code,                                  @RequestParam(value = &quot;rawData&quot;,required = false) String rawData,                                  @RequestParam(value = &quot;signature&quot;,required = false) String signature,                                  @RequestParam(value = &quot;encrypteData&quot;,required = false) String encrypteData,                                  @RequestParam(value = &quot;iv&quot;,required = false) String iv){    log.info( &quot;Start get SessionKey&quot; );    Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(  );    System.out.println(&quot;用户非敏感信息&quot;+rawData);    JSONObject rawDataJson = JSON.parseObject( rawData );    System.out.println(&quot;签名&quot;+signature);    JSONObject SessionKeyOpenId = getSessionKeyOrOpenId( code );    System.out.println(&quot;post请求获取的SessionAndopenId=&quot;+SessionKeyOpenId);    String openid = SessionKeyOpenId.getString(&quot;openid&quot; );    String sessionKey = SessionKeyOpenId.getString( &quot;session_key&quot; );    System.out.println(&quot;openid=&quot;+openid+&quot;,session_key=&quot;+sessionKey);    User user = userService.findByOpenid( openid );    //uuid生成唯一key    String skey = UUID.randomUUID().toString();    if(user==null){        //入库        String nickName = rawDataJson.getString( &quot;nickName&quot; );        String avatarUrl = rawDataJson.getString( &quot;avatarUrl&quot; );        String gender  = rawDataJson.getString( &quot;gender&quot; );        String city = rawDataJson.getString( &quot;city&quot; );        String country = rawDataJson.getString( &quot;country&quot; );        String province = rawDataJson.getString( &quot;province&quot; );        user = new User();        user.setUid( openid );        user.setCreateTime( new Date(  ) );        user.setSessionkey( sessionKey );        user.setUbalance( 0 );        user.setSkey( skey );        user.setUaddress( country+&quot; &quot;+province+&quot; &quot;+city );        user.setUavatar( avatarUrl );        user.setUgender( Integer.parseInt( gender ) );        user.setUname( nickName );        user.setUpdateTime( new Date(  ) );        userService.insert( user );    }else {        //已存在        log.info( &quot;用户openid已存在,不需要插入&quot; );    }    //根据openid查询skey是否存在    String skey_redis = (String) redisTemplate.opsForValue().get( openid );    if(StringUtils.isNotBlank( skey_redis )){        //存在 删除 skey 重新生成skey 将skey返回        redisTemplate.delete( skey_redis );    }        //  缓存一份新的        JSONObject sessionObj = new JSONObject(  );        sessionObj.put( &quot;openId&quot;,openid );        sessionObj.put( &quot;sessionKey&quot;,sessionKey );        redisTemplate.opsForValue().set( skey,sessionObj.toJSONString() );        redisTemplate.opsForValue().set( openid,skey );        //把新的sessionKey和oppenid返回给小程序        map.put( &quot;skey&quot;,skey );    map.put( &quot;result&quot;,&quot;0&quot; );    JSONObject userInfo = getUserInfo( encrypteData, sessionKey, iv );    System.out.println(&quot;根据解密算法获取的userInfo=&quot;+userInfo);    userInfo.put( &quot;balance&quot;,user.getUbalance() );    map.put( &quot;userInfo&quot;,userInfo );    return map;}</code></pre><p>获取openid和sessionKey方法</p><pre><code>public static JSONObject getSessionKeyOrOpenId(String code){    //微信端登录code    String wxCode = code;    String requestUrl = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;    Map&lt;String,String&gt; requestUrlParam = new HashMap&lt;String, String&gt;(  );    requestUrlParam.put( &quot;appid&quot;,&quot;你的小程序appId&quot; );//小程序appId    requestUrlParam.put( &quot;secret&quot;,&quot;你的小程序appSecret&quot; );    requestUrlParam.put( &quot;js_code&quot;,wxCode );//小程序端返回的code    requestUrlParam.put( &quot;grant_type&quot;,&quot;authorization_code&quot; );//默认参数    //发送post请求读取调用微信接口获取openid用户唯一标识    JSONObject jsonObject = JSON.parseObject( UrlUtil.sendPost( requestUrl,requestUrlParam ));    return jsonObject;}</code></pre><p>解密用户敏感数据获取用户信息</p><pre><code>public static JSONObject getUserInfo(String encryptedData,String sessionKey,String iv){    // 被加密的数据    byte[] dataByte = Base64.decode(encryptedData);    // 加密秘钥    byte[] keyByte = Base64.decode(sessionKey);    // 偏移量    byte[] ivByte = Base64.decode(iv);    try {        // 如果密钥不足16位，那么就补足.  这个if 中的内容很重要        int base = 16;        if (keyByte.length % base != 0) {            int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0);            byte[] temp = new byte[groups * base];            Arrays.fill(temp, (byte) 0);            System.arraycopy(keyByte, 0, temp, 0, keyByte.length);            keyByte = temp;        }        // 初始化        Security.addProvider(new BouncyCastleProvider());        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;,&quot;BC&quot;);        SecretKeySpec spec = new SecretKeySpec(keyByte, &quot;AES&quot;);        AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;AES&quot;);        parameters.init(new IvParameterSpec(ivByte));        cipher.init( Cipher.DECRYPT_MODE, spec, parameters);// 初始化        byte[] resultByte = cipher.doFinal(dataByte);        if (null != resultByte &amp;&amp; resultByte.length &gt; 0) {            String result = new String(resultByte, &quot;UTF-8&quot;);            return JSON.parseObject(result);        }    } catch (NoSuchAlgorithmException e) {        log.error(e.getMessage(), e);    } catch (NoSuchPaddingException e) {        log.error(e.getMessage(), e);    } catch (InvalidParameterSpecException e) {        log.error(e.getMessage(), e);    } catch (IllegalBlockSizeException e) {        log.error(e.getMessage(), e);    } catch (BadPaddingException e) {        log.error(e.getMessage(), e);    } catch (UnsupportedEncodingException e) {        log.error(e.getMessage(), e);    } catch (InvalidKeyException e) {        log.error(e.getMessage(), e);    } catch (InvalidAlgorithmParameterException e) {        log.error(e.getMessage(), e);    } catch (NoSuchProviderException e) {        log.error(e.getMessage(), e);    }    return null;}</code></pre><h1 id="四、流程"><a href="#四、流程" class="headerlink" title="四、流程"></a>四、流程</h1><p>1.小程序端发起请求并携带主要参数</p><p>2.java后台接到/login请求后，根据code去调用微信接口获取用户唯一标识openid和sessionKey</p><p>3.根据openid查询mysql数据库，判断该用户是否存在，如果不存在将用户非敏感信息和其他初始化数据存入到数据库中，如果已存在，不操作</p><p>4.根据openid查询redis数据库，判断openid对应的skey是否存在，如果存在则删除原来老的skey以及对应的openid和sessionKey</p><p>5.通过uuid生成唯一的skey，用openid做键，skey做值，存入到redis中</p><p>6.然后把skey做键，openid和sessionKey的json串做值也重新存入到redis中</p><p>7.根据解密算法，参数有encryptedData、sessionKey和iv，获取用户信息userInfo,如果userInfo字段不满足需要，可通过userInfo.put( “balance”,user.getUbalance() );添加所需要的字段和值</p><p>8.将微信小程序需要的数据封装到map中，返回给小程序端</p><pre><code>map.put( &quot;skey&quot;,skey );map.put( &quot;result&quot;,&quot;0&quot; );map.put( &quot;userInfo&quot;,userInfo );    return map;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、登录流程图&quot;&gt;&lt;a href=&quot;#一、登录流程图&quot; class=&quot;headerlink&quot; title=&quot;一、登录流程图&quot;&gt;&lt;/a&gt;一、登录流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wiki/w
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信登录" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>web调试代理工具Whistle</title>
    <link href="https://wanglinyong.github.io/2018/05/10/Whistle/"/>
    <id>https://wanglinyong.github.io/2018/05/10/Whistle/</id>
    <published>2018-05-10T12:15:18.000Z</published>
    <updated>2018-05-10T13:14:40.425Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。</p><p>完成https代理请求总共需要5个步骤。</p><h1 id="一、安装Node-js"><a href="#一、安装Node-js" class="headerlink" title="一、安装Node.js"></a>一、安装Node.js</h1><p>下载地址：</p><pre><code>https://nodejs.org/en/</code></pre><p>下载长期支持版：LTS版本</p><p>下载后按步骤进行安装，安装完成后打开cmd命令窗口，执行</p><pre><code>$ node -v</code></pre><p>查看版本号，如果出现版本号即安装正确。</p><pre><code>v8.11.1</code></pre><h1 id="二、安装并启动Whistle"><a href="#二、安装并启动Whistle" class="headerlink" title="二、安装并启动Whistle"></a>二、安装并启动Whistle</h1><h2 id="1-安装Whistle"><a href="#1-安装Whistle" class="headerlink" title="1.安装Whistle"></a>1.安装Whistle</h2><p>打开cmd命令窗口，执行</p><pre><code>$ npm install -g whistle</code></pre><p>npm默认镜像是在国外，有时候安装速度很慢或者出现安装不了的情况，如果无法安装或者安装很慢，可以使用taobao的镜像安装：</p><pre><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org$ cnpm install -g whistle</code></pre><p>或者直接指定镜像安装：</p><pre><code>$ npm install whistle -g --registry=https://registry.npm.taobao.org</code></pre><h2 id="2-启动Whistle"><a href="#2-启动Whistle" class="headerlink" title="2.启动Whistle"></a>2.启动Whistle</h2><p>在cmd命令窗口中执行启动命令：</p><pre><code>w2 start</code></pre><p>停止命令：</p><pre><code>w2 stop</code></pre><p>重启命令：</p><pre><code>w2 restart</code></pre><h2 id="3-访问Whistle-访问网址："><a href="#3-访问Whistle-访问网址：" class="headerlink" title="3.访问Whistle,访问网址："></a>3.访问Whistle,访问网址：</h2><pre><code>127.0.0.1:8899</code></pre><h2 id="三、配置代理"><a href="#三、配置代理" class="headerlink" title="三、配置代理"></a>三、配置代理</h2><p>打开控制面板–&gt;网络和 Internet–&gt;Internet 选项–&gt;连接–&gt;局域网设置</p><p>勾选 为LAN使用代理服务器</p><pre><code>地址(E): 127.0.0.1 端口(T): 8899</code></pre><p>然后确定配置。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle.png" alt=""></p><p>此时就可以配置http请求转发了</p><p>1.打开whistle网页（127.0.0.1:8899）</p><p>2.在Rules规则中有一个默认的Default窗口，在此可以配置转发请求</p><pre><code>www.myurl.com 127.0.0.1:8080</code></pre><p>这样访问www.myurl.com就会访问127.0.0.1:8080这个地址</p><p>如果不在Default窗口配置，也可以自己新建一个，点击Create创建</p><p>这样只能代理非https请求  如果想代理https请求还得下载https安全证书</p><h1 id="四、下载https安全证书"><a href="#四、下载https安全证书" class="headerlink" title="四、下载https安全证书"></a>四、下载https安全证书</h1><p>点击whistle网页上的HTTPS,会出现一个二维码，在二维码上方有一个Download RootCA,点击下载，在二维码下方有一个Capture HTTPS CONNECTs单选框，勾选表明拦截HTTPS请求。如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-2.png" alt=""></p><p>htpps安全证书下载好以后，打开 –&gt;安装证书–&gt;将所有的证书放入下列存储–&gt;受信任的根证书颁发机构。如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-3.png" alt=""></p><p>下载安装完成以后得重新配置转发请求。</p><h2 id="五、配置请求转发"><a href="#五、配置请求转发" class="headerlink" title="五、配置请求转发"></a>五、配置请求转发</h2><p>如果配置成：</p><pre><code>https://www.myurl.com 127.0.0.1:8080</code></pre><p>会报下面的错误</p><pre><code>From: whistle@1.9.10Node: v8.11.1Date: 2018-5-4 09:31:21Error: write EPROTO 101057795:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:openssl\ssl\s23_clnt.c:827:at _errnoException (util.js:1022:11)at WriteWrap.afterWrite [as oncomplete] (net.js:880:14)</code></pre><p>是因为没办法用https请求去访问http服务器，改成下面的配置就OK</p><pre><code>www.myurl.com 127.0.0.1:8080 http://www.myurl.com</code></pre><p>这样访问<a href="https://www.myurl.com" target="_blank" rel="external">https://www.myurl.com</a> 就可以访问127.0.0.1:8080这个地址了。</p><p>记得开启拦截HTTPS：勾选 Capture HTTPS CONNECTs</p><p>点击Network可以查看请求信息，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-4.png" alt=""></p><p>这只是Whistle的冰山一角，了解更多功能请访问：</p><pre><code>http://wproxy.org/whistle/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。&lt;/p&gt;
&lt;p&gt;完成https代理请求总共需要5个步骤。&lt;/p&gt;
&lt;h1 id=&quot;一、安装Node-js&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="whistle" scheme="https://wanglinyong.github.io/categories/whistle/"/>
    
    
      <category term="whistle" scheme="https://wanglinyong.github.io/tags/whistle/"/>
    
      <category term="web调试工具" scheme="https://wanglinyong.github.io/tags/web%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>linux文件服务器httpd开机自启动</title>
    <link href="https://wanglinyong.github.io/2018/04/27/linux%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8httpd%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/27/linux文件服务器httpd开机自启动/</id>
    <published>2018-04-27T12:15:18.000Z</published>
    <updated>2018-04-27T12:15:08.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、相关命令"><a href="#一、相关命令" class="headerlink" title="一、相关命令"></a>一、相关命令</h1><p>1.查看所有系统服务</p><pre><code>systemctl list-units --all --type=service</code></pre><p>2.查询服务状态</p><pre><code>systemctl status httpd.service</code></pre><p>3.查询服务是否为开机启动</p><pre><code>systemctl is-enabled httpd.service</code></pre><p>enabled是 disabled否</p><p>4.设置服务为开机启动状态</p><pre><code>systemctl enable httpd.service</code></pre><p>会自动创建一个系统链接</p><pre><code>Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.</code></pre><p>5.设置服务为开机不启动状态</p><p>systemctl disable httpd.service</p><p>会自动移除系统链接</p><pre><code>Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service.</code></pre><p>二、设置httpd开机自启动</p><pre><code>systemctl enable httpd.service</code></pre><p>重启即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、相关命令&quot;&gt;&lt;a href=&quot;#一、相关命令&quot; class=&quot;headerlink&quot; title=&quot;一、相关命令&quot;&gt;&lt;/a&gt;一、相关命令&lt;/h1&gt;&lt;p&gt;1.查看所有系统服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl list-units --all -
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="httpd" scheme="https://wanglinyong.github.io/tags/httpd/"/>
    
      <category term="文件服务器" scheme="https://wanglinyong.github.io/tags/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux系统mysql的远程访问</title>
    <link href="https://wanglinyong.github.io/2018/04/22/linux%E7%B3%BB%E7%BB%9Fmysql%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <id>https://wanglinyong.github.io/2018/04/22/linux系统mysql的远程访问/</id>
    <published>2018-04-22T02:46:18.000Z</published>
    <updated>2018-04-27T12:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建用户设置权限"><a href="#一、创建用户设置权限" class="headerlink" title="一、创建用户设置权限"></a>一、创建用户设置权限</h1><p>以root身份登录mysql</p><pre><code>[root@ ~]mysql -uroot -p[root@ ~]Enter password: xxxxxx</code></pre><p>创建用户</p><pre><code>mysql&gt;create user &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos;;</code></pre><p>授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>其中’wanglinyong’@’%’是允许该用户在任何主机上远程连接，如果只允许在某一台主机上连接，可指定ip</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;10.xx.xx.x&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>授权之后记得要刷新权限</p><pre><code>mysql&gt;flush privileges;</code></pre><h1 id="二、Navicate远程连接测试"><a href="#二、Navicate远程连接测试" class="headerlink" title="二、Navicate远程连接测试"></a>二、Navicate远程连接测试</h1><p>1.如果连接失败，提示：</p><pre><code>1045-Access denied for user&apos;wanglinyong&apos;@&apos;ip&apos;(using password:YES)</code></pre><p>则表示密码输入错误。</p><p>2.如果提示：</p><pre><code>ERROR 2003(HY000): Can’t connect to MySQL server on xxxxx</code></pre><p>如果服务器是阿里云的，可能没有开通3306端口，要去服务器上添加安全组，增加3360端口即可</p><p>3.Navicate连接成功后，只有information_schema一个数据库</p><p>在linux系统以root用户登录</p><p>先查一下其他数据库是否被删除</p><pre><code>mysql&gt;show databases;</code></pre><p>如果还在，查看下mysql库的用户表</p><pre><code>mysql&gt;select host,user from mysql.user;</code></pre><p>结果如下：</p><pre><code>+----------------+-----------------+| host           | user            |+----------------+-----------------+| %              | wanglinyong     || localhost      | mysql.session   || localhost      | root            |+----------------+-----------------+3 rows in set (0.00 sec)</code></pre><p>说明wanglinyong用户允许在任何远程主机登录</p><p>然后查看，远程登录的用户是否有权限</p><pre><code>mysql&gt; show grants for &apos;wanglinyong&apos;@&apos;%&apos;;</code></pre><p>结果不是</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO &apos;wanglinyong5112&apos;@&apos;%&apos; WITH GRANT OPTION </code></pre><p>说明权限不够，重新授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>刷新权限：</p><pre><code>mysql&gt;flush privileges;</code></pre><p>重新连接应该就OK了！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果还不行, vi /etc/mysql/mysql.conf.d/mysqld.cnf,检查下是否有</p><pre><code>bind-address = 127.0.0.1</code></pre><p>如果有，请把它注释掉（加#号注释）。如果找不到mysqld.cnf,有的可能在 /etc/my.cnf文件内</p><p>保存退出后重启mysql服务</p><pre><code>sudo /etc/init.d/mysql restart</code></pre><p>或者</p><pre><code>systemctl restart mysqld</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、创建用户设置权限&quot;&gt;&lt;a href=&quot;#一、创建用户设置权限&quot; class=&quot;headerlink&quot; title=&quot;一、创建用户设置权限&quot;&gt;&lt;/a&gt;一、创建用户设置权限&lt;/h1&gt;&lt;p&gt;以root身份登录mysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@ ~
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Mysql" scheme="https://wanglinyong.github.io/tags/Mysql/"/>
    
      <category term="远程访问" scheme="https://wanglinyong.github.io/tags/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>JAVA十六进制数据接收与传输</title>
    <link href="https://wanglinyong.github.io/2018/04/17/JAVA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E4%B8%8E%E4%BC%A0%E8%BE%93/"/>
    <id>https://wanglinyong.github.io/2018/04/17/JAVA十六进制数据接收与传输/</id>
    <published>2018-04-17T14:28:56.000Z</published>
    <updated>2018-04-22T02:05:12.243Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。</p><h1 id="一、十六进制转换工具类"><a href="#一、十六进制转换工具类" class="headerlink" title="一、十六进制转换工具类"></a>一、十六进制转换工具类</h1><p>主要包含十六进制字符串转ASCII，ASCII转十六进制字符串以及十六进制字符串转Byte数组等方法：</p><pre><code> /**   * Created by wly on 2018/4/17.  */public class HexConvert {public static String  convertStringToHex(String str){char[] chars = str.toCharArray();StringBuffer hex = new StringBuffer();for(int i = 0; i &lt; chars.length; i++){    hex.append(Integer.toHexString((int)chars[i]));}return hex.toString();}public static String convertHexToString(String hex){StringBuilder sb = new StringBuilder();StringBuilder sb2 = new StringBuilder();for( int i=0; i&lt;hex.length()-1; i+=2 ){    String s = hex.substring(i, (i + 2));               int decimal = Integer.parseInt(s, 16);              sb.append((char)decimal);    sb2.append(decimal);}return sb.toString();}public static byte[] hexStringToBytes(String hexString) {    if (hexString == null || hexString.equals(&quot;&quot;)) {            return null;}        // toUpperCase将字符串中的所有字符转换为大写        hexString = hexString.toUpperCase();        int length = hexString.length() / 2;        // toCharArray将此字符串转换为一个新的字符数组。    char[] hexChars = hexString.toCharArray();    byte[] d = new byte[length];for (int i = 0; i &lt; length; i++) {    int pos = i * 2;    d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos + 1]));}        return d;}    //返回匹配字符private static byte charToByte(char c) {    return (byte) &quot;0123456789ABCDEF&quot;.indexOf(c);}//将字节数组转换为short类型，即统计字符串长度public static short bytes2Short2(byte[] b) {       short i = (short) (((b[1] &amp; 0xff) &lt;&lt; 8) | b[0] &amp; 0xff);    return i;}//将字节数组转换为16进制字符串public static String BinaryToHexString(byte[] bytes) {    String hexStr = &quot;0123456789ABCDEF&quot;;    String result = &quot;&quot;;    String hex = &quot;&quot;;for (byte b : bytes) {    hex = String.valueOf(hexStr.charAt((b &amp; 0xF0) &gt;&gt; 4));    hex += String.valueOf(hexStr.charAt(b &amp; 0x0F));    result += hex + &quot; &quot;;}return result;}public static void main(String[] args) {System.out.println(&quot;======ASCII码转换为16进制======&quot;);String str = &quot;*00007VERSION\\n1$&quot;;System.out.println(&quot;字符串: &quot; + str);String hex = HexConvert.convertStringToHex(str);System.out.println(&quot;====转换为16进制=====&quot; + hex);System.out.println(&quot;======16进制转换为ASCII======&quot;);System.out.println(&quot;Hex : &quot; + hex);System.out.println(&quot;ASCII : &quot; + HexConvert.convertHexToString(hex));byte[] bytes = HexConvert.hexStringToBytes( hex );System.out.println(HexConvert.BinaryToHexString( bytes ));}}</code></pre><h1 id="二、接收数据"><a href="#二、接收数据" class="headerlink" title="二、接收数据"></a>二、接收数据</h1><pre><code>public class UdpReceiverThread {public static void main(String[] args) throws Exception {// 定义一个接收端，并且指定了接收的端口号DatagramSocket socket = new DatagramSocket(6070);while (true) {byte[] buf = new byte[1024*5];// 解析数据包DatagramPacket packet = new DatagramPacket(buf, buf.length);socket.receive(packet);String ip = packet.getAddress().getHostAddress();buf = packet.getData();//将字节数组转换为16进制字符串String hexString = HexConvert.BinaryToHexString( buf );//含有空格，如：2A 30 30 30 30 37 56 45 52 53 49 4F 4E 5C 6E 31 24 hexString =  hexString.replace( &quot; &quot;,&quot;&quot; );//去除空格String asc = HexConvert.convertHexToString( hexString );//转为ASCII,如：*00007VERSION\n1$System.out.println(&quot;收到 &quot; + ip + &quot; 发来的消息：&quot; + asc);}}}</code></pre><h1 id="三、发送数据"><a href="#三、发送数据" class="headerlink" title="三、发送数据"></a>三、发送数据</h1><pre><code>public class UDPSenderThread {public static void main(String[] args) throws Exception {DatagramSocket socket = new DatagramSocket();String serial = &quot;*00007VERSION\\n1$&quot;;//串口字符串String hex = HexConvert.convertStringToHex(serial);//转化为十六进制字符串：2a303030303756455253494f4e5c6e3124byte[] buf = HexConvert.hexStringToBytes( hex );//将十六进制字符串转为字节数组//将数据打包DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(&quot;192.168.11.139&quot;), 6070);socket.send(packet);socket.close();}}</code></pre><h2 id="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"><a href="#在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。" class="headerlink" title="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"></a>在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。&lt;/p&gt;
&lt;h1 id=&quot;一、十六进制转换工具类&quot;&gt;&lt;a href=&quot;#一、十六进制转换工具类&quot; class=&quot;headerlink&quot; title=&quot;一、十
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wanglinyong.github.io/tags/Java/"/>
    
      <category term="十六进制" scheme="https://wanglinyong.github.io/tags/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>BadBoy+Jmeter压力测试</title>
    <link href="https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter压力测试/</id>
    <published>2018-04-10T11:42:48.000Z</published>
    <updated>2018-04-10T11:28:32.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载BadBoy和Jmeter"><a href="#一、下载BadBoy和Jmeter" class="headerlink" title="一、下载BadBoy和Jmeter"></a>一、下载BadBoy和Jmeter</h1><h2 id="1-下载链接"><a href="#1-下载链接" class="headerlink" title="1.下载链接"></a>1.下载链接</h2><p>BadBoy</p><pre><code>http://www.badboy.com.au/download/index</code></pre><p>Jmeter</p><pre><code>http://jmeter.apache.org/download_jmeter.cgi</code></pre><h2 id="2-下载过程如图"><a href="#2-下载过程如图" class="headerlink" title="2.下载过程如图"></a>2.下载过程如图</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-1.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-1.png" alt=""></p><h2 id="3-解压并配置环境变量"><a href="#3-解压并配置环境变量" class="headerlink" title="3.解压并配置环境变量"></a>3.解压并配置环境变量</h2><p>将下载好的BadBoy和Jmeter解压到合适的地方</p><p>配置环境变量</p><pre><code>变量名称：JMETER_HOME变量值：  G:\wly\apache-jmeter-4.0</code></pre><p> 在classpath后面加入：                          </p><pre><code>%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;</code></pre><h2 id="二、录制Jmeter脚本"><a href="#二、录制Jmeter脚本" class="headerlink" title="二、录制Jmeter脚本"></a>二、录制Jmeter脚本</h2><h2 id="1-打开BadBoy"><a href="#1-打开BadBoy" class="headerlink" title="1.打开BadBoy"></a>1.打开BadBoy</h2><p>（1）点击badboy.exe ,打开BadBoy,界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-3.png" alt=""></p><p>（2）输入URL，点击回车开始录制</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-4.png" alt=""></p><p>（3）此时左侧script下多了一条记录，右侧出现调试页面的首页</p><p>然后点击登录，访问首页，然后退出，badboy界面如下，总共有五条记录</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-5.png" alt=""></p><p>（4）接下来导出jmter脚本，点击</p><pre><code>file-&gt;Export to Jmeter</code></pre><p>导出后缀为.jmx的文件</p><h2 id="2-打开Jmeter"><a href="#2-打开Jmeter" class="headerlink" title="2.打开Jmeter"></a>2.打开Jmeter</h2><p>（1）进入Jmeter的bin目录，点击jmeter.bat运行Jmeter</p><p>（2）File-&gt;Open打开刚才导出的jmeter脚本 界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-2.png" alt=""></p><p>（3）Thread Group线程组就是定义并发数量的，step就是压测的步骤。<br>Number of Threads(users) 表示线程数量，如果设置为5000，就是模拟5000个人不断重复刚才的 首页-&gt;登录-&gt;首页-&gt;退出 操作</p><p>Ram-Up Period(in seconds)表示间隔时间</p><p>Loop Count 表示循环次数</p><p>压力测试：线程数越多压力越大，间隔时间越短压力越大</p><p>（4）添加监听器</p><p>添加聚合报告、查看结果树和用表格查看，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-3.png" alt=""></p><p>（5）运行</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-4.png" alt=""></p><p>（6）查看结果</p><p>查看结果树，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-5.png" alt=""></p><p>聚合报告，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-6.png" alt=""></p><p>表格查看，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;a href=&quot;#一、下载BadBoy和Jmeter&quot; class=&quot;headerlink&quot; title=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;/a&gt;一、下载BadBoy和Jmeter&lt;/h1&gt;&lt;h2 id=&quot;1-下载链
      
    
    </summary>
    
      <category term="性能测试" scheme="https://wanglinyong.github.io/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="https://wanglinyong.github.io/tags/Jmeter/"/>
    
      <category term="BadBoy" scheme="https://wanglinyong.github.io/tags/BadBoy/"/>
    
  </entry>
  
  <entry>
    <title>linux系统搭建文件服务器</title>
    <link href="https://wanglinyong.github.io/2018/04/06/linux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/06/linux系统搭建文件服务器/</id>
    <published>2018-04-06T02:48:23.000Z</published>
    <updated>2018-04-10T11:26:35.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装-httpd-服务"><a href="#一、安装-httpd-服务" class="headerlink" title="一、安装 httpd 服务"></a>一、安装 httpd 服务</h2><pre><code>yum install httpd</code></pre><p>查看版本号</p><pre><code>httpd -version</code></pre><h2 id="二、启动-httpd-服务"><a href="#二、启动-httpd-服务" class="headerlink" title="二、启动 httpd 服务"></a>二、启动 httpd 服务</h2><pre><code>service httpd start</code></pre><h2 id="三、容易出现的问题"><a href="#三、容易出现的问题" class="headerlink" title="三、容易出现的问题"></a>三、容易出现的问题</h2><p>1.防火墙未开放端口</p><pre><code>开启端口：firewall-cmd --zone=public --add-port=8989/tcp --permanent重启防火墙：firewall-cmd --reload 查看已开放端口：firewall-cmd --list-ports</code></pre><p>2.端口被占用</p><pre><code>更改端口号</code></pre><p>修改配置文件，默认路径是</p><pre><code>/etc/httpd/conf/httpd.conf </code></pre><p>主要修改以下内容</p><pre><code>Listen 80 --&gt; Listen 8987     #监听端口#ServerName www.example.com:80 --&gt; ServerName 192.168.120.132:8987    #服务名称ip:portDocumentRoot &quot;/var/www/html&quot; --&gt;  DocumentRoot &quot;/home/profile&quot;   #文件根目录&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径1&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径2</code></pre><p>3.出现apache CentOS Permission denied: AH00072</p><p>关闭SELINUX</p><pre><code>setenforce 0</code></pre><p>修改配置文件</p><pre><code>vim /etc/selinux/configSELINUX=enforcing 改成--&gt; SELINUX=disabled</code></pre><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><pre><code>service httpd start</code></pre><p>停止服务</p><pre><code>service httpd stop</code></pre><h2 id="五、远程访问"><a href="#五、远程访问" class="headerlink" title="五、远程访问"></a>五、远程访问</h2><p>在浏览器中输入 ip:port 即可访问设置的 /home/profile 目录;</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ftp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、安装-httpd-服务&quot;&gt;&lt;a href=&quot;#一、安装-httpd-服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装 httpd 服务&quot;&gt;&lt;/a&gt;一、安装 httpd 服务&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;yum install httpd

      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux系统安装git</title>
    <link href="https://wanglinyong.github.io/2018/03/31/linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85git/"/>
    <id>https://wanglinyong.github.io/2018/03/31/linux系统安装git/</id>
    <published>2018-03-31T06:36:00.000Z</published>
    <updated>2018-04-10T11:24:32.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装git依赖包"><a href="#一、安装git依赖包" class="headerlink" title="一、安装git依赖包"></a>一、安装git依赖包</h1><pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</code></pre><h1 id="二、删除已有的git"><a href="#二、删除已有的git" class="headerlink" title="二、删除已有的git"></a>二、删除已有的git</h1><pre><code>yum remove git</code></pre><h1 id="三、下载git源码"><a href="#三、下载git源码" class="headerlink" title="三、下载git源码"></a>三、下载git源码</h1><p>切换到你的包文件存放目录下</p><pre><code>　cd /home/softs</code></pre><p>下载git安装包</p><pre><code>wget https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz</code></pre><p>解压git安装包</p><pre><code>tar -zxvf git-2.8.3.tar.gzcd git-2.8.3</code></pre><p>配置git安装路径</p><pre><code>./configure prefix=/usr/local/git/</code></pre><p>编译并且安装</p><pre><code>make &amp;&amp; make install</code></pre><h1 id="四、将git指令添加到bash中"><a href="#四、将git指令添加到bash中" class="headerlink" title="四、将git指令添加到bash中"></a>四、将git指令添加到bash中</h1><pre><code>vi /etc/profile</code></pre><p>在最后一行加入</p><pre><code>export PATH=$PATH:/usr/local/git/bin</code></pre><p>让该配置文件立即生效</p><pre><code>source /etc/profile</code></pre><p>查看git版本号</p><pre><code>git --version</code></pre><p>git已经安装完毕 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装git依赖包&quot;&gt;&lt;a href=&quot;#一、安装git依赖包&quot; class=&quot;headerlink&quot; title=&quot;一、安装git依赖包&quot;&gt;&lt;/a&gt;一、安装git依赖包&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install curl-devel expat-d
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Git" scheme="https://wanglinyong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>DES加密解密</title>
    <link href="https://wanglinyong.github.io/2018/03/24/DES%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>https://wanglinyong.github.io/2018/03/24/DES加密解密/</id>
    <published>2018-03-24T11:39:28.000Z</published>
    <updated>2018-03-24T11:40:53.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h1><p>我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！</p><p>查看日志后发现每次加密的结果都不同，后来百度得知是DES在linux和windows系统的加密算法不一致导致的。主要是DES补位导致，把补位规则改成”DES/ECB/PKCS5Padding”即可。</p><h1 id="二、DES加密解密代码"><a href="#二、DES加密解密代码" class="headerlink" title="二、DES加密解密代码"></a>二、DES加密解密代码</h1><pre><code>package wang.dreamland.www.common;import java.security.Key;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.apache.commons.codec.binary.Base64;public class MyDes {/** * 加密数据 * @param encryptString * @param encryptKey * @return * @throws Exception */public static String encryptDES(String encryptString, String encryptKey) throws Exception {    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getKey(encryptKey), &quot;DES&quot;));    byte[] encryptedData = cipher.doFinal(encryptString.getBytes(&quot;UTF-8&quot;));    return Base64.encodeBase64String(encryptedData);}/** * key  不足8位补位 * @param */public static byte[] getKey(String keyRule) {    Key key = null;    byte[] keyByte = keyRule.getBytes();    // 创建一个空的八位数组,默认情况下为0    byte[] byteTemp = new byte[8];    // 将用户指定的规则转换成八位数组    for (int i = 0; i &lt; byteTemp.length &amp;&amp; i &lt; keyByte.length; i++) {        byteTemp[i] = keyByte[i];    }    key = new SecretKeySpec(byteTemp, &quot;DES&quot;);    return key.getEncoded();}/*** * 解密数据 * @param decryptString * @param decryptKey * @return * @throws Exception */public static String decryptDES(String decryptString, String decryptKey) throws Exception {    byte[] sourceBytes = Base64.decodeBase64(decryptString);    Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS5Padding&quot;);    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(getKey(decryptKey), &quot;DES&quot;));    byte[] decoded = cipher.doFinal(sourceBytes);    return new String(decoded, &quot;UTF-8&quot;);}public static void main(String[] args) throws Exception {    String clearText = &quot;wanglinyong@163.com&quot;;    String key = &quot;123456&quot;;//密钥    System.out.println(&quot;明文：&quot;+clearText+&quot;\n密钥：&quot;+key);    String encryptText = encryptDES(clearText, key);    System.out.println(&quot;加密后：&quot;+encryptText);    String decryptText = decryptDES(encryptText, key);    System.out.println(&quot;解密后：&quot;+decryptText);}}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、场景&quot;&gt;&lt;a href=&quot;#一、场景&quot; class=&quot;headerlink&quot; title=&quot;一、场景&quot;&gt;&lt;/a&gt;一、场景&lt;/h1&gt;&lt;p&gt;我将打包好的war包放到linux系统运行时，其他一切正常，唯有登陆的时候怎么都登不上，提示密码错误！&lt;/p&gt;
&lt;p&gt;查看日
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux系统使用Gogs搭建自己的git服务</title>
    <link href="https://wanglinyong.github.io/2018/03/24/linux%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Gogs%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84git%E6%9C%8D%E5%8A%A1/"/>
    <id>https://wanglinyong.github.io/2018/03/24/linux系统使用Gogs搭建自己的git服务/</id>
    <published>2018-03-24T07:25:42.000Z</published>
    <updated>2018-04-10T11:29:24.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装Gogs服务"><a href="#一、安装Gogs服务" class="headerlink" title="一、安装Gogs服务"></a>一、安装Gogs服务</h1><h2 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户"></a>1.新建用户</h2><p>Gogs默认以 git 用户运行（你不会想用一个能修改 ssh 配置的程序以 root 用户运行吧）。 </p><pre><code>sudo adduser git  # 新建git用户。 </code></pre><p> 以 git 用户登录，到 git 用户的主目录中新建好 .ssh 文件夹。(新建git用户后我的出现在/home目录下)</p><pre><code>su gitcd /home/gitmkdir .ssh</code></pre><h2 id="2-下载安装包并解压"><a href="#2-下载安装包并解压" class="headerlink" title="2.下载安装包并解压"></a>2.下载安装包并解压</h2><p>我使用的是预编译的二进制包。下载链接</p><pre><code>https://gogs.io/docs/installation/install_from_binary</code></pre><p>查看linux系统是32位还是64位系统命令，32位选择386，64位选择amd64</p><pre><code>getconf LONG_BIT</code></pre><p>需要从源码编译的话，请参考一般 Go 语言项目的编译。下载后解包到你喜欢的地方，例如 /usr/share/gogs/ 或者 /home/git/gogs/ 。文件夹的内容如下。</p><pre><code>gogs  LICENSE  public  README.md  README_ZH.md  scripts  templates</code></pre><h2 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3.创建数据库"></a>3.创建数据库</h2><p>创建database,名称为gogs</p><pre><code>CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;GRANT ALL PRIVILEGES ON gogs.* TO &apos;root&apos;@&apos;localhost&apos; identified by &apos;root&apos;;FLUSH PRIVILEGES;</code></pre><p>在 Gogs 目录的 scripts/mysql.sql 文件是数据库初始化文件。执行</p><pre><code>mysql -u root -p &lt; scripts/mysql.sql （需要输入密码）即可初始化好数据库。</code></pre><p>然后登录 MySQL 创建一个新用户 gogs，并将数据库 gogs 的所有权限都赋予该用户。</p><pre><code>$ mysql -u root -p&gt; # （输入密码）&gt; create user &apos;gogs&apos;@&apos;localhost&apos; identified by &apos;密码&apos;;&gt; grant all privileges on gogs.* to &apos;gogs&apos;@&apos;localhost&apos;;&gt; flush privileges;&gt; exit;</code></pre><h2 id="4-运行-gogs-web"><a href="#4-运行-gogs-web" class="headerlink" title="4.运行 gogs web"></a>4.运行 gogs web</h2><p>进入gogs目录下，并运行gogs</p><pre><code>cd /home/git/gogs/gogsnohup ./gogs web &amp; tail -f nohup.out #并打印日志nohup ./gogs web &amp; #仅后台运行 ./gogs web  #前台运行</code></pre><p>然后访问 <a href="http://服务器IP:3000/" target="_blank" rel="external">http://服务器IP:3000/</a> 来进行安装，填写好表单之后提交就可以了。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.如果访问网页失败，可能防火墙没有打开3000的端口，防火墙相关配置请查看linux系统相关服务这篇博客。</p><p>2.还有0.6.9.0903 Beta 版本有个 bug，允许在关闭注册的情况下不添加管理员，这样安装完成之后将没有任何用户可以登录。所以请务必在安装界面指定一个管理员帐号。</p><h2 id="5-相关配置"><a href="#5-相关配置" class="headerlink" title="5.相关配置"></a>5.相关配置</h2><p>1.配置文件位于 Gogs 目录的 custom/conf/app.ini ，是 INI 格式的文本文件。详细的配置解释和默认值请参考官方文档 ，其中关键的配置大概是下面这些。</p><pre><code>RUN_USER 默认是 git ，指定 Gogs 以哪个用户运行ROOT 所有仓库的存储根路径PROTOCOL 如果你使用 nginx 反代的话请使用 http ，如果直接裸跑对外服务的话随意DOMAIN 域名。会影响 SSH clone 地址ROOT_URL 完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址HTTP_ADDR 监听地址，使用 nginx 的话建议 127.0.0.1 ，否则 0.0.0.0 也可以HTTP_PORT 监听端口，默认 3000INSTALL_LOCK 锁定安装页面Mailer 相关的选项</code></pre><p>其中，Mailer 可以使用 Mailgun 的免费邮件发送服务，将 Mailgun 的 SMTP 配置填入到配置中就好。</p><p>2.附app.ini(192.168.120.132为我使用的虚拟机ip)</p><pre><code>APP_NAME = GogsRUN_USER = gitRUN_MODE = prod[database]DB_TYPE  = mysqlHOST     = 127.0.0.1:3306NAME     = gogsUSER     = gogsPASSWD   = gogsSSL_MODE = disablePATH     = data/gogs.db[repository]ROOT = /home/git/gogs-repositories[server]DOMAIN           = 192.168.120.132HTTP_PORT        = 3000ROOT_URL         = http://192.168.120.132:3000/DISABLE_SSH      = falseSSH_PORT         = 1111START_SSH_SERVER = trueOFFLINE_MODE     = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL     = falseDISABLE_REGISTRATION   = falseENABLE_CAPTCHA         = trueREQUIRE_SIGNIN_VIEW    = false[picture]DISABLE_GRAVATAR        = falseENABLE_FEDERATED_AVATAR = true[session]PROVIDER = file[log]MODE      = fileLEVEL     = InfoROOT_PATH = /home/git/gogs/gogs/log[security]INSTALL_LOCK = trueSECRET_KEY   = YfaCLhKinQVLlb7</code></pre><h2 id="6-nginx-反向代理"><a href="#6-nginx-反向代理" class="headerlink" title="6.nginx 反向代理"></a>6.nginx 反向代理</h2><p>在 /etc/nginx/sites-available 中新建一个文件，把以下内容写入文件中。</p><pre><code>server {server_name 域名或IP;listen 80; # 或者 443，如果你使用 HTTPS 的话# ssl on; 是否启用加密连接# 如果你使用 HTTPS，还需要填写 ssl_certificate 和 ssl_certificate_keylocation / { # 如果你希望通过子路径访问，此处修改为子路径，注意以 / 开头并以 / 结束    proxy_pass http://127.0.0.1:3000/;}}</code></pre><p>然后进入 /etc/nginx/sites-enabled 中，执行 </p><pre><code>ln -s ../sites-available/配置文件名   #启用这个配置文件。</code></pre><p>最后重启 nginx 就好了，Centos下是</p><pre><code>service nginx restart   #重启/etc/init.d/nginx stop  #停止/etc/init.d/nginx start #开始</code></pre><p>Ubuntu 下是 </p><pre><code>sudo service nginx restart 。</code></pre><h2 id="7-开机自动重启等脚本"><a href="#7-开机自动重启等脚本" class="headerlink" title="7.开机自动重启等脚本"></a>7.开机自动重启等脚本</h2><p>在scripts/文件夹下有关于多个系统的服务脚本：</p><pre><code>autoboot.sh  build_freebsd.sh  build_linux64.sh  build.sh  init launchd  mysql.sql  README  supervisor  systemd  windows</code></pre><p>其中init,systemd以及windows目录分别为linux、Windows下服务脚本。<br>在此仅以CentOS为例:</p><p>复制scripts/init/centos/gogs到/etc/init.d/目录下:</p><pre><code>sudo cp scripts/init/centos/gogs /etc/init.d/</code></pre><p>切换到/etc/init.d/目录为脚本赋予可执行权限</p><pre><code>sudo chmod +x gogs</code></pre><p>更改gogs脚本内关于GOGS_HOME目录位置的设置(这儿使用vim编辑)</p><pre><code>GOGS_HOME=/data/gogs/gogs</code></pre><p>使用服务管理命令管理服务</p><pre><code>sudo service gogs start/stop/restart/status</code></pre><p>配置Gogs开机自启动</p><pre><code>sudo chkconfig --add gogs</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装Gogs服务&quot;&gt;&lt;a href=&quot;#一、安装Gogs服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装Gogs服务&quot;&gt;&lt;/a&gt;一、安装Gogs服务&lt;/h1&gt;&lt;h2 id=&quot;1-新建用户&quot;&gt;&lt;a href=&quot;#1-新建用户&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Git" scheme="https://wanglinyong.github.io/tags/Git/"/>
    
      <category term="Gogs" scheme="https://wanglinyong.github.io/tags/Gogs/"/>
    
  </entry>
  
</feed>
