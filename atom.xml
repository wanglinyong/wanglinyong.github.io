<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wang&#39;s Blog</title>
  
  
  <link href="/wanglinyong.github.io/atom.xml" rel="self"/>
  
  <link href="https://wanglinyong.github.io/"/>
  <updated>2018-09-08T03:30:30.050Z</updated>
  <id>https://wanglinyong.github.io/</id>
  
  <author>
    <name>WangLinYong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务（二）：基于可靠消息的分布式事务</title>
    <link href="https://wanglinyong.github.io/2018/08/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://wanglinyong.github.io/2018/08/31/分布式事务（二）/</id>
    <published>2018-08-31T12:15:09.000Z</published>
    <updated>2018-09-08T03:30:30.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目使用技术"><a href="#项目使用技术" class="headerlink" title="项目使用技术"></a>项目使用技术</h2><p>springboot、dubbo、zookeeper、定时任务</p><h2 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h2><p>maven父子工程：</p><p>父工程：consis</p><p>子工程：api-service、order、product、message</p><p>api-service:该项目主要是提供接口调用的，还包含实体类、枚举等一些通用内容</p><p>order:该项目是专门处理订单相关操作的系统</p><p>product:该项目是专门处理产品相关操作的系统</p><p>message:该项目是提供消息服务的系统，好包括定时任务</p><p>它们的依赖关系如下图：</p><p><img src="https://images.gitbook.cn/a181d460-acf7-11e8-afe5-6ba901a27e1b" alt="enter image description here"></p><p>根据上一篇的原理分别介绍下各个系统的实现</p><h2 id="二、order订单系统"><a href="#二、order订单系统" class="headerlink" title="二、order订单系统"></a>二、order订单系统</h2><p><strong>核心代码：</strong></p><pre><code>@Override@Transactionalpublic void add(Orders order) {    String messageBody = JSONObject.toJSONString( order );    //添加消息到数据库    String messageId = transactionMessageService.savePreparMessage(order.getMessageId(), messageBody, Constant.ORDER_QUEUE_NAME );    log.info(&quot;&gt;&gt;&gt; 预发送消息,消息编号:{}&quot;, messageId);    boolean flag = false;    boolean success = false;    try{        Orders orders = orderDao.saveAndFlush( order );        //int i = 1/0 ;        log.info(&quot;&gt;&gt;&gt; 插入订单,订单编号:{}&quot;, orders.getId());        flag = true;    }catch (Exception e){        transactionMessageService.delete( messageId );        log.info(&quot;&gt;&gt;&gt; 业务执行异常删除消息,消息编号:{}&quot;, messageId, e);        throw new RuntimeException( &quot;&gt;&gt;&gt; 创建订单失败&quot; );    }finally {        if(flag){            try {                transactionMessageService.confirmAndSend( messageId );                success = true;                log.info(&quot;&gt;&gt;&gt; 确认并且发送消息到实时消息中间件,消息编号:{}&quot;, messageId);            }catch (Exception e){                log.error(&quot;&gt;&gt;&gt; 消息确认异常,消息编号:{}&quot;, messageId, e);                if(!success){                    transactionMessageService.delete( messageId );                    throw new RuntimeException( &quot;&gt;&gt;&gt; 确认消息异常，创建订单失败&quot; );                }            }        }    }}</code></pre><ul><li>插入订单表之前，首先创建预发送消息，保存到事务消息表中，此时消息状态为：未发送</li><li>插入订单，如果插入订单失败则将事务消息表中预发送消息删除</li><li>插入订单成功后，修改消息表预发送消息状态为发送中，并发送消息至mq</li><li>如果发送消息失败，则订单回滚并删除事务消息表消息</li></ul><h2 id="三、message消息系统"><a href="#三、message消息系统" class="headerlink" title="三、message消息系统"></a>三、message消息系统</h2><p><strong>核心代码一：</strong></p><pre><code>@Overridepublic void sendMessageToMessageQueue(String queueName,final String messageBody) {    jmsTemplate.convertAndSend( queueName,messageBody );    log.info(&quot;&gt;&gt;&gt; 发送消息到mq 队列:{},消息内容:{}&quot;, queueName, messageBody);}</code></pre><ul><li>主要是activemq生产者讲消息发送至MQ消息中间件</li></ul><p><strong>核心代码二：</strong></p><pre><code>/** * 定时重发消息（每分钟） */@Scheduled(cron = &quot;0 */1 * * * ?&quot;)public void    handler(){    //查询transaction_message表中已发送但未被删除的消息    List&lt;TransactionMessage&gt; list = transactionMessageService.queryRetryList( Constant.MESSAGE_UNDEAD, maxTimeOut, Constant.MESSAGE_SENDING );    if(list!=null &amp;&amp; list.size() &gt; 0){        for (TransactionMessage message:list){            try {                transactionMessageService.retry( message.getMessageId() );            } catch (Exception e) {                log.warn(&quot;&gt;&gt;&gt; 消息不存在,可能已经被消费,消息编号:{}&quot;, message.getMessageId());            }        }    }}/** * 定时通知工作人员（每隔5分钟） */@Scheduled(cron = &quot;0 */5 * * * ?&quot;)public void    advance(){    List&lt;Long&gt; messages = transactionMessageService.queryDeadList();    log.warn(&quot;&gt;&gt;&gt; 共有:{}条消息需要人工处理&quot;, messages.size());    String ids = JSONObject.toJSONString( messages );    //发邮件或者是发送短信通知工作人员处理}</code></pre><ul><li>定时重发消息</li><li>定时将死亡的消息通知给工作人员，进行人工补偿操作</li></ul><h2 id="四、product产品系统"><a href="#四、product产品系统" class="headerlink" title="四、product产品系统"></a>四、product产品系统</h2><p><strong>核心代码：</strong></p><pre><code>@Transactional@JmsListener( destination = Constant.ORDER_QUEUE_NAME)public void    receiveQueue(String msg){    boolean flag = false;    Orders orders = JSONObject.parseObject( msg, Orders.class );    log.info(&quot;&gt;&gt;&gt; 接收到mq消息队列，消息编号:{} ,消息内容:{}&quot;, orders.getMessageId(), msg);    TransactionMessage transactionMessage = transactionMessageService.findByMessageId( orders.getMessageId() );    try {        //保证幂等性        if(transactionMessage!=null){            List&lt;OrderDetail&gt; list = orders.getList();            for(OrderDetail detail : list){                Product product = productService.findById( detail.getId() );                Long skuNum = product.getProductSku() - detail.getNum();                if(skuNum &gt;= 0){                    product.setProductSku( skuNum );                    productService.update( product );                }else {                    throw new Exception( &quot;&gt;&gt;&gt; 库存不足,修改库存失败！&quot; );                }            }            //int i = 1 /0 ;            flag = true;        }    }catch (Exception e){        e.printStackTrace();        throw new RuntimeException( e );    }finally {        if(flag){            transactionMessageService.delete( orders.getMessageId() );            DbLog dbLog = dbLogService.findByMesageId( orders.getMessageId() );            if(dbLog!=null){                dbLog.setState( &quot;1&quot; );//已处理成功                dbLogService.update( dbLog );            }            log.info(&quot;&gt;&gt;&gt; 业务执行成功删除消息! messageId:{}&quot;, orders.getMessageId());        }    }}</code></pre><ul><li>从mq消息中间件中监听并消费消息，将json消息转为订单对象</li><li>根据消息编号查询该消息是否已被消费，保证幂等性</li><li>如果消息未被消费（即存在此消息），则产品表扣减库存；如果已经消费（不存在此消息），则不做处理</li><li>产品表扣减库存成功，则删除此消息，如果待处理消息日志表中有此消息，则更改状态为1，表示已处理；扣减失败，则不做处理</li></ul><p>该项目源码已上传至github和码云，链接如下，<strong>希望喜欢的朋友都能给个star支持一下！谢谢~</strong></p><p>github链接</p><pre><code>https://github.com/wanglinyong/consis</code></pre><p>码云链接</p><pre><code>https://gitee.com/wanglinyong/consis</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目使用技术&quot;&gt;&lt;a href=&quot;#项目使用技术&quot; class=&quot;headerlink&quot; title=&quot;项目使用技术&quot;&gt;&lt;/a&gt;项目使用技术&lt;/h2&gt;&lt;p&gt;springboot、dubbo、zookeeper、定时任务&lt;/p&gt;
&lt;h2 id=&quot;一、项目结构&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="分布式事务" scheme="https://wanglinyong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务（一）</title>
    <link href="https://wanglinyong.github.io/2018/08/27/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wanglinyong.github.io/2018/08/27/分布式事务（一）/</id>
    <published>2018-08-27T11:08:22.000Z</published>
    <updated>2018-09-08T03:28:29.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据库事务"><a href="#一、数据库事务" class="headerlink" title="一、数据库事务"></a>一、数据库事务</h2><p>在介绍分布式事务之前，先简单了解下数据库事务。</p><p><strong>数据库事务(Database Transaction) :</strong>是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p><p>事务具有ACID四个特性：</p><p>1、原子性(Atomic)：事务必须是原子工作单元,对于其修改数据，要么全部成功，要么全部失败。</p><p>2、一致性(Consistent):事务在完成时，必须使所有的数据都保持一致状态。</p><p>3、隔离性(Insulation):由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。</p><p>4、持久性(Duration):事务完成之后，它对于系统的影响是永久性的。</p><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><p>在分布式系统中，不止使用一个数据库，比如订单系统使用db_order数据库，产品系统使用的是db_product数据库，在订单系统中只能保证订单相关操作的事务，在产品系统中只能保证产品相关操作的事务。比如：如果在订单系统中进行生成订单、扣减库存的业务，如果出现异常，那么创建订单的事务会回滚，而扣减库存的事务则不会，因为本地事务是不能夸数据库的。跨库的事务就属于分布式事务。</p><p>把分布式系统中两个相关操作看成是一个单元，比如创建订单和修改库存的操作，该单元要么一起成功，要么一起失败，这就是分布式事务。</p><p>关于分布式事务你不得不知的两个理论：</p><h3 id="1、CAP定理"><a href="#1、CAP定理" class="headerlink" title="1、CAP定理"></a>1、CAP定理</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，WEB服务无法同时满足以下3个特性：</p><ul><li><p>一致性(Consistency) ： 在分布式系统中数据一旦更新，所有数据变动都是同步的</p></li><li><p>可用性(Availability) ： 好的响应性能，每个操作都必须有预期的响应结束</p></li><li><p>分区容错性(Partition tolerance) ： 在网络分区的情况下，即使出现单个节点无法可用，系统依然正常对外提供服务</p></li></ul><p>首先在分布式系统中，横向扩展策略依赖于数据分区，所以一般会在一致性和可用性上做出牺牲。</p><h3 id="2、BASE理论"><a href="#2、BASE理论" class="headerlink" title="2、BASE理论"></a>2、BASE理论</h3><p>BASE理论中的三个特性：</p><ul><li><p>Basically Available（基本可用）</p></li><li><p>Soft state（软状态）</p></li><li><p>Eventually consistent（最终一致性）</p></li></ul><p>三个特性分别指的是：</p><p>（1）基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。</p><p>（2）软状态，和硬状态对应，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。</p><p>（3）最终一致性强调的是系统所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要试试保证系统数据的强一致性。 </p><p>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><h2 id="三、分布式事务解决方案"><a href="#三、分布式事务解决方案" class="headerlink" title="三、分布式事务解决方案"></a>三、分布式事务解决方案</h2><p>主要介绍目前主流的两种分布式事务解决方案：</p><h3 id="1、TCC-补偿型事务解决方案"><a href="#1、TCC-补偿型事务解决方案" class="headerlink" title="1、TCC-补偿型事务解决方案"></a>1、TCC-补偿型事务解决方案</h3><p>TCC指的是Try(尝试)、Confirm（确认）、Cancle（取消）,其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li><p>Try 阶段主要是对业务系统做检测及资源预留</p></li><li><p>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</p></li><li><p>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</p></li></ul><p>举个例子，假入 Bob 要向 Smith 转账，思路大概是：</p><p>1、首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</p><p>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</p><p>3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</p><p>优点： 跟两阶段提交（2PC）比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</p><p>缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h3 id="2、基于可靠消息的最终一致性解决方案"><a href="#2、基于可靠消息的最终一致性解决方案" class="headerlink" title="2、基于可靠消息的最终一致性解决方案"></a>2、基于可靠消息的最终一致性解决方案</h3><p>举例说明：订单系统创建订单成功后、产品系统扣减相应库存</p><p><strong>订单系统流程图如下：</strong></p><p><img src="https://images.gitbook.cn/f986cf50-a9d5-11e8-95af-1d569340e767" alt="enter image description here"></p><p>1.创建订单之前，创建预发送消息，保存到消息表中，此时消息状态为：未发送</p><p>2.创建订单，如果创建订单失败则将消息表预发送消息删除</p><p>3.创建订单成功后，修改消息表预发送消息状态为发送中，并发送消息至mq</p><p>4.如果发送消息失败，则订单回滚并删除消息表消息；发送成功则万事大吉</p><p><strong>产品系统流程图如下：</strong></p><p><img src="https://images.gitbook.cn/e1b4c660-a9d1-11e8-93ff-7b60c899eed0" alt="enter image description here"></p><p>1.从mq消息中间件中监听并消费消息，将json消息转为订单对象</p><p>2.根据消息编号查询该消息是否已被消费，保证幂等性</p><p>3.如果消息未被消费（即存在此消息），则产品表扣减库存；如果已经消费（不存在此消息），则不做处理</p><p>4.产品表扣减库存成功，则删除此消息；扣减失败，则不做处理</p><p>5.定时任务会定时扫描消息表中超时未被消费的消息，然后尝试重发，如果超过最大重试次数后仍未被消费，则记录日志并通知工作人员进行人工补偿操作</p><p>基于可靠消息的分布式事务虽然不能保证结果的强一致，但是可以通过可靠消息使得结果最终一致</p><p>下一节将给出基于可靠消息的分布式事务demo源码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、数据库事务&quot;&gt;&lt;a href=&quot;#一、数据库事务&quot; class=&quot;headerlink&quot; title=&quot;一、数据库事务&quot;&gt;&lt;/a&gt;一、数据库事务&lt;/h2&gt;&lt;p&gt;在介绍分布式事务之前，先简单了解下数据库事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据库事务(Datab
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="分布式事务" scheme="https://wanglinyong.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>dubbo快速入门</title>
    <link href="https://wanglinyong.github.io/2018/08/21/dubbo/"/>
    <id>https://wanglinyong.github.io/2018/08/21/dubbo/</id>
    <published>2018-08-21T10:23:48.000Z</published>
    <updated>2018-09-08T03:26:36.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、dubbo基本原理"><a href="#一、dubbo基本原理" class="headerlink" title="一、dubbo基本原理"></a>一、dubbo基本原理</h2><p> <strong>dubbo架构图如下：</strong></p><p><img src="https://images.gitbook.cn/e0e417a0-a4e9-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><p>节点角色说明</p><p><img src="https://images.gitbook.cn/5c2ee5c0-a4ea-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><p>调用关系说明:</p><p>0.服务容器负责启动，加载，运行服务提供者。</p><p>1.服务提供者在启动时，向注册中心注册自己提供的服务。</p><p>2.服务消费者在启动时，向注册中心订阅自己所需的服务。</p><p>3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p>4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p>5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p><p>具体详细内容请参加dubbo官方文档</p><pre><code>http://dubbo.apache.org/en-us/</code></pre><h2 id="二、入门demo简介"><a href="#二、入门demo简介" class="headerlink" title="二、入门demo简介"></a>二、入门demo简介</h2><p>该demo包含三个项目，分别是：</p><p>服务提供端项目：provider</p><p>服务消费端项目：consumer</p><p>共用服务接口项目：api</p><p>依赖关系如图：</p><p><img src="https://images.gitbook.cn/fa498740-a4ec-11e8-8a5b-85d5618fe6ba" alt="enter image description here"></p><p>api项目是一个jar项目，将生成的jar打包到maven仓库，作为provider和consumer项目的依赖导入。</p><h2 id="三、dubbo-远程调用（RPC）具体实现"><a href="#三、dubbo-远程调用（RPC）具体实现" class="headerlink" title="三、dubbo-远程调用（RPC）具体实现"></a>三、dubbo-远程调用（RPC）具体实现</h2><h3 id="1、启动zookeeper"><a href="#1、启动zookeeper" class="headerlink" title="1、启动zookeeper"></a>1、启动zookeeper</h3><p>在启动服务提供者项目之前要先启动zookeeper,因为我们需要把服务提供方注册到zookeeper中，然后才能被服务消费方发现并调用。</p><p>关于zookeeper这里不做详细介绍了，简单概括就是分布式服务治理框架，用于服务注册与发现，实现远程调用功能等。</p><ul><li><p>zookeeper下载</p><p>  <a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a></p></li><li><p>解压并修改配置</p></li></ul><p>zookeeper下载完成后解压到合适目录，然后进入到zookeeper的conf目录，找到zoo_sample.cfg文件将其重命名为zoo.cfg，然后打开该文件，<br>将其中的dataDir和dataLogDir修改如下：</p><pre><code>dataDir=E:\\Soft\\zookeeper-3.4.6\\datadataLogDir=E:\\Soft\\zookeeper-3.4.6\\log</code></pre><p>修改为你本地硬盘的目录</p><ul><li>启动zookeeper</li></ul><p>进入到zookeeper的bin目录下，双击zkServer.cmd,启动zookeeper</p><h3 id="2-dubbo接口服务api项目"><a href="#2-dubbo接口服务api项目" class="headerlink" title="2.dubbo接口服务api项目"></a>2.dubbo接口服务api项目</h3><p>新建maven项目api，注意将其pom.xml中的打包方式改为jar</p><p>然后在com.dubbo.api.service包下新建DemoService接口，如下：</p><pre><code>public interface DemoService {    String sayHello(String name);}</code></pre><p>项目结构如图：</p><p><img src="https://images.gitbook.cn/e024d790-a4ef-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><p>然后将项目打包（install一下即可），在E:\temp\api\target\目录下找到该jar，然后打包到本地maven仓库，打开cmd命令窗口，输入以下令如下：</p><pre><code>mvn install:install-file -Dfile=E:\temp\api\target\api.jar -DgroupId=com.dubbo.api -DartifactId=api -Dversion=1.0.0 -Dpackaging=jar -DgeneratePom=true -DcreateChecksum=true</code></pre><p>注意：jar路径该为你自己的路径</p><h3 id="3-dubbo服务提供者provider项目"><a href="#3-dubbo服务提供者provider项目" class="headerlink" title="3.dubbo服务提供者provider项目"></a>3.dubbo服务提供者provider项目</h3><p>新建maven项目provider,并在pom.xml中添加以下依赖：</p><pre><code> &lt;dependency&gt;  &lt;groupId&gt;com.dubbo.api&lt;/groupId&gt;  &lt;artifactId&gt;api&lt;/artifactId&gt;  &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.101tec&lt;/groupId&gt;  &lt;artifactId&gt;zkclient&lt;/artifactId&gt;  &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>这里引入了上面的生成的api接口依赖、dubbo依赖、zookeeper客服端依赖以及启动项目必需的依赖</p><p>然后在com.dubbo.provider.service.impl包下新建DemoServiceImp并实现DemoService接口，如下：</p><pre><code>public class DemoServiceImpl implements DemoService{@Overridepublic String sayHello(String name) {    return &quot;Hello &quot; + name;}</code></pre><p>然后在resources下新建provider.xml文件，配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://code.alibabatech.com/schema/dubbo   http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;&lt;!--定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识--&gt;&lt;dubbo:application name=&quot;demo-provider&quot; owner=&quot;wly&quot; organization=&quot;dubbox&quot;/&gt;&lt;!--使用 zookeeper 注册中心暴露服务，注意要先开启 zookeeper--&gt;&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;&lt;!--使用 dubbo 协议实现定义好的 api.PermissionService 接口--&gt;&lt;dubbo:service interface=&quot;com.dubbo.api.service.DemoService&quot; ref=&quot;demoService&quot; protocol=&quot;dubbo&quot; /&gt;&lt;!--具体实现该接口的 bean--&gt;&lt;bean id=&quot;demoService&quot; class=&quot;com.dubbo.provider.service.impl.DemoServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><p>然后在java下直接新建Provider用于启动项目：</p><pre><code>public class Provider {public static void main(String[] args) throws IOException {    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);    context.start();    System.out.println(&quot;dubbo服务提供端已启动....&quot;);    System.in.read(); // 按任意键退出}}</code></pre><p>provider项目结构如图：</p><p><img src="https://images.gitbook.cn/2550e6e0-a4f2-11e8-8b4a-cf3651600922" alt="enter image description here"></p><p>然后直接运行该main函数-dubbo服务提供者已启动！</p><h3 id="4-dubbo服务消费者consumer项目"><a href="#4-dubbo服务消费者consumer项目" class="headerlink" title="4.dubbo服务消费者consumer项目"></a>4.dubbo服务消费者consumer项目</h3><p>新建maven项目consumer,并在pom.xml中添加以下依赖：</p><pre><code> &lt;dependency&gt;  &lt;groupId&gt;com.dubbo.api&lt;/groupId&gt;  &lt;artifactId&gt;api&lt;/artifactId&gt;  &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.101tec&lt;/groupId&gt;  &lt;artifactId&gt;zkclient&lt;/artifactId&gt;  &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>和provider项目添加的依赖一样。</p><p>然后在resources下新建comsumer.xml，配置服务消费者，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;&lt;dubbo:application name=&quot;demo-consumer&quot; owner=&quot;wly&quot; organization=&quot;dubbox&quot;/&gt;&lt;!--向 zookeeper 订阅 provider 的地址，由 zookeeper 定时推送--&gt;&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;&lt;!--使用 dubbo 协议调用定义好的 api.PermissionService 接口--&gt;&lt;dubbo:reference id=&quot;demoService&quot; interface=&quot;com.dubbo.api.service.DemoService&quot;/&gt;&lt;/beans&gt;</code></pre><p>然后在java下新建Consumer.class用于启动该项目，如下：</p><pre><code>public class Consumer {public static void main(String[] args) throws IOException {    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext( &quot;consumer.xml&quot; );    context.start();    System.out.println(&quot;dubbo服务消费端已启动...&quot;);    DemoService demoService = (DemoService)context.getBean( &quot;demoService&quot; );// 获取远程服务代理    String hello = demoService.sayHello( &quot;world&quot; );//执行远程方法    System.out.println(hello);//显示调用结果    System.in.read(); // 按任意键退出}}</code></pre><p>启动该项目，显示调用结果，如图：</p><p><img src="https://images.gitbook.cn/dbfc3520-a4f2-11e8-8a5b-85d5618fe6ba" alt="enter image description here"></p><p>到这里就已经完成了dubbo的远程调用。下面介绍下dubbo-admin管理管理控制台</p><h2 id="四、dubbo-admin管理控制台"><a href="#四、dubbo-admin管理控制台" class="headerlink" title="四、dubbo-admin管理控制台"></a>四、dubbo-admin管理控制台</h2><p>通过dubbo-admin可以更好的管理dubbo服务。</p><p>首先下载dubbo-admin的war包，下载地址：</p><pre><code>http://www.java1234.com/a/javabook/javaweb/2018/0224/10496.html</code></pre><p>下载完成后，将dubbo-admin-2.6.0.war复制到tomcat的webapps目录下。然后启动tomcat,访问</p><pre><code>http://localhost:8080/dubbo-admin-2.6.0/</code></pre><p>也可以将dubbo-admin-2.6.0重命名为dubbo-admin访问的时候直接访问<a href="http://localhost:8080/dubbo-admin即可" target="_blank" rel="external">http://localhost:8080/dubbo-admin即可</a></p><p>用户名和密码都是root</p><p>登录后就可以通过网页进行管理dubbo服务了，如图：</p><p><img src="https://images.gitbook.cn/4da3b530-a4f4-11e8-a2aa-0bd41466d20f" alt="enter image description here"></p><h2 id="该demo项目以及相关资源下载链接"><a href="#该demo项目以及相关资源下载链接" class="headerlink" title="该demo项目以及相关资源下载链接"></a>该demo项目以及相关资源下载链接</h2><pre><code>https://download.csdn.net/download/abcwanglinyong/10617369</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、dubbo基本原理&quot;&gt;&lt;a href=&quot;#一、dubbo基本原理&quot; class=&quot;headerlink&quot; title=&quot;一、dubbo基本原理&quot;&gt;&lt;/a&gt;一、dubbo基本原理&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;dubbo架构图如下：&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wanglinyong.github.io/tags/Java/"/>
    
      <category term="dubbo" scheme="https://wanglinyong.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Solr工作原理</title>
    <link href="https://wanglinyong.github.io/2018/07/13/solr%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/13/solr工作原理/</id>
    <published>2018-07-13T06:56:19.000Z</published>
    <updated>2018-07-18T13:50:12.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Solr简介"><a href="#Solr简介" class="headerlink" title="Solr简介"></a>Solr简介</h2><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p><p>要想知道solr的实现原理，首先得了解什么是全文检索、solr的索引创建过程和索引搜索过程。</p><h2 id="一、全文检索"><a href="#一、全文检索" class="headerlink" title="一、全文检索"></a>一、全文检索</h2><p>首先举个例子：比如现在有5个文档，我现在想从5个文档中查找出包含”solr工作原理”的文档，此时有两种做法：</p><p>1.顺序扫描法:对5个文档依次查找，包含目标字段的文档就记录下来，最后查找的结果可能是在2,3文档中，这种查找方式叫做<strong>顺序扫描法</strong>。</p><p>顺序扫描法在文档数量较少的情况下，查找速度还是很快的，但是当文档数量很多时，查找速度就差强人意了。</p><p>2.全文检索:对文档内容进行分词，对分词后的结果创建索引，然后通过对索引进行搜索的方式叫做<strong>全文检索</strong>。</p><p>全文检索就相当于根据偏旁部首或者读音去查找字典，在文档很多的情况，这种查找速度肯定比你一个一个文档查找要快。</p><h2 id="二、索引创建和搜索过程"><a href="#二、索引创建和搜索过程" class="headerlink" title="二、索引创建和搜索过程"></a>二、索引创建和搜索过程</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1.创建索引"></a>1.创建索引</h3><p>举例子：</p><p>文档一：solr是基于Lucene开发的企业级搜索引擎技术</p><p>文档二：Solr是一个独立的企业级搜索应用服务器，Solr是一个高性能，基于Lucene的全文搜索服务器</p><p>首先经过分词器分词，solr会为分词后的结果（词典）创建索引，然后将索引和文档id列表对应起来，如下图所示：</p><p><img src="https://images.gitbook.cn/2b1670f0-8665-11e8-9b0d-95de449dc107" alt="enter image description here"></p><p>比如：solr在文档1和文档2中都有出现，所以对应的文档ID列表中既包含文档1的ID也包含文档2的ID，文档ID列表对应到具体的文档，并体现该词典在该文档中出现的频次，频次越多说明权重越大，权重越大搜索的结果就会排在前面。</p><p>solr内部会对分词的结果做如下处理：</p><p>1.去除停词和标点符号，例如英文的this，that等， 中文的”的”,”一”等没有特殊含义的词</p><p>2.会将所有的大写英文字母转换成小写，方便统一创建索引和搜索索引</p><p>3.将复数形式转为单数形式，比如students转为student，也是方便统一创建索引和搜索索引</p><h3 id="2-索引搜索过程"><a href="#2-索引搜索过程" class="headerlink" title="2.索引搜索过程"></a>2.索引搜索过程</h3><p>知道了创建索引的过程，那么根据索引进行搜索就变得简单了。</p><p>1.用户输入搜索条件</p><p>2.对搜索条件进行分词处理</p><p>3.根据分词的结果查找索引</p><p>4.根据索引找到文档ID列表</p><p>5.根据文档ID列表找到具体的文档，根据出现的频次等计算权重，最后将文档列表按照权重排序返回</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Solr简介&quot;&gt;&lt;a href=&quot;#Solr简介&quot; class=&quot;headerlink&quot; title=&quot;Solr简介&quot;&gt;&lt;/a&gt;Solr简介&lt;/h2&gt;&lt;p&gt;Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过h
      
    
    </summary>
    
      <category term="Solr" scheme="https://wanglinyong.github.io/categories/Solr/"/>
    
    
      <category term="solr" scheme="https://wanglinyong.github.io/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Security登录认证授权原理</title>
    <link href="https://wanglinyong.github.io/2018/07/10/Spring-Security%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83%E5%8E%9F%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/10/Spring-Security登录认证授权原理/</id>
    <published>2018-07-10T02:09:10.000Z</published>
    <updated>2018-07-18T13:47:57.755Z</updated>
    
    <content type="html"><![CDATA[<p>spring-security源码下载地址：</p><pre><code>https://github.com/spring-projects/spring-security</code></pre><h2 id="Spring-Security源码解读："><a href="#Spring-Security源码解读：" class="headerlink" title="Spring-Security源码解读："></a>Spring-Security源码解读：</h2><p>1.使用ctrl+shift+n组合键查找UsernamePasswordAuthenticationFilter过滤器，该过滤器是用来处理用户认证逻辑的，进入后如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security-3.png" alt=""></p><p>(1)可以看到它默认的登录请求url是”/login”，并且只允许POST方式的请求</p><p>(2)obtainUsername()方法点进去发现它默认是根据参数名为”username”和”password”来获取用户名和密码的</p><p>(3)通过构造方法实例化一个UsernamePasswordAuthenticationToken对象，此时调用的是UsernamePasswordAuthenticationToken的两个参数的构造函数,如果点击进不去，可直接用ctrl+shift+n查找(等依赖自动下载完成就可以跟进了)，如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security-4.png" alt=""></p><p>其中super(null)调用的是父类的构造方法，传入的是权限集合，因为目前还没有认证通过，所以不知道有什么权限信息，这里设置为null,然后将用户名和密码分别赋值给principal和credentials，同样因为此时还未进行身份认证，所以setAuthenticated(false)</p><p>(4)setDetails(request, authRequest)是将当前的请求信息设置到UsernamePasswordAuthenticationToken中</p><p>(5)通过调用getAuthenticationManager()来获取AuthenticationManager，通过调用它的authenticate方法来查找支持该token(UsernamePasswordAuthenticationToken)认证方式的provider，然后调用该provider的authenticate方法进行认证)</p><p>2.AuthenticationManager是用来管理AuthenticationProvider的接口，通过查找后进入，然后使用ctrl+H组合键查看它的继承关系，找到ProviderManager实现类，它实现了AuthenticationManager接口，查看它的authenticate方法，它里面有段这样的代码：</p><pre><code>for (AuthenticationProvider provider : getProviders()) {        if (!provider.supports(toTest)) {            continue;        }    ...    try {            result = provider.authenticate(authentication);    ...    }}</code></pre><p>通过for循环遍历AuthenticationProvider对象的集合，找到支持当前认证方式的AuthenticationProvider，找到之后调用该AuthenticationProvider的authenticate方法进行认证处理：</p><pre><code>result = provider.authenticate(authentication);</code></pre><p>3.AuthenticationProvider接口，就是进行身份认证的接口，它里面有两个方法：authenticate认证方法和supports是否支持某种类型token的方法，通过ctrl+h查看继承关系，找到AbstractUserDetailsAuthenticationProvider抽象类，它实现了AuthenticationProvider接口，它的supports方法如下：</p><pre><code>public boolean supports(Class&lt;?&gt; authentication) {    return (UsernamePasswordAuthenticationToken.class        .isAssignableFrom(authentication));    }</code></pre><p>说明它是支持UsernamePasswordAuthenticationToken类型的AuthenticationProvider</p><p>再看它的authenticate认证方法，其中有一段这样的代码：</p><pre><code>boolean cacheWasUsed = true;    UserDetails user = this.userCache.getUserFromCache(username);    if (user == null) {        cacheWasUsed = false;        try {            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);        }    ...    }</code></pre><p>如果从缓存中没有获取到UserDetails，那么它调用retrieveUser方法来获取用户信息UserDetails，这里的retrieveUser是抽象方法，等一会我们看它的子类实现。</p><p>用户信息UserDetails是个接口，我们进入查看，它包含以下6个接口方法：</p><pre><code>Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//获取权限集合String getPassword();  //获取密码String getUsername();    //获取用户名boolean isAccountNonExpired(); //账户未过期boolean isAccountNonLocked();    //账户未锁定boolean isCredentialsNonExpired(); //密码未过期boolean isEnabled();    //账户可用</code></pre><p>查看它的继承关系发现User类实现了该接口，并实现了该接口的所有方法</p><p>接着AbstractUserDetailsAuthenticationProvider往下看，找到下面的代码：</p><pre><code>preAuthenticationChecks.check(user);additionalAuthenticationChecks(user,            (UsernamePasswordAuthenticationToken) authentication);</code></pre><p>preAuthenticationChecks预检查，在最下面的内部类DefaultPreAuthenticationChecks中可以看到，它会检查上面提到的三个boolean方法，即检查账户未锁定、账户可用、账户未过期，如果上面的方法只要有一个返回false，就会抛出异常，那么认证就会失败。</p><p>additionalAuthenticationChecks是附加检查，是个抽象方法，等下看子类的具体实现。</p><p>下面还有个postAuthenticationChecks.check(user)后检查，在最下面的DefaultPostAuthenticationChecks内部类中可以看到，它会检查密码未过期，如果为false就会抛出异常</p><p>如果上面的检查都通过并且没有异常，表示认证通过，会调用下面的方法：</p><pre><code>createSuccessAuthentication(principalToReturn, authentication, user);</code></pre><p>跟进发现此时通过构造方法实例化对象UsernamePasswordAuthenticationToken时，调用的是三个参数的构造方法:</p><pre><code>    public UsernamePasswordAuthenticationToken(Object principal, Object credentials,        Collection&lt;? extends GrantedAuthority&gt; authorities) {    super(authorities);    this.principal = principal;    this.credentials = credentials;    super.setAuthenticated(true); // must use super, as we override}</code></pre><p>此时会调用父类的构造方法设置权限信息，并调用父类的setAuthenticated(true)方法，到这里就表示认证通过了。</p><p>下面我们看看AbstractUserDetailsAuthenticationProvider的子类，同ctrl+h可查看继承关系，找到DaoAuthenticationProvider</p><p>4.DaoAuthenticationProvider类</p><p>(1)查看additionalAuthenticationChecks附加检查方法，它主要是检查用户密码的正确性，如果密码为空或者错误都会抛出异常</p><p>(2)获取用户信息UserDetails的retrieveUser方法，主要看下面这段代码：</p><pre><code>UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</code></pre><p>它是调用了getUserDetailsService先获取到UserDetailsService对象，通过调用UserDetailsService对象的loadUserByUsername方法获取用户信息UserDetails</p><p>找到UserDetailsService，发现它是一个接口，查看继承关系，有很多实现，都是spring-security提供的实现类，并不满足我们的需要，我们想自己制定获取用户信息的逻辑，所以我们可以实现这个接口。比如从我们的数据库中查找用户信息</p><p>5.SecurityContextPersistenceFilter过滤器</p><p>那么用户认证成功之后，又是怎么保存认证信息的呢，在下一次请求过来是如何判断该用户是否已经认证了呢？</p><p>请求进来时会经过SecurityContextPersistenceFilter过滤器，进入SecurityContextPersistenceFilter过滤器并找到以下代码：</p><pre><code>SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</code></pre><p>从session中获取SecurityContext对象，如果没有就实例化一个SecurityContext对象</p><pre><code>SecurityContextHolder.setContext(contextBeforeChainExecution);</code></pre><p>将SecurityContext对象设置到SecurityContextHolder中</p><pre><code>chain.doFilter(holder.getRequest(), holder.getResponse());</code></pre><p>表示放行，执行下一个过滤器</p><p>执行完后面的过滤并经过servlet处理之后，响应给浏览器之前再次经过此过滤器。查看以下代码：</p><pre><code>SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();SecurityContextHolder.clearContext();this.repo.saveContext(contextAfterChainExecution, holder.getRequest(), holder.getResponse());</code></pre><p>通过SecurityContextHolder获取SecurityContext对象，然后清除SecurityContext，最后将获取的SecurityContext对象放入session中</p><p>其中SecurityContextHolder是与ThreadLocal绑定的，即本线程内所有的方法都可以获得SecurityContext对象，而SecurityContext对象中包含了Authentication对象，即用户的认证信息，spring-security判断用户是否认证主要是根据SecurityContext中的Authentication对象来判断。Authentication对象的详细信息如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/security.png" alt=""></p><p>最后整个过程的流程大致如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/spring-securityx.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring-security源码下载地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/spring-projects/spring-security
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Spring-Security源码解读：&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
      <category term="spring-security" scheme="https://wanglinyong.github.io/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>读取properties文件内容最简单的两种方式</title>
    <link href="https://wanglinyong.github.io/2018/07/03/%E8%8E%B7%E5%8F%96properties%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F/"/>
    <id>https://wanglinyong.github.io/2018/07/03/获取properties文件内容最简单方式/</id>
    <published>2018-07-03T00:47:49.000Z</published>
    <updated>2018-07-18T13:41:13.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、使用ResourceBundle读取jdbc-properties文件"><a href="#一、使用ResourceBundle读取jdbc-properties文件" class="headerlink" title="一、使用ResourceBundle读取jdbc.properties文件"></a>一、使用ResourceBundle读取jdbc.properties文件</h2><pre><code>public static void main(String[] args) {    ResourceBundle bundle = ResourceBundle.getBundle(&quot;jdbc&quot;);    String value= bundle.getString(&quot;driverClasss&quot;);    System.out.println(value);}</code></pre><p>结果如下：</p><pre><code>com.mysql.jdbc.Driver</code></pre><h2 id="二、自定义工具类PropertiesUtils读取jdbc-properties文件："><a href="#二、自定义工具类PropertiesUtils读取jdbc-properties文件：" class="headerlink" title="二、自定义工具类PropertiesUtils读取jdbc.properties文件："></a>二、自定义工具类PropertiesUtils读取jdbc.properties文件：</h2><h3 id="1-PropertiesUtils代码如下："><a href="#1-PropertiesUtils代码如下：" class="headerlink" title="1.PropertiesUtils代码如下："></a>1.PropertiesUtils代码如下：</h3><pre><code>import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;/** * Created by wly on 2018/7/3. */public class  {private static Properties props = new Properties();public static String getValue(String key) {    return props.getProperty(key);}public static void updateProperties(String key, String value) {    props.setProperty(key, value);}static {    try {        props.load(Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;));    } catch (FileNotFoundException var1) {        var1.printStackTrace();    } catch (IOException var2) {        var2.printStackTrace();    }}}</code></pre><h3 id="2-main方法测试"><a href="#2-main方法测试" class="headerlink" title="2.main方法测试"></a>2.main方法测试</h3><pre><code>public static void main(String[] args) {    String name = getValue( &quot;driverClasss&quot; );    System.out.println(&quot;mysql的driverClasss===&quot;+name);    updateProperties( &quot;driverClasss&quot;,&quot;oracle.jdbc.driver.OracleDriver&quot; );    name = getValue( &quot;driverClasss&quot; );    System.out.println(&quot;修改成Oracle的driverClasss====&quot;+name);}</code></pre><p>测试结果：</p><pre><code>mysql的driverClasss===com.mysql.jdbc.Driver修改成Oracle的driverClasss====oracle.jdbc.driver.OracleDriver</code></pre><p>一个是根据key获取对应的value值</p><p>一个是根据key值设置对应的value值，注意不会改变propertis文件内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、使用ResourceBundle读取jdbc-properties文件&quot;&gt;&lt;a href=&quot;#一、使用ResourceBundle读取jdbc-properties文件&quot; class=&quot;headerlink&quot; title=&quot;一、使用ResourceBundle
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>AccessDeniedException如何处理</title>
    <link href="https://wanglinyong.github.io/2018/07/02/AccessDeniedException%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <id>https://wanglinyong.github.io/2018/07/02/AccessDeniedException如何处理/</id>
    <published>2018-07-02T02:46:40.000Z</published>
    <updated>2018-07-18T13:39:13.452Z</updated>
    
    <content type="html"><![CDATA[<p>有两种情况：</p><p>1.用户未登录情况下访问受保护资源</p><p>2.用户登录情况下访问被保护资源</p><h2 id="一、用户未登录情况下访问受保护资源"><a href="#一、用户未登录情况下访问受保护资源" class="headerlink" title="一、用户未登录情况下访问受保护资源"></a>一、用户未登录情况下访问受保护资源</h2><p>用户在未登录的情况下访问受保护资源时会自动跳转到配置的登录页面。主要是以下这个配置起作用：</p><pre><code>&lt;security:http auto-config=&quot;false&quot; access-decision-manager-ref=&quot;accessDecisionManager&quot;               use-expressions=&quot;true&quot; entry-point-ref=&quot;loginEntryPoint&quot;&gt; &lt;bean id=&quot;loginEntryPoint&quot;    class=&quot;org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint&quot;&gt;    &lt;!-- 默认登录页的url --&gt;    &lt;constructor-arg value=&quot;/login?error=login&quot;/&gt;&lt;/bean&gt;&lt;/security:http&gt;</code></pre><p>但是这里说的访问路径不包含ajax请求的访问，如果是ajax请求的话，你会看到后台报AccessDeniedException异常，而前台没反应。因为对ajax请求不起作用</p><p>此时你可以这样来解决，在发送ajax请求的页面判断用户是否为空，为空则直接跳转到登录页面，如下：</p><pre><code> var res = &apos;${user.id}&apos;;    if(res==&apos;&apos; || res==null){        window.location.href = &quot;/login.jsp&quot;;    }    $.ajax({    ...})；}</code></pre><p>登录情况下的ajax请求我们下面介绍</p><h2 id="二、用户在登录情况下访问受保护资源"><a href="#二、用户在登录情况下访问受保护资源" class="headerlink" title="二、用户在登录情况下访问受保护资源"></a>二、用户在登录情况下访问受保护资源</h2><p>用户在登录情况下访问受保护资源时，可以有两种解决方案：</p><h3 id="1-配置403错误页面-有瑕疵"><a href="#1-配置403错误页面-有瑕疵" class="headerlink" title="1.配置403错误页面(有瑕疵)"></a>1.配置403错误页面(有瑕疵)</h3><p>因为我们知道访问受保护资源时会返回403错误码，我们可以直接配置403错误页面</p><p>在web.xml中配置错误页面：</p><pre><code>&lt;error-page&gt;    &lt;error-code&gt;403&lt;/error-code&gt;    &lt;location&gt;/WEB-INF/403.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><p>在/WEB-INF/下引入403.jsp即可</p><p>此时访问受保护资源时会直接跳转到我们配置的403错误页面</p><p>但是问题又来了，ajax请求访问受保护资源时同样没有反应，且看下面的解决办法</p><h3 id="2-自定义MyAccessDeniedHandler拒绝访问处理器（完美）"><a href="#2-自定义MyAccessDeniedHandler拒绝访问处理器（完美）" class="headerlink" title="2.自定义MyAccessDeniedHandler拒绝访问处理器（完美）"></a>2.自定义MyAccessDeniedHandler拒绝访问处理器（完美）</h3><p>1.新建MyAccessDeniedHandler并实现AccessDeniedHandler接口：</p><pre><code>public class MyAccessDeniedHandler implements AccessDeniedHandler{private String errorPage;public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {    String header = request.getHeader( &quot;X-Requested-With&quot; );    if (header != null &amp;&amp; &quot;XMLHttpRequest&quot;.equals( header )) {        //ajax请求        String jsonObject = &quot;{\&quot;access-denied\&quot;:true}&quot;;        PrintWriter out = response.getWriter();        out.print( jsonObject );        out.flush();        out.close();        return;    } else {        RequestDispatcher dispatcher = request.getRequestDispatcher( errorPage );        dispatcher.forward( request, response );    }}public void setErrorPage(String errorPage) {    if(errorPage != null &amp;&amp; !errorPage.startsWith(&quot;/&quot;)) {        throw new IllegalArgumentException(&quot;errorPage must begin with &apos;/&apos;&quot;);    } else {        this.errorPage = errorPage;    }}}</code></pre><p>(1)通过setter方法获取配置文件中配置的错误页面</p><p>(2)根据请求头信息判断该请求是不是ajax请求</p><p>(3)如果是ajax请求，则返回json格式数据{access-denied:true}</p><p>(4)如果不是ajax请求则将请求转发到配置的错误页面</p><p>2.spring-security.xml配置自定义的AccessDeniedHandler：</p><pre><code>&lt;security:access-denied-handler ref=&quot;accessDeniedHandler&quot;/&gt;&lt;bean id=&quot;accessDeniedHandler&quot; class=&quot;wang.dreamland.www.security.MyAccessDeniedHandler&quot;&gt;    &lt;property name=&quot;errorPage&quot; value=&quot;/accessDenied.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>3.在webapp目录下新建accessDenied.jsp文件：</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;无访问权限&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;span style=&quot;color: red&quot;&gt;无访问权限&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>4.在发ajax请求的页面做下判断：</p><pre><code>$.ajax({       type:&apos;post&apos;,       url:&apos;/list&apos;,       dataType:&apos;json&apos;,       success:function(data){           var noAccess = data[&quot;access-denied&quot;]           if(noAccess){               window.location.href = &quot;${ctx}/accessDenied.jsp&quot;;               return           }       ...   }   });</code></pre><p>如果noAccess=true则跳转到accessDenied.jsp页面</p><p>这样就完美解决了登陆后无访问权限跳转的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有两种情况：&lt;/p&gt;
&lt;p&gt;1.用户未登录情况下访问受保护资源&lt;/p&gt;
&lt;p&gt;2.用户登录情况下访问被保护资源&lt;/p&gt;
&lt;h2 id=&quot;一、用户未登录情况下访问受保护资源&quot;&gt;&lt;a href=&quot;#一、用户未登录情况下访问受保护资源&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wanglinyong.github.io/tags/java/"/>
    
      <category term="security" scheme="https://wanglinyong.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Python压缩解压zip文件</title>
    <link href="https://wanglinyong.github.io/2018/06/28/Python%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8Bzip%E6%96%87%E4%BB%B6/"/>
    <id>https://wanglinyong.github.io/2018/06/28/Python压缩解压zip文件/</id>
    <published>2018-06-28T03:37:40.000Z</published>
    <updated>2018-07-18T13:33:02.308Z</updated>
    
    <content type="html"><![CDATA[<p>导入相关模块</p><pre><code>import osimport shutilimport zipfilefrom os.path import join, getsize</code></pre><h2 id="一、python压缩指定文件夹"><a href="#一、python压缩指定文件夹" class="headerlink" title="一、python压缩指定文件夹"></a>一、python压缩指定文件夹</h2><pre><code>def zip_file(src_dir):    zip_name = src_dir +&apos;.zip&apos;    z = zipfile.ZipFile(zip_name,&apos;w&apos;,zipfile.ZIP_DEFLATED)    for dirpath, dirnames, filenames in os.walk(src_dir):        fpath = dirpath.replace(src_dir,&apos;&apos;)        fpath = fpath and fpath + os.sep or &apos;&apos;        for filename in filenames:            z.write(os.path.join(dirpath, filename),fpath+filename)            print (&apos;==压缩成功==&apos;)    z.close()</code></pre><p>其中</p><pre><code>src_dir：你要压缩的文件夹的路径zip_name：压缩后zip文件的路径及名称</code></pre><h2 id="二、python解压zip"><a href="#二、python解压zip" class="headerlink" title="二、python解压zip"></a>二、python解压zip</h2><pre><code>def unzip_file(zip_src, dst_dir):    r = zipfile.is_zipfile(zip_src)    if r:             fz = zipfile.ZipFile(zip_src, &apos;r&apos;)        for file in fz.namelist():            fz.extract(file, dst_dir)           else:        print(&apos;This is not zip&apos;)</code></pre><p>其中：</p><pre><code>zip_src:是zip文件的全路径dst_dir：是要解压到的目的文件夹</code></pre><h2 id="三、Python其它操作文件方法"><a href="#三、Python其它操作文件方法" class="headerlink" title="三、Python其它操作文件方法"></a>三、Python其它操作文件方法</h2><h3 id="1-剪切（移动）文件到指定目录"><a href="#1-剪切（移动）文件到指定目录" class="headerlink" title="1.剪切（移动）文件到指定目录"></a>1.剪切（移动）文件到指定目录</h3><pre><code>shutil.move(filename, dst_dir)</code></pre><h3 id="2-删除文件夹"><a href="#2-删除文件夹" class="headerlink" title="2.删除文件夹"></a>2.删除文件夹</h3><pre><code>shutil.rmtree(src_dir)</code></pre><h3 id="3-删除指定文件"><a href="#3-删除指定文件" class="headerlink" title="3.删除指定文件"></a>3.删除指定文件</h3><pre><code>os.remove(file_src)</code></pre><h3 id="4-新建文件夹"><a href="#4-新建文件夹" class="headerlink" title="4.新建文件夹"></a>4.新建文件夹</h3><pre><code>os.mkdir(dst_dir)</code></pre><h3 id="5-遍历文件夹"><a href="#5-遍历文件夹" class="headerlink" title="5.遍历文件夹"></a>5.遍历文件夹</h3><pre><code>for filename in os.listdir(src_dir):</code></pre><h3 id="6-复制文件"><a href="#6-复制文件" class="headerlink" title="6.复制文件"></a>6.复制文件</h3><pre><code>shutil.copyfile(src_file,dst_file)  </code></pre><h3 id="7-获取文件夹大小"><a href="#7-获取文件夹大小" class="headerlink" title="7.获取文件夹大小"></a>7.获取文件夹大小</h3><pre><code>def get_dir_size(dir_path):    size = 0L    for root, dirs, files in os.walk(dir_path):        size += sum([getsize(join(root, name)) for name in files])    return size</code></pre><p>可以根据文件大小做不同的判断，如：</p><pre><code>file_size = get_dir_size(DATA_PATH)max_size = file_size / 1024 / 1024   ##获得的是以Mb为单位的值if max_size &lt; 100:    pass</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导入相关模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
import shutil
import zipfile
from os.path import join, getsize
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;一、python压缩指定文件夹&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Python" scheme="https://wanglinyong.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="https://wanglinyong.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>dockpanel动态添加picturebox并绑定图片</title>
    <link href="https://wanglinyong.github.io/2018/06/04/dockpanel%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0picturebox%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://wanglinyong.github.io/2018/06/04/dockpanel动态添加picturebox的方法/</id>
    <published>2018-06-04T12:59:40.000Z</published>
    <updated>2018-06-04T13:03:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。</p><h2 id="1-生成picturebox的方法"><a href="#1-生成picturebox的方法" class="headerlink" title="1.生成picturebox的方法"></a>1.生成picturebox的方法</h2><pre><code> public void generatorPictureBox(){    int imageNum = 20;//图片的数量    PictureBox[] pict;    pict = new PictureBox[imageNum];    for (int i = 1; i &lt; imageNum; i++)    {        pict[i] = new System.Windows.Forms.PictureBox();               pict[i].Location = new Point(5 , 10+(i - 1) * 60);//设置图片位置  竖向排列        pict[i].SizeMode = PictureBoxSizeMode.Zoom;        pict[i].Image = Image.FromFile(@&quot;D:\images\&quot; + i + &quot;.png&quot;);//导入图片        pict[i].Size = new Size(50, 50);//设置图片大小        pict[i].BorderStyle = BorderStyle.None;//取消边框        pict[i].Image.Tag = i;        pict[i].Click += singleClick;//给图片绑定点击事件        dockPanel1.Controls.Add(pict[i]); //添加picturebox    }}</code></pre><h2 id="2-给图片绑定的点击事件"><a href="#2-给图片绑定的点击事件" class="headerlink" title="2.给图片绑定的点击事件"></a>2.给图片绑定的点击事件</h2><pre><code>private void singleClick(object sender, EventArgs e)  {      PictureBox p = sender as PictureBox;             LOG.Info(&quot;Click===============imgIndex====&quot;+p.Image.Tag);  }</code></pre><h2 id="3-在窗体初始化的时候调用generatorPictureBox方法即可"><a href="#3-在窗体初始化的时候调用generatorPictureBox方法即可" class="headerlink" title="3.在窗体初始化的时候调用generatorPictureBox方法即可"></a>3.在窗体初始化的时候调用generatorPictureBox方法即可</h2><h2 id="4-效果如下："><a href="#4-效果如下：" class="headerlink" title="4.效果如下："></a>4.效果如下：</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/doc-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于DockManager的使用之前已经介绍过，这里不再赘述。直接说如何在dockpanel中动态添加picturebox并绑定图片。&lt;/p&gt;
&lt;h2 id=&quot;1-生成picturebox的方法&quot;&gt;&lt;a href=&quot;#1-生成picturebox的方法&quot; class=&quot;he
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="picturebox" scheme="https://wanglinyong.github.io/tags/picturebox/"/>
    
      <category term="c#" scheme="https://wanglinyong.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Xshell6下载安装</title>
    <link href="https://wanglinyong.github.io/2018/05/28/Xshell6%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
    <id>https://wanglinyong.github.io/2018/05/28/Xshell6下载安装/</id>
    <published>2018-05-28T11:23:20.000Z</published>
    <updated>2018-05-29T11:44:50.606Z</updated>
    
    <content type="html"><![CDATA[<p>随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。</p><p> 1.进入xshell英文官网，链接地址如下：</p><pre><code>http://www.netsarang.com/products/main.html</code></pre><p>2.将鼠标悬浮在Download上会出现三个列表，点击第三个Free License,如下图：</p><p><img src="https://img-blog.csdn.net/20180528160438334" alt=""></p><p>或者点击Download，将窗口滚动到最下方，点击Free for Home &amp; School，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160452206" alt=""></p><p>3.之后会进入Xshell6和Xftp6的下载页面，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160508678" alt=""></p><p>4.点击Xshell6会跳转到填写个人信息的页面，打红星的是必填项，注意邮箱要正确，会将下载链接发到你的邮箱，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160523209" alt=""></p><p>5.填写好信息后，点击Submit提交，这时下载链接就会发送到你填写的邮箱了。</p><p>6.打开邮箱，点击链接进行下载，如下图：</p><p><img src="https://img-blog.csdn.net/20180528160539725" alt=""></p><p>7.下载完成后根据提示进行安装即可。</p><p>xshell6下载完成以后，一般还需要配合xftp6文件上传工具使用，下载步骤同上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着xshell5出现评估期已过的问题，发现好多人不知道怎么下载免费版的Xshell，在这里我将详细告诉大家如何下载和安装最新的Xshell6远程管理工具。&lt;/p&gt;
&lt;p&gt; 1.进入xshell英文官网，链接地址如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://www.n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零开始开发SSM项目-博客系统实战</title>
    <link href="https://wanglinyong.github.io/2018/05/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91SSM%E9%A1%B9%E7%9B%AE-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://wanglinyong.github.io/2018/05/26/从零开始开发SSM项目-博客系统实战/</id>
    <published>2018-05-26T11:30:28.000Z</published>
    <updated>2018-05-26T11:30:45.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、项目包含功能"><a href="#一、项目包含功能" class="headerlink" title="一、项目包含功能"></a>一、项目包含功能</h1><p>使用SSM框架开发一个博客系统，包含的功能大致有:</p><p>1.用户注册与激活，激活方式通过邮件激活</p><p>2.用户的登录和退出，包括账号登录和手机快捷登录</p><p>3.用户账号登录和注册时需要输入验证码验证</p><p>4.首页展示及分页，主要展示文章内容，可进行搜索，将搜索结果高亮显示</p><p>5.首页文章的点赞、踩和评论功能</p><p>6.个人主页模块，包括个人的基本信息，梦分类，发布梦，管理梦以及热梦推荐等</p><p>7.书写文章功能</p><p>8.文章管理功能，包括文章的查看、修改和删除</p><p>9.个人信息修改功能</p><p>10.安全框架 spring-security 的整合，对不符合条件的用户或者 URL 进行拦截</p><p>11.记录用户登录信息，包括登录的时间、IP 等</p><h1 id="二、项目所用技术"><a href="#二、项目所用技术" class="headerlink" title="二、项目所用技术"></a>二、项目所用技术</h1><p>使用到的技术主要有</p><p>1.主体框架：SpringMVC + Spring + Mybatis</p><p>2.安全框架：Spring-Security</p><p>3.数据库：Mysql</p><p>4.缓存技术：Redis</p><p>5.消息中间件：ActiveMQ</p><p>6.搜索引擎：solr</p><p>7.富文本编辑器： Kindeditor</p><p>8.异步更新：Ajax</p><p>9.前端框架：zui、bootstrap、Jquery</p><h1 id="三、部分页面效果如下："><a href="#三、部分页面效果如下：" class="headerlink" title="三、部分页面效果如下："></a>三、部分页面效果如下：</h1><p>1.登录页面（账号登录和手机快捷登录）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/login-y.png" alt=""></p><p>2.注册页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/regist-x.png" alt=""></p><p>3.首页（评论、回复及点赞）</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/index-x.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/chat-x.png" alt=""></p><p>4.写博客页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/write-x.png" alt=""></p><p>5.个人主页</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/personal-x.png" alt=""></p><p>6.个人信息页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/update.png" alt=""></p><p>7.修改密码页面</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/repassword-x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、项目包含功能&quot;&gt;&lt;a href=&quot;#一、项目包含功能&quot; class=&quot;headerlink&quot; title=&quot;一、项目包含功能&quot;&gt;&lt;/a&gt;一、项目包含功能&lt;/h1&gt;&lt;p&gt;使用SSM框架开发一个博客系统，包含的功能大致有:&lt;/p&gt;
&lt;p&gt;1.用户注册与激活，激活方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C# 借助阿里大于平台发送短信</title>
    <link href="https://wanglinyong.github.io/2018/05/18/csharp%E5%80%9F%E5%8A%A9%E9%98%BF%E9%87%8C%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    <id>https://wanglinyong.github.io/2018/05/18/csharp借助阿里大于发送短信/</id>
    <published>2018-05-18T12:30:18.000Z</published>
    <updated>2018-05-18T12:34:29.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、首先申请签名和模板"><a href="#一、首先申请签名和模板" class="headerlink" title="一、首先申请签名和模板"></a>一、首先申请签名和模板</h1><p>1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管理，申请一个签名，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-1.png" alt=""></p><p>2.然后找到模板管理，申请一个模板，模板里都有格式内容介绍，申请好以后大概是这样：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-8.png" alt=""></p><p>3.签名名称和模板CODE等会代码中会用到，还有Access Key ID 和 Access Key Secret也要用到，Access Key在个人信息的下拉列表里可以找到，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-3.png" alt=""></p><h1 id="二、下载-Net平台下的SDK"><a href="#二、下载-Net平台下的SDK" class="headerlink" title="二、下载.Net平台下的SDK"></a>二、下载.Net平台下的SDK</h1><p>1.点击短信服务列表中的帮助文档</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-4.png" alt=""></p><p>2.点击SDK下载，进入到SDK及DEMO下载页面，找到第4个[NET],点击即可下载。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-5.png" alt=""></p><p>3.将下载好的压缩包进行解压，找到msg_demo目录，在/msg_demo/alicom-mns-receive有发送短信的demo和dll文件</p><h1 id="三、发短信的具体实现"><a href="#三、发短信的具体实现" class="headerlink" title="三、发短信的具体实现"></a>三、发短信的具体实现</h1><p>1.将/msg_demo/alicom-mns-receive/dll目录下的4个dll文件拷贝到你的项目目录下</p><p>2.在你项目的引用右键添加引用，打开引用管理器，如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-6.png" alt=""></p><p>3.点击浏览，将阿里大于依赖的4个dll文件添加进来，然后点击确定。</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ali-7.png" alt=""></p><p>4.将/msg_demo/alicom-mns-receive下的sendsms文件拷贝到你的项目中，将其中Access Key ID 、 Access Key Secret、签名名称、模板CODE替换成你自己的即可，还有接收短信的手机号，模板内容等，可以将main函数改成一个方法sendMsg(string phone,string code)，直接调用方法即可，参数改为接收短信的手机号和短信内容：</p><pre><code>namespace ConsoleApplication1{class sendsms{    static String product = &quot;Dysmsapi&quot;;//短信API产品名称    static String domain = &quot;dysmsapi.aliyuncs.com&quot;;//短信API产品域名    static String accessId = &quot;你的Key&quot;;    static String accessSecret = &quot;你的Secret&quot;;    static String regionIdForPop = &quot;cn-hangzhou&quot;;   public  static void sendMsg(string phone,string code)    {        IClientProfile profile = DefaultProfile.GetProfile(regionIdForPop, accessId, accessSecret);        DefaultProfile.AddEndpoint(regionIdForPop, regionIdForPop, product, domain);        IAcsClient acsClient = new DefaultAcsClient(profile);        SendSmsRequest request = new SendSmsRequest();        try        {            //request.SignName = &quot;上云预发测试&quot;;//&quot;管理控制台中配置的短信签名（状态必须是验证通过）&quot;            //request.TemplateCode = &quot;SMS_71130001&quot;;//管理控制台中配置的审核通过的短信模板的模板CODE（状态必须是验证通过）&quot;            //request.RecNum = &quot;13567939485&quot;;//&quot;接收号码，多个号码可以逗号分隔&quot;            //request.ParamString = &quot;{\&quot;name\&quot;:\&quot;123\&quot;}&quot;;//短信模板中的变量；数字需要转换为字符串；个人用户每个变量长度必须小于15个字符。&quot;            //SingleSendSmsResponse httpResponse = client.GetAcsResponse(request);            request.PhoneNumbers = phone;//接收短信的手机号            request.SignName = &quot;签名名称&quot;;            request.TemplateCode = &quot;模板CODE&quot;;            request.TemplateParam = &quot;{\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;}&quot;;//模板内容           // request.OutId = &quot;xxxxxxxx&quot;;  //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者            //请求失败这里会抛ClientException异常            SendSmsResponse sendSmsResponse = acsClient.GetAcsResponse(request);            System.Console.WriteLine(sendSmsResponse.Message);        }        catch (ServerException e)        {            System.Console.WriteLine(&quot;ServerException&quot;);        }        catch (ClientException e)        {            System.Console.WriteLine(&quot;ClientException&quot;);        }    }}}</code></pre><p>5.运行程序，调用发送短信方法进行测试，测试成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、首先申请签名和模板&quot;&gt;&lt;a href=&quot;#一、首先申请签名和模板&quot; class=&quot;headerlink&quot; title=&quot;一、首先申请签名和模板&quot;&gt;&lt;/a&gt;一、首先申请签名和模板&lt;/h1&gt;&lt;p&gt;1.登陆阿里云官网，找到短信服务，开通以后进入管理控制台，找到签名管
      
    
    </summary>
    
      <category term="C#" scheme="https://wanglinyong.github.io/categories/C/"/>
    
    
      <category term="C#" scheme="https://wanglinyong.github.io/tags/C/"/>
    
      <category term="发短信" scheme="https://wanglinyong.github.io/tags/%E5%8F%91%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序日期格式化</title>
    <link href="https://wanglinyong.github.io/2018/05/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://wanglinyong.github.io/2018/05/11/微信小程序日期格式化/</id>
    <published>2018-05-11T12:15:18.000Z</published>
    <updated>2018-05-14T12:46:48.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-微信小程序util-js下有一个日期格式化函数"><a href="#1-微信小程序util-js下有一个日期格式化函数" class="headerlink" title="1.微信小程序util.js下有一个日期格式化函数"></a>1.微信小程序util.js下有一个日期格式化函数</h2><pre><code>const formatTime = date =&gt; {  var date = new Date(date);    const year = date.getFullYear()  const month = date.getMonth() + 1  const day = date.getDate()  const hour = date.getHours()  const minute = date.getMinutes()  const second = date.getSeconds()  return [year, month, day].map(formatNumber).join(&apos;-&apos;) + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)}module.exports = {  formatTime: formatTime}</code></pre><p>但是它原来是没有下面的这段代码的  它要求传入的data是一个日期参数，为了方便将日期字符串作为参数传递，将date转换一下（这里的参数date就是日期字符串）：</p><pre><code>var date = new Date(date);  </code></pre><h2 id="2-获取后台的list列表数据后，遍历对其进行日期格式化："><a href="#2-获取后台的list列表数据后，遍历对其进行日期格式化：" class="headerlink" title="2.获取后台的list列表数据后，遍历对其进行日期格式化："></a>2.获取后台的list列表数据后，遍历对其进行日期格式化：</h2><p>引入util.js</p><pre><code>var util = require(&apos;../../utils/util.js&apos;);</code></pre><p>评论列表日期格式化代码：</p><pre><code>  if (res.data.result == 0) {  let comms = res.data.lists  console.log(comms)  for(let c in comms){    let  date = util.formatTime(comms[c].ctime)    comms[c].ctime = date  }  that.setData({    commentList: comms || [],    bookIsBuy: res.data.is_buy  });  setTimeout(function () {    that.setData({      commentLoading: false    });  }, 500);} </code></pre><p>调用util.js中的方法</p><pre><code>let  date = util.formatTime(comms[c].ctime)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-微信小程序util-js下有一个日期格式化函数&quot;&gt;&lt;a href=&quot;#1-微信小程序util-js下有一个日期格式化函数&quot; class=&quot;headerlink&quot; title=&quot;1.微信小程序util.js下有一个日期格式化函数&quot;&gt;&lt;/a&gt;1.微信小程序util
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序Java登录流程</title>
    <link href="https://wanglinyong.github.io/2018/05/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FJava%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"/>
    <id>https://wanglinyong.github.io/2018/05/10/微信小程序Java登录流程/</id>
    <published>2018-05-10T12:48:25.000Z</published>
    <updated>2018-05-10T13:17:06.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、登录流程图"><a href="#一、登录流程图" class="headerlink" title="一、登录流程图"></a>一、登录流程图</h1><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/wx-login.png" alt=""></p><h1 id="二、微信小程序端"><a href="#二、微信小程序端" class="headerlink" title="二、微信小程序端"></a>二、微信小程序端</h1><pre><code>doLogin:function(callback = () =&gt;{}){let that = this;wx.login({  success:function(loginRes){    if(loginRes){      //获取用户信息      wx.getUserInfo({        withCredentials:true,//非必填  默认为true        success:function(infoRes){          console.log(infoRes,&apos;&gt;&gt;&gt;&apos;);          //请求服务端的登录接口          wx.request({            url: api.loginUrl,            data:{              code:loginRes.code,//临时登录凭证              rawData:infoRes.rawData,//用户非敏感信息              signature:infoRes.signature,//签名              encrypteData:infoRes.encryptedData,//用户敏感信息              iv:infoRes.iv//解密算法的向量            },            success:function(res){              console.log(&apos;login success&apos;);              res = res.data;              if(res.result==0){                that.globalData.userInfo = res.userInfo;                wx.setStorageSync(&apos;userInfo&apos;,JSON.stringify(res.userInfo));                wx.setStorageSync(&apos;loginFlag&apos;,res.skey);                console.log(&quot;skey=&quot;+res.skey);                callback();              }else{                that.showInfo(&apos;res.errmsg&apos;);              }            },            fail:function(error){              //调用服务端登录接口失败             // that.showInfo(&apos;调用接口失败&apos;);              console.log(error);            }          });        }      });    }else{    }  }});}</code></pre><p>微信小程序端发起登录请求，携带的参数主要有：</p><pre><code>code:loginRes.code,//临时登录凭证rawData:infoRes.rawData,//用户非敏感信息signature:infoRes.signature,//签名encrypteData:infoRes.encryptedData,//用户敏感信息iv:infoRes.iv//解密算法的向量</code></pre><p>需要的数据主要有：</p><pre><code>result、userInfo和skey</code></pre><p>result用来判断是否登录成功，userInfo是用户的一些信息，保存在缓存中，不用每次都从后台获取，skey是用户登录态标识，也放在缓存中，如果skey存在就直接登录，维护用户的登录状态，具有时效性</p><h1 id="三、Java后台"><a href="#三、Java后台" class="headerlink" title="三、Java后台"></a>三、Java后台</h1><pre><code>@ResponseBody@RequestMapping(&quot;/login&quot;)public Map&lt;String,Object&gt; doLogin(Model model,                                  @RequestParam(value = &quot;code&quot;,required = false) String code,                                  @RequestParam(value = &quot;rawData&quot;,required = false) String rawData,                                  @RequestParam(value = &quot;signature&quot;,required = false) String signature,                                  @RequestParam(value = &quot;encrypteData&quot;,required = false) String encrypteData,                                  @RequestParam(value = &quot;iv&quot;,required = false) String iv){    log.info( &quot;Start get SessionKey&quot; );    Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(  );    System.out.println(&quot;用户非敏感信息&quot;+rawData);    JSONObject rawDataJson = JSON.parseObject( rawData );    System.out.println(&quot;签名&quot;+signature);    JSONObject SessionKeyOpenId = getSessionKeyOrOpenId( code );    System.out.println(&quot;post请求获取的SessionAndopenId=&quot;+SessionKeyOpenId);    String openid = SessionKeyOpenId.getString(&quot;openid&quot; );    String sessionKey = SessionKeyOpenId.getString( &quot;session_key&quot; );    System.out.println(&quot;openid=&quot;+openid+&quot;,session_key=&quot;+sessionKey);    User user = userService.findByOpenid( openid );    //uuid生成唯一key    String skey = UUID.randomUUID().toString();    if(user==null){        //入库        String nickName = rawDataJson.getString( &quot;nickName&quot; );        String avatarUrl = rawDataJson.getString( &quot;avatarUrl&quot; );        String gender  = rawDataJson.getString( &quot;gender&quot; );        String city = rawDataJson.getString( &quot;city&quot; );        String country = rawDataJson.getString( &quot;country&quot; );        String province = rawDataJson.getString( &quot;province&quot; );        user = new User();        user.setUid( openid );        user.setCreateTime( new Date(  ) );        user.setSessionkey( sessionKey );        user.setUbalance( 0 );        user.setSkey( skey );        user.setUaddress( country+&quot; &quot;+province+&quot; &quot;+city );        user.setUavatar( avatarUrl );        user.setUgender( Integer.parseInt( gender ) );        user.setUname( nickName );        user.setUpdateTime( new Date(  ) );        userService.insert( user );    }else {        //已存在        log.info( &quot;用户openid已存在,不需要插入&quot; );    }    //根据openid查询skey是否存在    String skey_redis = (String) redisTemplate.opsForValue().get( openid );    if(StringUtils.isNotBlank( skey_redis )){        //存在 删除 skey 重新生成skey 将skey返回        redisTemplate.delete( skey_redis );    }        //  缓存一份新的        JSONObject sessionObj = new JSONObject(  );        sessionObj.put( &quot;openId&quot;,openid );        sessionObj.put( &quot;sessionKey&quot;,sessionKey );        redisTemplate.opsForValue().set( skey,sessionObj.toJSONString() );        redisTemplate.opsForValue().set( openid,skey );        //把新的sessionKey和oppenid返回给小程序        map.put( &quot;skey&quot;,skey );    map.put( &quot;result&quot;,&quot;0&quot; );    JSONObject userInfo = getUserInfo( encrypteData, sessionKey, iv );    System.out.println(&quot;根据解密算法获取的userInfo=&quot;+userInfo);    userInfo.put( &quot;balance&quot;,user.getUbalance() );    map.put( &quot;userInfo&quot;,userInfo );    return map;}</code></pre><p>获取openid和sessionKey方法</p><pre><code>public static JSONObject getSessionKeyOrOpenId(String code){    //微信端登录code    String wxCode = code;    String requestUrl = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;    Map&lt;String,String&gt; requestUrlParam = new HashMap&lt;String, String&gt;(  );    requestUrlParam.put( &quot;appid&quot;,&quot;你的小程序appId&quot; );//小程序appId    requestUrlParam.put( &quot;secret&quot;,&quot;你的小程序appSecret&quot; );    requestUrlParam.put( &quot;js_code&quot;,wxCode );//小程序端返回的code    requestUrlParam.put( &quot;grant_type&quot;,&quot;authorization_code&quot; );//默认参数    //发送post请求读取调用微信接口获取openid用户唯一标识    JSONObject jsonObject = JSON.parseObject( UrlUtil.sendPost( requestUrl,requestUrlParam ));    return jsonObject;}</code></pre><p>解密用户敏感数据获取用户信息</p><pre><code>public static JSONObject getUserInfo(String encryptedData,String sessionKey,String iv){    // 被加密的数据    byte[] dataByte = Base64.decode(encryptedData);    // 加密秘钥    byte[] keyByte = Base64.decode(sessionKey);    // 偏移量    byte[] ivByte = Base64.decode(iv);    try {        // 如果密钥不足16位，那么就补足.  这个if 中的内容很重要        int base = 16;        if (keyByte.length % base != 0) {            int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0);            byte[] temp = new byte[groups * base];            Arrays.fill(temp, (byte) 0);            System.arraycopy(keyByte, 0, temp, 0, keyByte.length);            keyByte = temp;        }        // 初始化        Security.addProvider(new BouncyCastleProvider());        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;,&quot;BC&quot;);        SecretKeySpec spec = new SecretKeySpec(keyByte, &quot;AES&quot;);        AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;AES&quot;);        parameters.init(new IvParameterSpec(ivByte));        cipher.init( Cipher.DECRYPT_MODE, spec, parameters);// 初始化        byte[] resultByte = cipher.doFinal(dataByte);        if (null != resultByte &amp;&amp; resultByte.length &gt; 0) {            String result = new String(resultByte, &quot;UTF-8&quot;);            return JSON.parseObject(result);        }    } catch (NoSuchAlgorithmException e) {        log.error(e.getMessage(), e);    } catch (NoSuchPaddingException e) {        log.error(e.getMessage(), e);    } catch (InvalidParameterSpecException e) {        log.error(e.getMessage(), e);    } catch (IllegalBlockSizeException e) {        log.error(e.getMessage(), e);    } catch (BadPaddingException e) {        log.error(e.getMessage(), e);    } catch (UnsupportedEncodingException e) {        log.error(e.getMessage(), e);    } catch (InvalidKeyException e) {        log.error(e.getMessage(), e);    } catch (InvalidAlgorithmParameterException e) {        log.error(e.getMessage(), e);    } catch (NoSuchProviderException e) {        log.error(e.getMessage(), e);    }    return null;}</code></pre><h1 id="四、流程"><a href="#四、流程" class="headerlink" title="四、流程"></a>四、流程</h1><p>1.小程序端发起请求并携带主要参数</p><p>2.java后台接到/login请求后，根据code去调用微信接口获取用户唯一标识openid和sessionKey</p><p>3.根据openid查询mysql数据库，判断该用户是否存在，如果不存在将用户非敏感信息和其他初始化数据存入到数据库中，如果已存在，不操作</p><p>4.根据openid查询redis数据库，判断openid对应的skey是否存在，如果存在则删除原来老的skey以及对应的openid和sessionKey</p><p>5.通过uuid生成唯一的skey，用openid做键，skey做值，存入到redis中</p><p>6.然后把skey做键，openid和sessionKey的json串做值也重新存入到redis中</p><p>7.根据解密算法，参数有encryptedData、sessionKey和iv，获取用户信息userInfo,如果userInfo字段不满足需要，可通过userInfo.put( “balance”,user.getUbalance() );添加所需要的字段和值</p><p>8.将微信小程序需要的数据封装到map中，返回给小程序端</p><pre><code>map.put( &quot;skey&quot;,skey );map.put( &quot;result&quot;,&quot;0&quot; );map.put( &quot;userInfo&quot;,userInfo );    return map;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、登录流程图&quot;&gt;&lt;a href=&quot;#一、登录流程图&quot; class=&quot;headerlink&quot; title=&quot;一、登录流程图&quot;&gt;&lt;/a&gt;一、登录流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wiki/w
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信登录" scheme="https://wanglinyong.github.io/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>web调试代理工具Whistle</title>
    <link href="https://wanglinyong.github.io/2018/05/10/Whistle/"/>
    <id>https://wanglinyong.github.io/2018/05/10/Whistle/</id>
    <published>2018-05-10T12:15:18.000Z</published>
    <updated>2018-05-10T13:14:40.425Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。</p><p>完成https代理请求总共需要5个步骤。</p><h1 id="一、安装Node-js"><a href="#一、安装Node-js" class="headerlink" title="一、安装Node.js"></a>一、安装Node.js</h1><p>下载地址：</p><pre><code>https://nodejs.org/en/</code></pre><p>下载长期支持版：LTS版本</p><p>下载后按步骤进行安装，安装完成后打开cmd命令窗口，执行</p><pre><code>$ node -v</code></pre><p>查看版本号，如果出现版本号即安装正确。</p><pre><code>v8.11.1</code></pre><h1 id="二、安装并启动Whistle"><a href="#二、安装并启动Whistle" class="headerlink" title="二、安装并启动Whistle"></a>二、安装并启动Whistle</h1><h2 id="1-安装Whistle"><a href="#1-安装Whistle" class="headerlink" title="1.安装Whistle"></a>1.安装Whistle</h2><p>打开cmd命令窗口，执行</p><pre><code>$ npm install -g whistle</code></pre><p>npm默认镜像是在国外，有时候安装速度很慢或者出现安装不了的情况，如果无法安装或者安装很慢，可以使用taobao的镜像安装：</p><pre><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org$ cnpm install -g whistle</code></pre><p>或者直接指定镜像安装：</p><pre><code>$ npm install whistle -g --registry=https://registry.npm.taobao.org</code></pre><h2 id="2-启动Whistle"><a href="#2-启动Whistle" class="headerlink" title="2.启动Whistle"></a>2.启动Whistle</h2><p>在cmd命令窗口中执行启动命令：</p><pre><code>w2 start</code></pre><p>停止命令：</p><pre><code>w2 stop</code></pre><p>重启命令：</p><pre><code>w2 restart</code></pre><h2 id="3-访问Whistle-访问网址："><a href="#3-访问Whistle-访问网址：" class="headerlink" title="3.访问Whistle,访问网址："></a>3.访问Whistle,访问网址：</h2><pre><code>127.0.0.1:8899</code></pre><h2 id="三、配置代理"><a href="#三、配置代理" class="headerlink" title="三、配置代理"></a>三、配置代理</h2><p>打开控制面板–&gt;网络和 Internet–&gt;Internet 选项–&gt;连接–&gt;局域网设置</p><p>勾选 为LAN使用代理服务器</p><pre><code>地址(E): 127.0.0.1 端口(T): 8899</code></pre><p>然后确定配置。</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle.png" alt=""></p><p>此时就可以配置http请求转发了</p><p>1.打开whistle网页（127.0.0.1:8899）</p><p>2.在Rules规则中有一个默认的Default窗口，在此可以配置转发请求</p><pre><code>www.myurl.com 127.0.0.1:8080</code></pre><p>这样访问www.myurl.com就会访问127.0.0.1:8080这个地址</p><p>如果不在Default窗口配置，也可以自己新建一个，点击Create创建</p><p>这样只能代理非https请求  如果想代理https请求还得下载https安全证书</p><h1 id="四、下载https安全证书"><a href="#四、下载https安全证书" class="headerlink" title="四、下载https安全证书"></a>四、下载https安全证书</h1><p>点击whistle网页上的HTTPS,会出现一个二维码，在二维码上方有一个Download RootCA,点击下载，在二维码下方有一个Capture HTTPS CONNECTs单选框，勾选表明拦截HTTPS请求。如图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-2.png" alt=""></p><p>htpps安全证书下载好以后，打开 –&gt;安装证书–&gt;将所有的证书放入下列存储–&gt;受信任的根证书颁发机构。如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-3.png" alt=""></p><p>下载安装完成以后得重新配置转发请求。</p><h2 id="五、配置请求转发"><a href="#五、配置请求转发" class="headerlink" title="五、配置请求转发"></a>五、配置请求转发</h2><p>如果配置成：</p><pre><code>https://www.myurl.com 127.0.0.1:8080</code></pre><p>会报下面的错误</p><pre><code>From: whistle@1.9.10Node: v8.11.1Date: 2018-5-4 09:31:21Error: write EPROTO 101057795:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:openssl\ssl\s23_clnt.c:827:at _errnoException (util.js:1022:11)at WriteWrap.afterWrite [as oncomplete] (net.js:880:14)</code></pre><p>是因为没办法用https请求去访问http服务器，改成下面的配置就OK</p><pre><code>www.myurl.com 127.0.0.1:8080 http://www.myurl.com</code></pre><p>这样访问<a href="https://www.myurl.com" target="_blank" rel="external">https://www.myurl.com</a> 就可以访问127.0.0.1:8080这个地址了。</p><p>记得开启拦截HTTPS：勾选 Capture HTTPS CONNECTs</p><p>点击Network可以查看请求信息，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/whistle-4.png" alt=""></p><p>这只是Whistle的冰山一角，了解更多功能请访问：</p><pre><code>http://wproxy.org/whistle/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近在学习微信小程序开发，项目中用到了https代理请求，所以用到了基于Node实现的跨平台web调试代理工具Whistle，在此做一记录。&lt;/p&gt;
&lt;p&gt;完成https代理请求总共需要5个步骤。&lt;/p&gt;
&lt;h1 id=&quot;一、安装Node-js&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="whistle" scheme="https://wanglinyong.github.io/categories/whistle/"/>
    
    
      <category term="whistle" scheme="https://wanglinyong.github.io/tags/whistle/"/>
    
      <category term="web调试工具" scheme="https://wanglinyong.github.io/tags/web%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>linux文件服务器httpd开机自启动</title>
    <link href="https://wanglinyong.github.io/2018/04/27/linux%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8httpd%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/27/linux文件服务器httpd开机自启动/</id>
    <published>2018-04-27T12:15:18.000Z</published>
    <updated>2018-04-27T12:15:08.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、相关命令"><a href="#一、相关命令" class="headerlink" title="一、相关命令"></a>一、相关命令</h1><p>1.查看所有系统服务</p><pre><code>systemctl list-units --all --type=service</code></pre><p>2.查询服务状态</p><pre><code>systemctl status httpd.service</code></pre><p>3.查询服务是否为开机启动</p><pre><code>systemctl is-enabled httpd.service</code></pre><p>enabled是 disabled否</p><p>4.设置服务为开机启动状态</p><pre><code>systemctl enable httpd.service</code></pre><p>会自动创建一个系统链接</p><pre><code>Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.</code></pre><p>5.设置服务为开机不启动状态</p><p>systemctl disable httpd.service</p><p>会自动移除系统链接</p><pre><code>Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service.</code></pre><p>二、设置httpd开机自启动</p><pre><code>systemctl enable httpd.service</code></pre><p>重启即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、相关命令&quot;&gt;&lt;a href=&quot;#一、相关命令&quot; class=&quot;headerlink&quot; title=&quot;一、相关命令&quot;&gt;&lt;/a&gt;一、相关命令&lt;/h1&gt;&lt;p&gt;1.查看所有系统服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl list-units --all -
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="httpd" scheme="https://wanglinyong.github.io/tags/httpd/"/>
    
      <category term="文件服务器" scheme="https://wanglinyong.github.io/tags/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>linux系统mysql的远程访问</title>
    <link href="https://wanglinyong.github.io/2018/04/22/linux%E7%B3%BB%E7%BB%9Fmysql%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <id>https://wanglinyong.github.io/2018/04/22/linux系统mysql的远程访问/</id>
    <published>2018-04-22T02:46:18.000Z</published>
    <updated>2018-04-27T12:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建用户设置权限"><a href="#一、创建用户设置权限" class="headerlink" title="一、创建用户设置权限"></a>一、创建用户设置权限</h1><p>以root身份登录mysql</p><pre><code>[root@ ~]mysql -uroot -p[root@ ~]Enter password: xxxxxx</code></pre><p>创建用户</p><pre><code>mysql&gt;create user &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos;;</code></pre><p>授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>其中’wanglinyong’@’%’是允许该用户在任何主机上远程连接，如果只允许在某一台主机上连接，可指定ip</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;10.xx.xx.x&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>授权之后记得要刷新权限</p><pre><code>mysql&gt;flush privileges;</code></pre><h1 id="二、Navicate远程连接测试"><a href="#二、Navicate远程连接测试" class="headerlink" title="二、Navicate远程连接测试"></a>二、Navicate远程连接测试</h1><p>1.如果连接失败，提示：</p><pre><code>1045-Access denied for user&apos;wanglinyong&apos;@&apos;ip&apos;(using password:YES)</code></pre><p>则表示密码输入错误。</p><p>2.如果提示：</p><pre><code>ERROR 2003(HY000): Can’t connect to MySQL server on xxxxx</code></pre><p>如果服务器是阿里云的，可能没有开通3306端口，要去服务器上添加安全组，增加3360端口即可</p><p>3.Navicate连接成功后，只有information_schema一个数据库</p><p>在linux系统以root用户登录</p><p>先查一下其他数据库是否被删除</p><pre><code>mysql&gt;show databases;</code></pre><p>如果还在，查看下mysql库的用户表</p><pre><code>mysql&gt;select host,user from mysql.user;</code></pre><p>结果如下：</p><pre><code>+----------------+-----------------+| host           | user            |+----------------+-----------------+| %              | wanglinyong     || localhost      | mysql.session   || localhost      | root            |+----------------+-----------------+3 rows in set (0.00 sec)</code></pre><p>说明wanglinyong用户允许在任何远程主机登录</p><p>然后查看，远程登录的用户是否有权限</p><pre><code>mysql&gt; show grants for &apos;wanglinyong&apos;@&apos;%&apos;;</code></pre><p>结果不是</p><pre><code>GRANT ALL PRIVILEGES ON *.* TO &apos;wanglinyong5112&apos;@&apos;%&apos; WITH GRANT OPTION </code></pre><p>说明权限不够，重新授权</p><pre><code>mysql&gt;grant all privileges on *.* to &apos;wanglinyong&apos;@&apos;%&apos; identified by &apos;wanglinyong9527&apos; with grant option;</code></pre><p>刷新权限：</p><pre><code>mysql&gt;flush privileges;</code></pre><p>重新连接应该就OK了！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果还不行, vi /etc/mysql/mysql.conf.d/mysqld.cnf,检查下是否有</p><pre><code>bind-address = 127.0.0.1</code></pre><p>如果有，请把它注释掉（加#号注释）。如果找不到mysqld.cnf,有的可能在 /etc/my.cnf文件内</p><p>保存退出后重启mysql服务</p><pre><code>sudo /etc/init.d/mysql restart</code></pre><p>或者</p><pre><code>systemctl restart mysqld</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、创建用户设置权限&quot;&gt;&lt;a href=&quot;#一、创建用户设置权限&quot; class=&quot;headerlink&quot; title=&quot;一、创建用户设置权限&quot;&gt;&lt;/a&gt;一、创建用户设置权限&lt;/h1&gt;&lt;p&gt;以root身份登录mysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@ ~
      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
      <category term="Mysql" scheme="https://wanglinyong.github.io/tags/Mysql/"/>
    
      <category term="远程访问" scheme="https://wanglinyong.github.io/tags/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>JAVA十六进制数据接收与传输</title>
    <link href="https://wanglinyong.github.io/2018/04/17/JAVA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E4%B8%8E%E4%BC%A0%E8%BE%93/"/>
    <id>https://wanglinyong.github.io/2018/04/17/JAVA十六进制数据接收与传输/</id>
    <published>2018-04-17T14:28:56.000Z</published>
    <updated>2018-04-22T02:05:12.243Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。</p><h1 id="一、十六进制转换工具类"><a href="#一、十六进制转换工具类" class="headerlink" title="一、十六进制转换工具类"></a>一、十六进制转换工具类</h1><p>主要包含十六进制字符串转ASCII，ASCII转十六进制字符串以及十六进制字符串转Byte数组等方法：</p><pre><code> /**   * Created by wly on 2018/4/17.  */public class HexConvert {public static String  convertStringToHex(String str){char[] chars = str.toCharArray();StringBuffer hex = new StringBuffer();for(int i = 0; i &lt; chars.length; i++){    hex.append(Integer.toHexString((int)chars[i]));}return hex.toString();}public static String convertHexToString(String hex){StringBuilder sb = new StringBuilder();StringBuilder sb2 = new StringBuilder();for( int i=0; i&lt;hex.length()-1; i+=2 ){    String s = hex.substring(i, (i + 2));               int decimal = Integer.parseInt(s, 16);              sb.append((char)decimal);    sb2.append(decimal);}return sb.toString();}public static byte[] hexStringToBytes(String hexString) {    if (hexString == null || hexString.equals(&quot;&quot;)) {            return null;}        // toUpperCase将字符串中的所有字符转换为大写        hexString = hexString.toUpperCase();        int length = hexString.length() / 2;        // toCharArray将此字符串转换为一个新的字符数组。    char[] hexChars = hexString.toCharArray();    byte[] d = new byte[length];for (int i = 0; i &lt; length; i++) {    int pos = i * 2;    d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[pos + 1]));}        return d;}    //返回匹配字符private static byte charToByte(char c) {    return (byte) &quot;0123456789ABCDEF&quot;.indexOf(c);}//将字节数组转换为short类型，即统计字符串长度public static short bytes2Short2(byte[] b) {       short i = (short) (((b[1] &amp; 0xff) &lt;&lt; 8) | b[0] &amp; 0xff);    return i;}//将字节数组转换为16进制字符串public static String BinaryToHexString(byte[] bytes) {    String hexStr = &quot;0123456789ABCDEF&quot;;    String result = &quot;&quot;;    String hex = &quot;&quot;;for (byte b : bytes) {    hex = String.valueOf(hexStr.charAt((b &amp; 0xF0) &gt;&gt; 4));    hex += String.valueOf(hexStr.charAt(b &amp; 0x0F));    result += hex + &quot; &quot;;}return result;}public static void main(String[] args) {System.out.println(&quot;======ASCII码转换为16进制======&quot;);String str = &quot;*00007VERSION\\n1$&quot;;System.out.println(&quot;字符串: &quot; + str);String hex = HexConvert.convertStringToHex(str);System.out.println(&quot;====转换为16进制=====&quot; + hex);System.out.println(&quot;======16进制转换为ASCII======&quot;);System.out.println(&quot;Hex : &quot; + hex);System.out.println(&quot;ASCII : &quot; + HexConvert.convertHexToString(hex));byte[] bytes = HexConvert.hexStringToBytes( hex );System.out.println(HexConvert.BinaryToHexString( bytes ));}}</code></pre><h1 id="二、接收数据"><a href="#二、接收数据" class="headerlink" title="二、接收数据"></a>二、接收数据</h1><pre><code>public class UdpReceiverThread {public static void main(String[] args) throws Exception {// 定义一个接收端，并且指定了接收的端口号DatagramSocket socket = new DatagramSocket(6070);while (true) {byte[] buf = new byte[1024*5];// 解析数据包DatagramPacket packet = new DatagramPacket(buf, buf.length);socket.receive(packet);String ip = packet.getAddress().getHostAddress();buf = packet.getData();//将字节数组转换为16进制字符串String hexString = HexConvert.BinaryToHexString( buf );//含有空格，如：2A 30 30 30 30 37 56 45 52 53 49 4F 4E 5C 6E 31 24 hexString =  hexString.replace( &quot; &quot;,&quot;&quot; );//去除空格String asc = HexConvert.convertHexToString( hexString );//转为ASCII,如：*00007VERSION\n1$System.out.println(&quot;收到 &quot; + ip + &quot; 发来的消息：&quot; + asc);}}}</code></pre><h1 id="三、发送数据"><a href="#三、发送数据" class="headerlink" title="三、发送数据"></a>三、发送数据</h1><pre><code>public class UDPSenderThread {public static void main(String[] args) throws Exception {DatagramSocket socket = new DatagramSocket();String serial = &quot;*00007VERSION\\n1$&quot;;//串口字符串String hex = HexConvert.convertStringToHex(serial);//转化为十六进制字符串：2a303030303756455253494f4e5c6e3124byte[] buf = HexConvert.hexStringToBytes( hex );//将十六进制字符串转为字节数组//将数据打包DatagramPacket packet = new DatagramPacket(buf, buf.length, InetAddress.getByName(&quot;192.168.11.139&quot;), 6070);socket.send(packet);socket.close();}}</code></pre><h2 id="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"><a href="#在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。" class="headerlink" title="在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。"></a>在此基础上进行封装、抽象后即可处理十六进制数据的传输与接收问题。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目中经常遇到与设备进行交互获取数据，不仅有Python版本、还有Java版本，还可能会有C#版本，在此做个记录。&lt;/p&gt;
&lt;h1 id=&quot;一、十六进制转换工具类&quot;&gt;&lt;a href=&quot;#一、十六进制转换工具类&quot; class=&quot;headerlink&quot; title=&quot;一、十
      
    
    </summary>
    
      <category term="Java" scheme="https://wanglinyong.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wanglinyong.github.io/tags/Java/"/>
    
      <category term="十六进制" scheme="https://wanglinyong.github.io/tags/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>BadBoy+Jmeter压力测试</title>
    <link href="https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>https://wanglinyong.github.io/2018/04/10/BadBoy+Jmeter压力测试/</id>
    <published>2018-04-10T11:42:48.000Z</published>
    <updated>2018-04-10T11:28:32.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、下载BadBoy和Jmeter"><a href="#一、下载BadBoy和Jmeter" class="headerlink" title="一、下载BadBoy和Jmeter"></a>一、下载BadBoy和Jmeter</h1><h2 id="1-下载链接"><a href="#1-下载链接" class="headerlink" title="1.下载链接"></a>1.下载链接</h2><p>BadBoy</p><pre><code>http://www.badboy.com.au/download/index</code></pre><p>Jmeter</p><pre><code>http://jmeter.apache.org/download_jmeter.cgi</code></pre><h2 id="2-下载过程如图"><a href="#2-下载过程如图" class="headerlink" title="2.下载过程如图"></a>2.下载过程如图</h2><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-1.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-1.png" alt=""></p><h2 id="3-解压并配置环境变量"><a href="#3-解压并配置环境变量" class="headerlink" title="3.解压并配置环境变量"></a>3.解压并配置环境变量</h2><p>将下载好的BadBoy和Jmeter解压到合适的地方</p><p>配置环境变量</p><pre><code>变量名称：JMETER_HOME变量值：  G:\wly\apache-jmeter-4.0</code></pre><p> 在classpath后面加入：                          </p><pre><code>%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;</code></pre><h2 id="二、录制Jmeter脚本"><a href="#二、录制Jmeter脚本" class="headerlink" title="二、录制Jmeter脚本"></a>二、录制Jmeter脚本</h2><h2 id="1-打开BadBoy"><a href="#1-打开BadBoy" class="headerlink" title="1.打开BadBoy"></a>1.打开BadBoy</h2><p>（1）点击badboy.exe ,打开BadBoy,界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-3.png" alt=""></p><p>（2）输入URL，点击回车开始录制</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-4.png" alt=""></p><p>（3）此时左侧script下多了一条记录，右侧出现调试页面的首页</p><p>然后点击登录，访问首页，然后退出，badboy界面如下，总共有五条记录</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/bd-5.png" alt=""></p><p>（4）接下来导出jmter脚本，点击</p><pre><code>file-&gt;Export to Jmeter</code></pre><p>导出后缀为.jmx的文件</p><h2 id="2-打开Jmeter"><a href="#2-打开Jmeter" class="headerlink" title="2.打开Jmeter"></a>2.打开Jmeter</h2><p>（1）进入Jmeter的bin目录，点击jmeter.bat运行Jmeter</p><p>（2）File-&gt;Open打开刚才导出的jmeter脚本 界面如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-2.png" alt=""></p><p>（3）Thread Group线程组就是定义并发数量的，step就是压测的步骤。<br>Number of Threads(users) 表示线程数量，如果设置为5000，就是模拟5000个人不断重复刚才的 首页-&gt;登录-&gt;首页-&gt;退出 操作</p><p>Ram-Up Period(in seconds)表示间隔时间</p><p>Loop Count 表示循环次数</p><p>压力测试：线程数越多压力越大，间隔时间越短压力越大</p><p>（4）添加监听器</p><p>添加聚合报告、查看结果树和用表格查看，如下图：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-3.png" alt=""></p><p>（5）运行</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-4.png" alt=""></p><p>（6）查看结果</p><p>查看结果树，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-5.png" alt=""></p><p>聚合报告，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-6.png" alt=""></p><p>表格查看，如下：</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/jm-7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;a href=&quot;#一、下载BadBoy和Jmeter&quot; class=&quot;headerlink&quot; title=&quot;一、下载BadBoy和Jmeter&quot;&gt;&lt;/a&gt;一、下载BadBoy和Jmeter&lt;/h1&gt;&lt;h2 id=&quot;1-下载链
      
    
    </summary>
    
      <category term="性能测试" scheme="https://wanglinyong.github.io/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="https://wanglinyong.github.io/tags/Jmeter/"/>
    
      <category term="BadBoy" scheme="https://wanglinyong.github.io/tags/BadBoy/"/>
    
  </entry>
  
  <entry>
    <title>linux系统搭建文件服务器</title>
    <link href="https://wanglinyong.github.io/2018/04/06/linux%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wanglinyong.github.io/2018/04/06/linux系统搭建文件服务器/</id>
    <published>2018-04-06T02:48:23.000Z</published>
    <updated>2018-04-10T11:26:35.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装-httpd-服务"><a href="#一、安装-httpd-服务" class="headerlink" title="一、安装 httpd 服务"></a>一、安装 httpd 服务</h2><pre><code>yum install httpd</code></pre><p>查看版本号</p><pre><code>httpd -version</code></pre><h2 id="二、启动-httpd-服务"><a href="#二、启动-httpd-服务" class="headerlink" title="二、启动 httpd 服务"></a>二、启动 httpd 服务</h2><pre><code>service httpd start</code></pre><h2 id="三、容易出现的问题"><a href="#三、容易出现的问题" class="headerlink" title="三、容易出现的问题"></a>三、容易出现的问题</h2><p>1.防火墙未开放端口</p><pre><code>开启端口：firewall-cmd --zone=public --add-port=8989/tcp --permanent重启防火墙：firewall-cmd --reload 查看已开放端口：firewall-cmd --list-ports</code></pre><p>2.端口被占用</p><pre><code>更改端口号</code></pre><p>修改配置文件，默认路径是</p><pre><code>/etc/httpd/conf/httpd.conf </code></pre><p>主要修改以下内容</p><pre><code>Listen 80 --&gt; Listen 8987     #监听端口#ServerName www.example.com:80 --&gt; ServerName 192.168.120.132:8987    #服务名称ip:portDocumentRoot &quot;/var/www/html&quot; --&gt;  DocumentRoot &quot;/home/profile&quot;   #文件根目录&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径1&lt;Directory &quot;/var/www/html&quot;&gt; ---&gt;  &lt;Directory &quot;/home/profile&quot;&gt;  #文件路径2</code></pre><p>3.出现apache CentOS Permission denied: AH00072</p><p>关闭SELINUX</p><pre><code>setenforce 0</code></pre><p>修改配置文件</p><pre><code>vim /etc/selinux/configSELINUX=enforcing 改成--&gt; SELINUX=disabled</code></pre><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><pre><code>service httpd start</code></pre><p>停止服务</p><pre><code>service httpd stop</code></pre><h2 id="五、远程访问"><a href="#五、远程访问" class="headerlink" title="五、远程访问"></a>五、远程访问</h2><p>在浏览器中输入 ip:port 即可访问设置的 /home/profile 目录;</p><p><img src="https://raw.githubusercontent.com/wiki/wanglinyong/wanglinyong.github.io/ftp.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、安装-httpd-服务&quot;&gt;&lt;a href=&quot;#一、安装-httpd-服务&quot; class=&quot;headerlink&quot; title=&quot;一、安装 httpd 服务&quot;&gt;&lt;/a&gt;一、安装 httpd 服务&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;yum install httpd

      
    
    </summary>
    
      <category term="Linux" scheme="https://wanglinyong.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://wanglinyong.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
